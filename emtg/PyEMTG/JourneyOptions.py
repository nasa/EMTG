#PyEMTG JourneyOptions class
#auto-generated by make_EMTG_missionoptions_journeyoptions.py

class JourneyOptions(object):

    #************************************************************************************constructor
    def __init__(self, inputFile = None, lineNumber = None):
        self.journey_name = "default" #Journey name
        self.journey_central_body = "Sun" #Journey central body name
        self.destination_list = [3, 4] #destination list, as indices from the Universe file
        self.sequence = [] #flyby sequence, as indices from the Universe file
        self.phase_type = 2 #mission type, #0: MGALTS, #1: FBLTS, #2: MGALT, #3: FBLT, #4: PSBI, #5: PSFB, #6: MGAnDSMs, #7: CoastPhase, #8: SundmanCoastPhase, #9: variable (do not use), #10: ProbeEntryPhase, #11 ControlLawThrustPhase
        self.impulses_per_phase = 1 #impulses per phase
        self.thrust_control_law = 1 #Thrust control law,#0: Cartesian, #1: Velocity direction, #2: anti-velocity direction
        self.force_unit_magnitude_control = 0 #Force unit magnitude control?,#0: free control magnitude,#1: force unit magnitude,#2: force zero magnitude
        self.force_fixed_inertial_control = 0 #Force fixed inertial control? All control vectors in a phase must be identical if this is selected.
        self.override_num_steps = 0 #Override this journey's number of steps?
        self.number_of_steps = 20 #Number of time steps for this journey, if overriden
        self.override_duty_cycle = 0 #Journey override global duty cycle
        self.duty_cycle = 1 #Journey duty cycle
        self.override_PropagatorType = 0 #override propagator type?
        self.propagatorType = 1 #propagator type
        self.override_integration_step_size = 0 #Override global integration step size?
        self.integration_step_size = 86400 #integration step size (s)
        self.override_flyby_altitude_bounds = 0 #Override journey flyby altitude?
        self.flyby_altitude_bounds = [300.0, 1.0e+6] #Lower and upper bound on journey flyby altitude (only applies to the departure flyby, if there is one)
        self.PeriapseArrival_override_altitude = 1 #Override journey flyby altitude?
        self.PeriapseArrival_altitude_bounds = [300.0, 1.0e+6] #Lower and upper bound on journey flyby altitude (km)
        self.PeriapseDeparture_altitude_bounds = [185.0, 185.0] #PeriapseDeparture altitude bounds (in km)
        self.num_interior_control_points = 1 #number of interior control points for parallel shooting phase types
        self.CoastPhaseMatchPointFraction = 0.5 #coast phase match point fraction
        self.CoastPhaseForwardIntegrationStepLength = 86400 #coast phase forward integration step length (seconds)
        self.CoastPhaseBackwardIntegrationStepLength = 86400 #coast phase backward integration step length (seconds)
        self.journey_end_TCM = 0 #Journey-end TCM magnitude (km/s)
        self.enable_periapse_burns = 0 #Enable periapse burns in ephemeris pegged flybys?
        self.bounded_departure_date = 0 #Bound the departure epoch?
        self.timebounded = 0 #0: unbounded, 1: bounded flight time, 2: bounded arrival date
        self.departure_date_bounds = [0.0, 0.0] #MJD
        self.wait_time_bounds = [0.0, 1000.0] #days
        self.flight_time_bounds = [0.0, 0.0] #days
        self.arrival_date_bounds = [51544.5, 60000.0] #MJD
        self.departure_type = 0 #journey departure type, #0: launch or direct insertion, #1: depart from parking orbit (you can use this one in place of a launch vehicle model, and the departure burn will be done with the EDS motor), #2: free direct departure, i.e. do not burn to get the departure v_infinity (used for when operations about a small body are not modeled but the departure velocity is known), #3: flyby (only valid for successive journeys), #4: flyby with fixed v-infinity-out (only valid for successive journeys), #5: spiral-out from circular orbit (low-thrust missions only), #6: zero-turn flyby (for small bodies)
        self.initial_impulse_bounds = [0.0, 6.97] #what are the bounds on the initial impulse for each journey in km/s
        self.force_free_point_direct_insertion_along_velocity_vector = 0 #Force free point direct insertion burn to be along the inertial velocity vector?
        self.departure_elements_vary_flag = [0,0,0,0,0,0] #one entry for each element
        self.departure_elements = [0.0,0.0,0.0,0.0,0.0,0.0] #cartesian state or SMA, ECC, INC, RAAN, AOP, TA
        self.departure_elements_bounds = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] #bounds on elements or state components, two entries for each element
        self.departure_elements_reference_epoch = 51544.5 #MJD
        self.departure_elements_state_representation = 0 #departure free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)
        self.departure_elements_frame = 0 #reference frame for journey departure elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)
        self.AllowJourneyFreePointDepartureToPropagate = 0 #Allow journey departure free point boundary to propagate (otherwise it is a fixed waypoint)
        self.maximum_starting_mass_increment = 0 #negative number indicates mass drop
        self.minimum_starting_mass_increment = 0 #negative number indicates mass drop
        self.fixed_starting_mass_increment = 0 #negative number indicates mass drop
        self.fixed_ending_mass_increment = 0 #negative number indicates mass drop
        self.variable_mass_increment = 0 #Vary initial mass increment?
        self.constrain_initial_mass = 0 #Constrain initial mass?
        self.maximum_initial_mass = 0 #If initial mass for this journey is constrained, enter the constraint value here.
        self.departure_class = 0 #journey departure boundary class, #0: Ephemeris-pegged (default EMTG), #1: Free point, #2: Ephemeris-referenced, #3: Periapse
        self.departure_ellipsoid_axes = [1e-8,1e-8,1e-8] #journey departure ellipsoid axes (3)
        self.arrival_type = 3 #journey arrival type, #0: insertion into parking orbit (use chemical Isp), #1: rendezvous (use chemical Isp), #2: intercept with bounded V_infinity, #3: low-thrust rendezvous (does not work if terminal phase is not low-thrust), #4: match final v-infinity vector, #5: match final v-infinity vector (low-thrust), #6: capture spiral, #7: momentum transfer (kinetic impactor)
        self.arrival_elements_vary_flag = [0,0,0,0,0,0] #one entry for each element
        self.arrival_elements = [0.0,0.0,0.0,0.0,0.0,0.0] #cartesian state or SMA, ECC, INC, RAAN, AOP, TA
        self.arrival_elements_bounds = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] #bounds on elements or state components, two entries for each element
        self.arrival_elements_reference_epoch = 51544.5 #MJD
        self.arrival_elements_state_representation = 0 #arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)
        self.arrival_elements_frame = 0 #reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)
        self.AllowJourneyFreePointArrivalToPropagate = 0 #Allow journey arrival free point boundary to propagate (otherwise it is a fixed waypoint)
        self.final_velocity = [0.0, 20.0, 0.0] #Bounds on this journey's final velocity (in km/s)
        self.forced_terminal_coast = 0 #Journey forced terminal coast (in days)
        self.forced_initial_coast = 0 #Journey forced initial coast (in days)
        self.arrival_class = 0 #journey arrival boundary class, #0: Ephemeris-pegged (default EMTG), #1: Free point, #2: Ephemeris-referenced, #3: Periapse
        self.arrival_ellipsoid_axes = [1e-8,1e-8,1e-8] #journey arrival ellipsoid axes (3)
        self.zero_turn_flyby_distance = 1000 #encounter distance (from center of object) for a zero-turn flyby (km)
        self.terminal_intercept_flyby_distance = 1000 #encounter distance (from center of object) for an ephemeris-pegged intercept (km)
        self.escape_spiral_starting_radius = 6678 #Starting orbital radius for an Edelbaum escape spiral (km)
        self.escape_spiral_final_radius = 6678 #Final orbit radius for an Edelbaum escape spiral (km)
        self.capture_spiral_final_radius = 6678 #Final orbit radius for an Edelbaum capture spiral (km)
        self.capture_spiral_starting_radius = 6678 #Starting orbital radius for an Edelbaum capture spiral (km)
        self.FreePointArrival_print_target_spec = 1 #Print a target spec for free point arrival at the end of this journey?
        self.journey_end_deltav = 0 #Journey-end delta-v (km/s)
        self.journey_end_propulsion_system = 0 #Propulsion system for journey-end maneuver, #0: Monoprop chemical, #1: Biprop chemical, #2: Electric
        self.perturbation_bodies = [] #Universe file indices of each perturbation body
        self.stage_after_departure = 0 #Stage after departure?
        self.stage_before_arrival = 0 #Stage before arrival?
        self.stage_after_arrival = 0 #Stage after arrival?
        self.freeze_decision_variables = 0 #Freeze this journey's decision variables?
        self.ephemeris_pegged_orbit_insertion_SMA = 6678 #SMA (in km) for ephemeris pegged orbit insertion
        self.ephemeris_pegged_orbit_insertion_ECC = 0 #ECC for ephemeris pegged orbit insertion
        self.impact_momentum_enhancement_factor = 1 #Impact momentum enhancement factor for planetary defense (also called beta)
        self.perturb_drag = 0 #Aerodynamic drag?
        self.spacecraft_drag_area = 70 #spacecraft area (for aerodynamic drag, in m^2)
        self.coefficient_of_drag = 2.2 #coefficient of drag, i.e. Cd (unitless)
        self.AtmosphericDensityModelKey = "Exponential" #Atmospheric density model
        self.AtmosphericDensityModelDataFile = "DoesNotExist.emtg_densityopt" #File defining atmospheric density model
        self.probe_separation_impulse = 1 #Probe separation impulse (Ns)
        self.probe_mass = 100.0 #Probe mass (kg)
        self.Probe_AEI_elements_vary_flag = [0,0,0,0,0,0] #one entry for each element
        self.Probe_AEI_elements = [0.0,0.0,0.0,0.0,0.0,0.0] #cartesian state or SMA, ECC, INC, RAAN, AOP, TA
        self.Probe_AEI_elements_bounds = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] #bounds on elements or state components, two entries for each element
        self.Probe_AEI_elements_reference_epoch = 51544.5 #MJD
        self.Probe_AEI_elements_state_representation = 0 #probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)
        self.Probe_AEI_elements_frame = 0 #reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)
        self.Probe_End_elements_vary_flag = [0,0,0,0,0,0] #one entry for each element
        self.Probe_End_elements = [0.0,0.0,0.0,0.0,0.0,0.0] #cartesian state or SMA, ECC, INC, RAAN, AOP, TA
        self.Probe_End_elements_bounds = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] #bounds on elements or state components, two entries for each element
        self.Probe_End_elements_reference_epoch = 51544.5 #MJD
        self.Probe_End_elements_state_representation = 0 #probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)
        self.Probe_End_elements_frame = 0 #reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)
        self.ModelProbeSecondPhase = 0 #Model the probe's descent phase
        self.AllowJourneyProbeAEIToPropagate = 0 #Allow probe AEI free point boundary to propagate (otherwise it is a fixed waypoint)
        self.AllowJourneyProbeEndToPropagate = 0 #Allow probe end free point boundary to propagate (otherwise it is a fixed waypoint)
        self.probe_communication_distance_bounds = [2000.0, 10000.0] #Probe-spacecraft communication distance constraint (km)
        self.perturb_drag_probe_separation_to_AEI = 0 #Aerodynamic drag on probe from separation to AEI?
        self.perturb_drag_probe_AEI_to_end = 0 #Aerodynamic drag on probe from AEI to end of probe mission?
        self.probe_drag_area_probe_separation_to_AEI = 70 #probe area prior to AEI (for aerodynamic drag, in m^2)
        self.probe_drag_area_probe_AEI_to_end = 70 #probe area after AEI (for aerodynamic drag, in m^2)
        self.probe_coefficient_of_drag_probe_separation_to_AEI = 2.2 #probe coefficient of drag prior to AEI, i.e. Cd (unitless)
        self.probe_coefficient_of_drag_probe_AEI_to_end = 2.2 #probe coefficient of drag after AEI, i.e. Cd (unitless)
        self.probe_AEI_velocity = [0.0, 20.0, 0.0] #Bounds on the probe's final velocity at AEI (in km/s)
        self.probe_end_velocity = [0.0, 20.0, 0.0] #Bounds on the probe's final velocity at end of mission (in km/s)
        self.ProbeSeparationToAEI_MatchPointFraction = 0.5 #probe separation to AEI match point fraction
        self.ProbeSeparationToAEI_ForwardIntegrationStepLength = 86400 #probe separation to AEI forward integration step length (seconds)
        self.ProbeSeparationToAEI_BackwardIntegrationStepLength = 86400 #probe separation to AEI backward integration step length (seconds)
        self.ProbeAEI_to_end_MatchPointFraction = 0.5 #probe AEI to end match point fraction
        self.ProbeAEI_to_end_ForwardIntegrationStepLength = 86400 #probe AEI to end forward integration step length (seconds)
        self.ProbeAEI_to_end_BackwardIntegrationStepLength = 86400 #probe AEI to end backward integration step length (seconds)
        self.print_this_journey_options_no_matter_what = 0 #Always print this journey's options to the .emtgopt file?
        
        #empty lists for constraint definitions and trialX
        self.ManeuverConstraintDefinitions = []
        self.BoundaryConstraintDefinitions = []
        self.PhaseDistanceConstraintDefinitions = []
        self.trialX = []

        if inputFile != None:
            self.parse_journey(inputFile, lineNumber)
   
    #************************************************************************************parse
    def parse_journey(self, inputFile, lineNumber = 0):
        while True:
            line = inputFile.readline()
            if not line:
                break
            #strip off the newline character
            line = line.rstrip("\n\r ")
            
            lineNumber += 1
            if line == "END_JOURNEY":
                break
            
            #if we got this far, then this is a line worth reading
            #Note that unlike EMTG proper, PyEMTG does NOT length or bounds-check input files. But if you try to run an invalid .emtgopt, EMTG will notify you and help you fix it.
            
            if line.strip('\r') != "":
                if line[0] != "#":
                    #this is an active line, so it is space delimited
                    linecell = [entry.rstrip(" \r\n") for entry in line.split(" ")]
                    
                    if linecell[0] == "journey_name":
                        self.journey_name = linecell[1]
                  
                    elif linecell[0] == "journey_central_body":
                        self.journey_central_body = linecell[1]
                  
                    elif linecell[0] == "destination_list":
                        self.destination_list = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "sequence":
                        self.sequence = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "phase_type":
                        self.phase_type = int(linecell[1])
                  
                    elif linecell[0] == "impulses_per_phase":
                        self.impulses_per_phase = int(linecell[1])
                  
                    elif linecell[0] == "thrust_control_law":
                        self.thrust_control_law = int(linecell[1])
                  
                    elif linecell[0] == "force_unit_magnitude_control":
                        self.force_unit_magnitude_control = int(linecell[1])
                  
                    elif linecell[0] == "force_fixed_inertial_control":
                        self.force_fixed_inertial_control = int(linecell[1])
                  
                    elif linecell[0] == "override_num_steps":
                        self.override_num_steps = int(linecell[1])
                  
                    elif linecell[0] == "number_of_steps":
                        self.number_of_steps = int(linecell[1])
                  
                    elif linecell[0] == "override_duty_cycle":
                        self.override_duty_cycle = int(linecell[1])
                  
                    elif linecell[0] == "duty_cycle":
                        self.duty_cycle = float(linecell[1])
                  
                    elif linecell[0] == "override_PropagatorType":
                        self.override_PropagatorType = int(linecell[1])
                  
                    elif linecell[0] == "propagatorType":
                        self.propagatorType = int(linecell[1])
                  
                    elif linecell[0] == "override_integration_step_size":
                        self.override_integration_step_size = int(linecell[1])
                  
                    elif linecell[0] == "integration_step_size":
                        self.integration_step_size = float(linecell[1])
                  
                    elif linecell[0] == "override_flyby_altitude_bounds":
                        self.override_flyby_altitude_bounds = int(linecell[1])
                  
                    elif linecell[0] == "flyby_altitude_bounds":
                        self.flyby_altitude_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "PeriapseArrival_override_altitude":
                        self.PeriapseArrival_override_altitude = int(linecell[1])
                  
                    elif linecell[0] == "PeriapseArrival_altitude_bounds":
                        self.PeriapseArrival_altitude_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "PeriapseDeparture_altitude_bounds":
                        self.PeriapseDeparture_altitude_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "num_interior_control_points":
                        self.num_interior_control_points = int(linecell[1])
                  
                    elif linecell[0] == "CoastPhaseMatchPointFraction":
                        self.CoastPhaseMatchPointFraction = float(linecell[1])
                  
                    elif linecell[0] == "CoastPhaseForwardIntegrationStepLength":
                        self.CoastPhaseForwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "CoastPhaseBackwardIntegrationStepLength":
                        self.CoastPhaseBackwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "journey_end_TCM":
                        self.journey_end_TCM = float(linecell[1])
                  
                    elif linecell[0] == "enable_periapse_burns":
                        self.enable_periapse_burns = int(linecell[1])
                  
                    elif linecell[0] == "bounded_departure_date":
                        self.bounded_departure_date = int(linecell[1])
                  
                    elif linecell[0] == "timebounded":
                        self.timebounded = int(linecell[1])
                  
                    elif linecell[0] == "departure_date_bounds":
                        self.departure_date_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "wait_time_bounds":
                        self.wait_time_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "flight_time_bounds":
                        self.flight_time_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "arrival_date_bounds":
                        self.arrival_date_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "departure_type":
                        self.departure_type = int(linecell[1])
                  
                    elif linecell[0] == "initial_impulse_bounds":
                        self.initial_impulse_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "force_free_point_direct_insertion_along_velocity_vector":
                        self.force_free_point_direct_insertion_along_velocity_vector = int(linecell[1])
                  
                    elif linecell[0] == "departure_elements_vary_flag":
                        self.departure_elements_vary_flag = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "departure_elements":
                        self.departure_elements = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "departure_elements_bounds":
                        self.departure_elements_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "departure_elements_reference_epoch":
                        self.departure_elements_reference_epoch = float(linecell[1])
                  
                    elif linecell[0] == "departure_elements_state_representation":
                        self.departure_elements_state_representation = int(linecell[1])
                  
                    elif linecell[0] == "departure_elements_frame":
                        self.departure_elements_frame = int(linecell[1])
                  
                    elif linecell[0] == "AllowJourneyFreePointDepartureToPropagate":
                        self.AllowJourneyFreePointDepartureToPropagate = int(linecell[1])
                  
                    elif linecell[0] == "maximum_starting_mass_increment":
                        self.maximum_starting_mass_increment = float(linecell[1])
                  
                    elif linecell[0] == "minimum_starting_mass_increment":
                        self.minimum_starting_mass_increment = float(linecell[1])
                  
                    elif linecell[0] == "fixed_starting_mass_increment":
                        self.fixed_starting_mass_increment = float(linecell[1])
                  
                    elif linecell[0] == "fixed_ending_mass_increment":
                        self.fixed_ending_mass_increment = float(linecell[1])
                  
                    elif linecell[0] == "variable_mass_increment":
                        self.variable_mass_increment = int(linecell[1])
                  
                    elif linecell[0] == "constrain_initial_mass":
                        self.constrain_initial_mass = int(linecell[1])
                  
                    elif linecell[0] == "maximum_initial_mass":
                        self.maximum_initial_mass = float(linecell[1])
                  
                    elif linecell[0] == "departure_class":
                        self.departure_class = int(linecell[1])
                  
                    elif linecell[0] == "departure_ellipsoid_axes":
                        self.departure_ellipsoid_axes = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "arrival_type":
                        self.arrival_type = int(linecell[1])
                  
                    elif linecell[0] == "arrival_elements_vary_flag":
                        self.arrival_elements_vary_flag = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "arrival_elements":
                        self.arrival_elements = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "arrival_elements_bounds":
                        self.arrival_elements_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "arrival_elements_reference_epoch":
                        self.arrival_elements_reference_epoch = float(linecell[1])
                  
                    elif linecell[0] == "arrival_elements_state_representation":
                        self.arrival_elements_state_representation = int(linecell[1])
                  
                    elif linecell[0] == "arrival_elements_frame":
                        self.arrival_elements_frame = int(linecell[1])
                  
                    elif linecell[0] == "AllowJourneyFreePointArrivalToPropagate":
                        self.AllowJourneyFreePointArrivalToPropagate = int(linecell[1])
                  
                    elif linecell[0] == "final_velocity":
                        self.final_velocity = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "forced_terminal_coast":
                        self.forced_terminal_coast = float(linecell[1])
                  
                    elif linecell[0] == "forced_initial_coast":
                        self.forced_initial_coast = float(linecell[1])
                  
                    elif linecell[0] == "arrival_class":
                        self.arrival_class = int(linecell[1])
                  
                    elif linecell[0] == "arrival_ellipsoid_axes":
                        self.arrival_ellipsoid_axes = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "zero_turn_flyby_distance":
                        self.zero_turn_flyby_distance = float(linecell[1])
                  
                    elif linecell[0] == "terminal_intercept_flyby_distance":
                        self.terminal_intercept_flyby_distance = float(linecell[1])
                  
                    elif linecell[0] == "escape_spiral_starting_radius":
                        self.escape_spiral_starting_radius = float(linecell[1])
                  
                    elif linecell[0] == "escape_spiral_final_radius":
                        self.escape_spiral_final_radius = float(linecell[1])
                  
                    elif linecell[0] == "capture_spiral_final_radius":
                        self.capture_spiral_final_radius = float(linecell[1])
                  
                    elif linecell[0] == "capture_spiral_starting_radius":
                        self.capture_spiral_starting_radius = float(linecell[1])
                  
                    elif linecell[0] == "FreePointArrival_print_target_spec":
                        self.FreePointArrival_print_target_spec = int(linecell[1])
                  
                    elif linecell[0] == "journey_end_deltav":
                        self.journey_end_deltav = float(linecell[1])
                  
                    elif linecell[0] == "journey_end_propulsion_system":
                        self.journey_end_propulsion_system = int(linecell[1])
                  
                    elif linecell[0] == "perturbation_bodies":
                        self.perturbation_bodies = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "stage_after_departure":
                        self.stage_after_departure = int(linecell[1])
                  
                    elif linecell[0] == "stage_before_arrival":
                        self.stage_before_arrival = int(linecell[1])
                  
                    elif linecell[0] == "stage_after_arrival":
                        self.stage_after_arrival = int(linecell[1])
                  
                    elif linecell[0] == "freeze_decision_variables":
                        self.freeze_decision_variables = int(linecell[1])
                  
                    elif linecell[0] == "ephemeris_pegged_orbit_insertion_SMA":
                        self.ephemeris_pegged_orbit_insertion_SMA = float(linecell[1])
                  
                    elif linecell[0] == "ephemeris_pegged_orbit_insertion_ECC":
                        self.ephemeris_pegged_orbit_insertion_ECC = float(linecell[1])
                  
                    elif linecell[0] == "impact_momentum_enhancement_factor":
                        self.impact_momentum_enhancement_factor = float(linecell[1])
                  
                    elif linecell[0] == "perturb_drag":
                        self.perturb_drag = int(linecell[1])
                  
                    elif linecell[0] == "spacecraft_drag_area":
                        self.spacecraft_drag_area = float(linecell[1])
                  
                    elif linecell[0] == "coefficient_of_drag":
                        self.coefficient_of_drag = float(linecell[1])
                  
                    elif linecell[0] == "AtmosphericDensityModelKey":
                        self.AtmosphericDensityModelKey = linecell[1]
                  
                    elif linecell[0] == "AtmosphericDensityModelDataFile":
                        self.AtmosphericDensityModelDataFile = linecell[1]
                  
                    elif linecell[0] == "probe_separation_impulse":
                        self.probe_separation_impulse = float(linecell[1])
                  
                    elif linecell[0] == "probe_mass":
                        self.probe_mass = float(linecell[1])
                  
                    elif linecell[0] == "Probe_AEI_elements_vary_flag":
                        self.Probe_AEI_elements_vary_flag = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_AEI_elements":
                        self.Probe_AEI_elements = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_AEI_elements_bounds":
                        self.Probe_AEI_elements_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_AEI_elements_reference_epoch":
                        self.Probe_AEI_elements_reference_epoch = float(linecell[1])
                  
                    elif linecell[0] == "Probe_AEI_elements_state_representation":
                        self.Probe_AEI_elements_state_representation = int(linecell[1])
                  
                    elif linecell[0] == "Probe_AEI_elements_frame":
                        self.Probe_AEI_elements_frame = int(linecell[1])
                  
                    elif linecell[0] == "Probe_End_elements_vary_flag":
                        self.Probe_End_elements_vary_flag = [int(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_End_elements":
                        self.Probe_End_elements = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_End_elements_bounds":
                        self.Probe_End_elements_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "Probe_End_elements_reference_epoch":
                        self.Probe_End_elements_reference_epoch = float(linecell[1])
                  
                    elif linecell[0] == "Probe_End_elements_state_representation":
                        self.Probe_End_elements_state_representation = int(linecell[1])
                  
                    elif linecell[0] == "Probe_End_elements_frame":
                        self.Probe_End_elements_frame = int(linecell[1])
                  
                    elif linecell[0] == "ModelProbeSecondPhase":
                        self.ModelProbeSecondPhase = int(linecell[1])
                  
                    elif linecell[0] == "AllowJourneyProbeAEIToPropagate":
                        self.AllowJourneyProbeAEIToPropagate = int(linecell[1])
                  
                    elif linecell[0] == "AllowJourneyProbeEndToPropagate":
                        self.AllowJourneyProbeEndToPropagate = int(linecell[1])
                  
                    elif linecell[0] == "probe_communication_distance_bounds":
                        self.probe_communication_distance_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "perturb_drag_probe_separation_to_AEI":
                        self.perturb_drag_probe_separation_to_AEI = int(linecell[1])
                  
                    elif linecell[0] == "perturb_drag_probe_AEI_to_end":
                        self.perturb_drag_probe_AEI_to_end = int(linecell[1])
                  
                    elif linecell[0] == "probe_drag_area_probe_separation_to_AEI":
                        self.probe_drag_area_probe_separation_to_AEI = float(linecell[1])
                  
                    elif linecell[0] == "probe_drag_area_probe_AEI_to_end":
                        self.probe_drag_area_probe_AEI_to_end = float(linecell[1])
                  
                    elif linecell[0] == "probe_coefficient_of_drag_probe_separation_to_AEI":
                        self.probe_coefficient_of_drag_probe_separation_to_AEI = float(linecell[1])
                  
                    elif linecell[0] == "probe_coefficient_of_drag_probe_AEI_to_end":
                        self.probe_coefficient_of_drag_probe_AEI_to_end = float(linecell[1])
                  
                    elif linecell[0] == "probe_AEI_velocity":
                        self.probe_AEI_velocity = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "probe_end_velocity":
                        self.probe_end_velocity = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "ProbeSeparationToAEI_MatchPointFraction":
                        self.ProbeSeparationToAEI_MatchPointFraction = float(linecell[1])
                  
                    elif linecell[0] == "ProbeSeparationToAEI_ForwardIntegrationStepLength":
                        self.ProbeSeparationToAEI_ForwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "ProbeSeparationToAEI_BackwardIntegrationStepLength":
                        self.ProbeSeparationToAEI_BackwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "ProbeAEI_to_end_MatchPointFraction":
                        self.ProbeAEI_to_end_MatchPointFraction = float(linecell[1])
                  
                    elif linecell[0] == "ProbeAEI_to_end_ForwardIntegrationStepLength":
                        self.ProbeAEI_to_end_ForwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "ProbeAEI_to_end_BackwardIntegrationStepLength":
                        self.ProbeAEI_to_end_BackwardIntegrationStepLength = float(linecell[1])
                  
                    elif linecell[0] == "print_this_journey_options_no_matter_what":
                        self.print_this_journey_options_no_matter_what = int(linecell[1])
                  
                    elif linecell[0] == "BEGIN_MANEUVER_CONSTRAINT_BLOCK":
                        self.ManeuverConstraintDefinitions = []
                        while True:
                            entry = inputFile.readline()
                            lineNumber += 1
                            if "END_MANEUVER_CONSTRAINT_BLOCK" in entry:
                                break
                            self.ManeuverConstraintDefinitions.append(entry)
                    
                    elif linecell[0] == "BEGIN_BOUNDARY_CONSTRAINT_BLOCK":
                        self.BoundaryConstraintDefinitions = []
                        while True:
                            entry = inputFile.readline()
                            lineNumber += 1
                            if "END_BOUNDARY_CONSTRAINT_BLOCK" in entry:
                                break
                            self.BoundaryConstraintDefinitions.append(entry)
                    
                    elif linecell[0] == "BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK":
                        self.PhaseDistanceConstraintDefinitions = []
                        while True:
                            entry = inputFile.readline()
                            lineNumber += 1
                            if "END_PHASE_DISTANCE_CONSTRAINT_BLOCK" in entry:
                                break
                            self.PhaseDistanceConstraintDefinitions.append(entry)
                    
                    elif linecell[0] == "BEGIN_TRIALX":
                        self.trialX = []
                        while True:
                            entry = inputFile.readline()
                            lineNumber += 1
                            if "END_TRIALX" in entry:
                                break
                            commalinecell = entry.split(',')
                            self.trialX.append(commalinecell)
                    
    #************************************************************************************write
    def write(self, optionsFileName, writeAll = False):
        with open(optionsFileName, "a+") as optionsFile:
            optionsFile.write("\n")
            optionsFile.write("\n")
            optionsFile.write("BEGIN_JOURNEY\n")
            optionsFile.write("\n")
            
            if (self.journey_name != "default" or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey name\n")
                optionsFile.write("journey_name " + str(self.journey_name) + "\n")
    
            if (self.journey_central_body != "Sun" or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey central body name\n")
                optionsFile.write("journey_central_body " + str(self.journey_central_body) + "\n")
    
            if (self.destination_list != [3, 4] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#destination list, as indices from the Universe file\n")
                optionsFile.write("destination_list")
                for entry in self.destination_list:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.sequence != [] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#flyby sequence, as indices from the Universe file\n")
                optionsFile.write("sequence")
                for entry in self.sequence:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.phase_type != 2 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#phase type\n#0: MGALTS\n#1: FBLTS\n#2: MGALT\n#3: FBLT\n#4: PSBI\n#5: PSFB\n#6: MGAnDSMs\n#7: CoastPhase\n#8: SundmanCoastPhase\n#9: variable (do not use)\n#10 ProbeEntryPhase\n#11 ControlLawThrustPhase\n")
                optionsFile.write("phase_type " + str(self.phase_type) + "\n")
    
            if (self.impulses_per_phase != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#impulses per phase\n")
                optionsFile.write("impulses_per_phase " + str(self.impulses_per_phase) + "\n")
    
            if (self.thrust_control_law != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Thrust control law\n#0: Cartesian\n#1: Velocity direction\n1#2: anti-velocity direction\n")
                optionsFile.write("thrust_control_law " + str(self.thrust_control_law) + "\n")
    
            if (self.force_unit_magnitude_control != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Force unit magnitude control?\n#0: free control magnitude\n#1: force unit magnitude\n#2: force zero magnitude\n")
                optionsFile.write("force_unit_magnitude_control " + str(self.force_unit_magnitude_control) + "\n")
    
            if (self.force_fixed_inertial_control != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Force fixed inertial control? All control vectors in a phase must be identical if this is selected.\n")
                optionsFile.write("force_fixed_inertial_control " + str(int(self.force_fixed_inertial_control)) + "\n")
    
            if (self.override_num_steps != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Override this journey's number of steps?\n")
                optionsFile.write("override_num_steps " + str(int(self.override_num_steps)) + "\n")
    
            if (self.number_of_steps != 20 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Number of time steps for this journey, if overriden\n")
                optionsFile.write("number_of_steps " + str(self.number_of_steps) + "\n")
    
            if (self.override_duty_cycle != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey override global duty cycle\n")
                optionsFile.write("override_duty_cycle " + str(int(self.override_duty_cycle)) + "\n")
    
            if (self.duty_cycle != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey duty cycle\n")
                optionsFile.write("duty_cycle " + str(self.duty_cycle) + "\n")
    
            if (self.override_PropagatorType != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#override propagator type?\n")
                optionsFile.write("override_PropagatorType " + str(int(self.override_PropagatorType)) + "\n")
    
            if (self.propagatorType != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#propagator type\n")
                optionsFile.write("propagatorType " + str(self.propagatorType) + "\n")
    
            if (self.override_integration_step_size != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Override global integration step size?\n")
                optionsFile.write("override_integration_step_size " + str(int(self.override_integration_step_size)) + "\n")
    
            if (self.integration_step_size != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#integration step size (s)\n")
                optionsFile.write("integration_step_size " + str(self.integration_step_size) + "\n")
    
            if (self.override_flyby_altitude_bounds != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Override journey flyby altitude?\n")
                optionsFile.write("override_flyby_altitude_bounds " + str(int(self.override_flyby_altitude_bounds)) + "\n")
    
            if (self.flyby_altitude_bounds != [300.0, 1.0e+6] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Lower and upper bound on journey flyby altitude (only applies to the departure flyby, if there is one)\n")
                optionsFile.write("flyby_altitude_bounds")
                for entry in self.flyby_altitude_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.PeriapseArrival_override_altitude != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Override journey flyby altitude?\n")
                optionsFile.write("PeriapseArrival_override_altitude " + str(int(self.PeriapseArrival_override_altitude)) + "\n")
    
            if (self.PeriapseArrival_altitude_bounds != [300.0, 1.0e+6] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Lower and upper bound on journey flyby altitude (km)\n")
                optionsFile.write("PeriapseArrival_altitude_bounds")
                for entry in self.PeriapseArrival_altitude_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.PeriapseDeparture_altitude_bounds != [185.0, 185.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#PeriapseDeparture altitude bounds (in km)\n")
                optionsFile.write("PeriapseDeparture_altitude_bounds")
                for entry in self.PeriapseDeparture_altitude_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.num_interior_control_points != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#number of interior control points for parallel shooting phase types\n")
                optionsFile.write("num_interior_control_points " + str(self.num_interior_control_points) + "\n")
    
            if (self.CoastPhaseMatchPointFraction != 0.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#coast phase match point fraction\n")
                optionsFile.write("CoastPhaseMatchPointFraction " + str(self.CoastPhaseMatchPointFraction) + "\n")
    
            if (self.CoastPhaseForwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#coast phase forward integration step length (seconds)\n")
                optionsFile.write("CoastPhaseForwardIntegrationStepLength " + str(self.CoastPhaseForwardIntegrationStepLength) + "\n")
    
            if (self.CoastPhaseBackwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#coast phase backward integration step length (seconds)\n")
                optionsFile.write("CoastPhaseBackwardIntegrationStepLength " + str(self.CoastPhaseBackwardIntegrationStepLength) + "\n")
    
            if (self.journey_end_TCM != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey-end TCM magnitude (km/s)\n")
                optionsFile.write("journey_end_TCM " + str(self.journey_end_TCM) + "\n")
    
            if (self.enable_periapse_burns != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Enable periapse burns in ephemeris pegged flybys?\n")
                optionsFile.write("enable_periapse_burns " + str(int(self.enable_periapse_burns)) + "\n")
    
            if (self.bounded_departure_date != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Bound the departure epoch?\n")
                optionsFile.write("bounded_departure_date " + str(int(self.bounded_departure_date)) + "\n")
    
            if (self.timebounded != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#does the journey have time bounds?\n#0: unbounded\n#1: bounded flight time\n#2: bounded arrival date\n#3: bounded aggregate flight time\n")
                optionsFile.write("timebounded " + str(self.timebounded) + "\n")
    
            if (self.departure_date_bounds != [0.0, 0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey departure epoch bounds (MJD, two entries)\n")
                optionsFile.write("departure_date_bounds")
                for entry in self.departure_date_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.wait_time_bounds != [0.0, 1000.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey wait time bounds (days)\n")
                optionsFile.write("wait_time_bounds")
                for entry in self.wait_time_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.flight_time_bounds != [0.0, 0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey flight time bounds (days)\n")
                optionsFile.write("flight_time_bounds")
                for entry in self.flight_time_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.arrival_date_bounds != [51544.5, 60000.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey arrival date bounds (MJD, two entries)\n")
                optionsFile.write("arrival_date_bounds")
                for entry in self.arrival_date_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.departure_type != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey departure type\n#0: launch or direct insertion\n#1: depart from parking orbit (you can use this one in place of a launch vehicle model, and the departure burn will be done with the EDS motor)\n#2: free direct departure, i.e. do not burn to get the departure v_infinity (used for when operations about a small body are not modeled but the departure velocity is known)\n#3: flyby (only valid for successive journeys)\n#4: flyby with fixed v-infinity-out (only valid for successive journeys)\n#5: spiral-out from circular orbit (low-thrust missions only)\n#6: zero-turn flyby (for small bodies)\n")
                optionsFile.write("departure_type " + str(self.departure_type) + "\n")
    
            if (self.initial_impulse_bounds != [0.0, 6.97] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#what are the bounds on the initial impulse for each journey in km/s\\\n#you can set a very high upper bound if you are using a launchy vehicle model - the optimizer will find the correct value\n")
                optionsFile.write("initial_impulse_bounds")
                for entry in self.initial_impulse_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.force_free_point_direct_insertion_along_velocity_vector != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Force free point direct insertion burn to be along the inertial velocity vector?\n")
                optionsFile.write("force_free_point_direct_insertion_along_velocity_vector " + str(int(self.force_free_point_direct_insertion_along_velocity_vector)) + "\n")
    
            if (self.departure_elements_vary_flag != [0,0,0,0,0,0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#one entry for each element\n")
                optionsFile.write("departure_elements_vary_flag")
                for entry in self.departure_elements_vary_flag:
                    optionsFile.write(" " + str(int(entry)))
                optionsFile.write("\n")
    
            if (self.departure_elements != [0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#cartesian state or SMA, ECC, INC, RAAN, AOP, TA\n")
                optionsFile.write("departure_elements")
                for entry in self.departure_elements:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.departure_elements_bounds != [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#bounds on elements or state components, two entries for each element\n")
                optionsFile.write("departure_elements_bounds")
                for entry in self.departure_elements_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.departure_elements_reference_epoch != 51544.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Reference epoch (MJD) for journey departure elements\n")
                optionsFile.write("departure_elements_reference_epoch " + str(self.departure_elements_reference_epoch) + "\n")
    
            if (self.departure_elements_state_representation != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)\n")
                optionsFile.write("departure_elements_state_representation " + str(self.departure_elements_state_representation) + "\n")
    
            if (self.departure_elements_frame != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#reference frame for journey departure elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)\n")
                optionsFile.write("departure_elements_frame " + str(self.departure_elements_frame) + "\n")
    
            if (self.AllowJourneyFreePointDepartureToPropagate != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Allow journey departure free point boundary to propagate (otherwise it is a fixed waypoint)\n")
                optionsFile.write("AllowJourneyFreePointDepartureToPropagate " + str(int(self.AllowJourneyFreePointDepartureToPropagate)) + "\n")
    
            if (self.maximum_starting_mass_increment != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#upper bound on starting mass increment (negative number indicates mass drop) [kg]\n")
                optionsFile.write("maximum_starting_mass_increment " + str(self.maximum_starting_mass_increment) + "\n")
    
            if (self.minimum_starting_mass_increment != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#lower bound on starting mass increment (negative number indicates mass drop) [kg]\n")
                optionsFile.write("minimum_starting_mass_increment " + str(self.minimum_starting_mass_increment) + "\n")
    
            if (self.fixed_starting_mass_increment != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#starting mass increment (negative number indicates mass drop) [kg]\n")
                optionsFile.write("fixed_starting_mass_increment " + str(self.fixed_starting_mass_increment) + "\n")
    
            if (self.fixed_ending_mass_increment != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#ending mass increment (negative number indicates mass drop) [kg]\n")
                optionsFile.write("fixed_ending_mass_increment " + str(self.fixed_ending_mass_increment) + "\n")
    
            if (self.variable_mass_increment != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Vary initial mass increment?\n")
                optionsFile.write("variable_mass_increment " + str(int(self.variable_mass_increment)) + "\n")
    
            if (self.constrain_initial_mass != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Constrain initial mass?\n")
                optionsFile.write("constrain_initial_mass " + str(int(self.constrain_initial_mass)) + "\n")
    
            if (self.maximum_initial_mass != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#If initial mass for this journey is constrained, enter the constraint value here.\n")
                optionsFile.write("maximum_initial_mass " + str(self.maximum_initial_mass) + "\n")
    
            if (self.departure_class != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey departure boundary class\n#0: Ephemeris-pegged (default EMTG)\n#1: Free point\n#2: Ephemeris-referenced\n#3: Periapse\n")
                optionsFile.write("departure_class " + str(self.departure_class) + "\n")
    
            if (self.departure_ellipsoid_axes != [1e-8,1e-8,1e-8] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey departure ellipsoid axes (3)\n")
                optionsFile.write("departure_ellipsoid_axes")
                for entry in self.departure_ellipsoid_axes:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.arrival_type != 3 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey arrival type\n#0: insertion into parking orbit (use chemical Isp)\n#1: rendezvous (use chemical Isp)\n#2: intercept with bounded V_infinity\n#3: low-thrust rendezvous (does not work if terminal phase is not low-thrust)\n#4: match final v-infinity vector\n#5: match final v-infinity vector (low-thrust)\n#6: capture spiral\n#7: momentum transfer (kinetic impactor)\n")
                optionsFile.write("arrival_type " + str(self.arrival_type) + "\n")
    
            if (self.arrival_elements_vary_flag != [0,0,0,0,0,0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#one entry for each element\n")
                optionsFile.write("arrival_elements_vary_flag")
                for entry in self.arrival_elements_vary_flag:
                    optionsFile.write(" " + str(int(entry)))
                optionsFile.write("\n")
    
            if (self.arrival_elements != [0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#cartesian state or SMA, ECC, INC, RAAN, AOP, TA\n")
                optionsFile.write("arrival_elements")
                for entry in self.arrival_elements:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.arrival_elements_bounds != [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#bounds on elements or state components, two entries for each element\n")
                optionsFile.write("arrival_elements_bounds")
                for entry in self.arrival_elements_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.arrival_elements_reference_epoch != 51544.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Reference epoch (MJD) for journey arrival elements\n")
                optionsFile.write("arrival_elements_reference_epoch " + str(self.arrival_elements_reference_epoch) + "\n")
    
            if (self.arrival_elements_state_representation != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)\n")
                optionsFile.write("arrival_elements_state_representation " + str(self.arrival_elements_state_representation) + "\n")
    
            if (self.arrival_elements_frame != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)\n")
                optionsFile.write("arrival_elements_frame " + str(self.arrival_elements_frame) + "\n")
    
            if (self.AllowJourneyFreePointArrivalToPropagate != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Allow journey arrival free point boundary to propagate (otherwise it is a fixed waypoint)\n")
                optionsFile.write("AllowJourneyFreePointArrivalToPropagate " + str(int(self.AllowJourneyFreePointArrivalToPropagate)) + "\n")
    
            if (self.final_velocity != [0.0, 20.0, 0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Bounds on this journey's final velocity (in km/s)\n")
                optionsFile.write("final_velocity")
                for entry in self.final_velocity:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.forced_terminal_coast != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey forced terminal coast (in days)\n")
                optionsFile.write("forced_terminal_coast " + str(self.forced_terminal_coast) + "\n")
    
            if (self.forced_initial_coast != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey forced initial coast (in days)\n")
                optionsFile.write("forced_initial_coast " + str(self.forced_initial_coast) + "\n")
    
            if (self.arrival_class != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey arrival boundary class\n#0: Ephemeris-pegged (default EMTG)\n#1: Free point\n#2: Ephemeris-referenced\n#3: Periapse\n")
                optionsFile.write("arrival_class " + str(self.arrival_class) + "\n")
    
            if (self.arrival_ellipsoid_axes != [1e-8,1e-8,1e-8] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#journey arrival ellipsoid axes (3)\n")
                optionsFile.write("arrival_ellipsoid_axes")
                for entry in self.arrival_ellipsoid_axes:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.zero_turn_flyby_distance != 1000 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#encounter distance (from center of object) for a zero-turn flyby (km)\n")
                optionsFile.write("zero_turn_flyby_distance " + str(self.zero_turn_flyby_distance) + "\n")
    
            if (self.terminal_intercept_flyby_distance != 1000 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#encounter distance (from center of object) for an ephemeris-pegged intercept (km)\n")
                optionsFile.write("terminal_intercept_flyby_distance " + str(self.terminal_intercept_flyby_distance) + "\n")
    
            if (self.escape_spiral_starting_radius != 6678 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Starting orbital radius for an Edelbaum escape spiral (km)\n")
                optionsFile.write("escape_spiral_starting_radius " + str(self.escape_spiral_starting_radius) + "\n")
    
            if (self.escape_spiral_final_radius != 6678 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Final orbit radius for an Edelbaum capture spiral (km)\n")
                optionsFile.write("escape_spiral_final_radius " + str(self.escape_spiral_final_radius) + "\n")
    
            if (self.capture_spiral_final_radius != 6678 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Final orbit radius for an Edelbaum capture spiral (km)\n")
                optionsFile.write("capture_spiral_final_radius " + str(self.capture_spiral_final_radius) + "\n")
    
            if (self.capture_spiral_starting_radius != 6678 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Starting orbital radius for an Edelbaum capture spiral (km)\n")
                optionsFile.write("capture_spiral_starting_radius " + str(self.capture_spiral_starting_radius) + "\n")
    
            if (self.FreePointArrival_print_target_spec != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Print a target spec for free point arrival at the end of this journey?\n")
                optionsFile.write("FreePointArrival_print_target_spec " + str(int(self.FreePointArrival_print_target_spec)) + "\n")
    
            if (self.journey_end_deltav != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Journey-end delta-v (km/s)\n")
                optionsFile.write("journey_end_deltav " + str(self.journey_end_deltav) + "\n")
    
            if (self.journey_end_propulsion_system != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Propulsion system for journey-end maneuver\n#0: Monoprop chemical\n#1: Biprop chemical\n#2: Electric\n")
                optionsFile.write("journey_end_propulsion_system " + str(self.journey_end_propulsion_system) + "\n")
    
            if (self.perturbation_bodies != [] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Which bodies are used for third-body perturbation?\n#Expressed as indices in the Universe file\n")
                optionsFile.write("perturbation_bodies")
                for entry in self.perturbation_bodies:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.stage_after_departure != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Stage after departure?\n")
                optionsFile.write("stage_after_departure " + str(int(self.stage_after_departure)) + "\n")
    
            if (self.stage_before_arrival != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Stage before arrival?\n")
                optionsFile.write("stage_before_arrival " + str(int(self.stage_before_arrival)) + "\n")
    
            if (self.stage_after_arrival != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Stage after arrival?\n")
                optionsFile.write("stage_after_arrival " + str(int(self.stage_after_arrival)) + "\n")
    
            if (self.freeze_decision_variables != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Freeze this journey's decision variables?\n")
                optionsFile.write("freeze_decision_variables " + str(int(self.freeze_decision_variables)) + "\n")
    
            if (self.ephemeris_pegged_orbit_insertion_SMA != 6678 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#SMA (in km) for ephemeris pegged orbit insertion\n")
                optionsFile.write("ephemeris_pegged_orbit_insertion_SMA " + str(self.ephemeris_pegged_orbit_insertion_SMA) + "\n")
    
            if (self.ephemeris_pegged_orbit_insertion_ECC != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#ECC for ephemeris pegged orbit insertion\n")
                optionsFile.write("ephemeris_pegged_orbit_insertion_ECC " + str(self.ephemeris_pegged_orbit_insertion_ECC) + "\n")
    
            if (self.impact_momentum_enhancement_factor != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Impact momentum enhancement factor for planetary defense (also called beta)\n")
                optionsFile.write("impact_momentum_enhancement_factor " + str(self.impact_momentum_enhancement_factor) + "\n")
    
            if (self.perturb_drag != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Aerodynamic drag?\n")
                optionsFile.write("perturb_drag " + str(int(self.perturb_drag)) + "\n")
    
            if (self.spacecraft_drag_area != 70 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#spacecraft area (for aerodynamic drag, in m^2)\n")
                optionsFile.write("spacecraft_drag_area " + str(self.spacecraft_drag_area) + "\n")
    
            if (self.coefficient_of_drag != 2.2 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#coefficient of drag, i.e. Cd (unitless)\n")
                optionsFile.write("coefficient_of_drag " + str(self.coefficient_of_drag) + "\n")
    
            if (self.AtmosphericDensityModelKey != "Exponential" or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Atmospheric density model\n")
                optionsFile.write("AtmosphericDensityModelKey " + str(self.AtmosphericDensityModelKey) + "\n")
    
            if (self.AtmosphericDensityModelDataFile != "DoesNotExist.emtg_densityopt" or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#File defining atmospheric density model\n")
                optionsFile.write("AtmosphericDensityModelDataFile " + str(self.AtmosphericDensityModelDataFile) + "\n")
    
            if (self.probe_separation_impulse != 1 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Probe separation impulse (Ns)\n")
                optionsFile.write("probe_separation_impulse " + str(self.probe_separation_impulse) + "\n")
    
            if (self.probe_mass != 100.0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Probe mass (kg)\n")
                optionsFile.write("probe_mass " + str(self.probe_mass) + "\n")
    
            if (self.Probe_AEI_elements_vary_flag != [0,0,0,0,0,0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#one entry for each element\n")
                optionsFile.write("Probe_AEI_elements_vary_flag")
                for entry in self.Probe_AEI_elements_vary_flag:
                    optionsFile.write(" " + str(int(entry)))
                optionsFile.write("\n")
    
            if (self.Probe_AEI_elements != [0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#cartesian state or SMA, ECC, INC, RAAN, AOP, TA\n")
                optionsFile.write("Probe_AEI_elements")
                for entry in self.Probe_AEI_elements:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.Probe_AEI_elements_bounds != [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#bounds on elements or state components, two entries for each element\n")
                optionsFile.write("Probe_AEI_elements_bounds")
                for entry in self.Probe_AEI_elements_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.Probe_AEI_elements_reference_epoch != 51544.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Reference epoch (MJD) for journey probe arrival elements\n")
                optionsFile.write("Probe_AEI_elements_reference_epoch " + str(self.Probe_AEI_elements_reference_epoch) + "\n")
    
            if (self.Probe_AEI_elements_state_representation != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)\n")
                optionsFile.write("Probe_AEI_elements_state_representation " + str(self.Probe_AEI_elements_state_representation) + "\n")
    
            if (self.Probe_AEI_elements_frame != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)\n")
                optionsFile.write("Probe_AEI_elements_frame " + str(self.Probe_AEI_elements_frame) + "\n")
    
            if (self.Probe_End_elements_vary_flag != [0,0,0,0,0,0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#one entry for each element\n")
                optionsFile.write("Probe_End_elements_vary_flag")
                for entry in self.Probe_End_elements_vary_flag:
                    optionsFile.write(" " + str(int(entry)))
                optionsFile.write("\n")
    
            if (self.Probe_End_elements != [0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#cartesian state or SMA, ECC, INC, RAAN, AOP, TA\n")
                optionsFile.write("Probe_End_elements")
                for entry in self.Probe_End_elements:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.Probe_End_elements_bounds != [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#bounds on elements or state components, two entries for each element\n")
                optionsFile.write("Probe_End_elements_bounds")
                for entry in self.Probe_End_elements_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.Probe_End_elements_reference_epoch != 51544.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Reference epoch (MJD) for journey probe arrival elements\n")
                optionsFile.write("Probe_End_elements_reference_epoch " + str(self.Probe_End_elements_reference_epoch) + "\n")
    
            if (self.Probe_End_elements_state_representation != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)\n")
                optionsFile.write("Probe_End_elements_state_representation " + str(self.Probe_End_elements_state_representation) + "\n")
    
            if (self.Probe_End_elements_frame != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)\n")
                optionsFile.write("Probe_End_elements_frame " + str(self.Probe_End_elements_frame) + "\n")
    
            if (self.ModelProbeSecondPhase != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("# or just final approach?\n")
                optionsFile.write("ModelProbeSecondPhase " + str(int(self.ModelProbeSecondPhase)) + "\n")
    
            if (self.AllowJourneyProbeAEIToPropagate != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Allow probe AEI free point boundary to propagate (otherwise it is a fixed waypoint)\n")
                optionsFile.write("AllowJourneyProbeAEIToPropagate " + str(int(self.AllowJourneyProbeAEIToPropagate)) + "\n")
    
            if (self.AllowJourneyProbeEndToPropagate != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Allow probe end free point boundary to propagate (otherwise it is a fixed waypoint)\n")
                optionsFile.write("AllowJourneyProbeEndToPropagate " + str(int(self.AllowJourneyProbeEndToPropagate)) + "\n")
    
            if (self.probe_communication_distance_bounds != [2000.0, 10000.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Probe-spacecraft communication distance constraint (km)\n")
                optionsFile.write("probe_communication_distance_bounds")
                for entry in self.probe_communication_distance_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.perturb_drag_probe_separation_to_AEI != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Aerodynamic drag on probe from separation to AEI?\n")
                optionsFile.write("perturb_drag_probe_separation_to_AEI " + str(int(self.perturb_drag_probe_separation_to_AEI)) + "\n")
    
            if (self.perturb_drag_probe_AEI_to_end != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Aerodynamic drag on probe from AEI to end of probe mission?\n")
                optionsFile.write("perturb_drag_probe_AEI_to_end " + str(int(self.perturb_drag_probe_AEI_to_end)) + "\n")
    
            if (self.probe_drag_area_probe_separation_to_AEI != 70 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe area prior to AEI (for aerodynamic drag, in m^2)\n")
                optionsFile.write("probe_drag_area_probe_separation_to_AEI " + str(self.probe_drag_area_probe_separation_to_AEI) + "\n")
    
            if (self.probe_drag_area_probe_AEI_to_end != 70 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe area after AEI (for aerodynamic drag, in m^2)\n")
                optionsFile.write("probe_drag_area_probe_AEI_to_end " + str(self.probe_drag_area_probe_AEI_to_end) + "\n")
    
            if (self.probe_coefficient_of_drag_probe_separation_to_AEI != 2.2 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe coefficient of drag prior to AEI, i.e. Cd (unitless)\n")
                optionsFile.write("probe_coefficient_of_drag_probe_separation_to_AEI " + str(self.probe_coefficient_of_drag_probe_separation_to_AEI) + "\n")
    
            if (self.probe_coefficient_of_drag_probe_AEI_to_end != 2.2 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe coefficient of drag after AEI, i.e. Cd (unitless)\n")
                optionsFile.write("probe_coefficient_of_drag_probe_AEI_to_end " + str(self.probe_coefficient_of_drag_probe_AEI_to_end) + "\n")
    
            if (self.probe_AEI_velocity != [0.0, 20.0, 0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Bounds on the probe's final velocity at AEI (in km/s)\n")
                optionsFile.write("probe_AEI_velocity")
                for entry in self.probe_AEI_velocity:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.probe_end_velocity != [0.0, 20.0, 0.0] or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Bounds on the probe's final velocity at end of mission (in km/s)\n")
                optionsFile.write("probe_end_velocity")
                for entry in self.probe_end_velocity:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.ProbeSeparationToAEI_MatchPointFraction != 0.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe separation to AEI match point fraction\n")
                optionsFile.write("ProbeSeparationToAEI_MatchPointFraction " + str(self.ProbeSeparationToAEI_MatchPointFraction) + "\n")
    
            if (self.ProbeSeparationToAEI_ForwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe separation to AEI forward integration step length (seconds)\n")
                optionsFile.write("ProbeSeparationToAEI_ForwardIntegrationStepLength " + str(self.ProbeSeparationToAEI_ForwardIntegrationStepLength) + "\n")
    
            if (self.ProbeSeparationToAEI_BackwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe separation to AEI backward integration step length (seconds)\n")
                optionsFile.write("ProbeSeparationToAEI_BackwardIntegrationStepLength " + str(self.ProbeSeparationToAEI_BackwardIntegrationStepLength) + "\n")
    
            if (self.ProbeAEI_to_end_MatchPointFraction != 0.5 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe AEI to end match point fraction\n")
                optionsFile.write("ProbeAEI_to_end_MatchPointFraction " + str(self.ProbeAEI_to_end_MatchPointFraction) + "\n")
    
            if (self.ProbeAEI_to_end_ForwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe AEI to end forward integration step length (seconds)\n")
                optionsFile.write("ProbeAEI_to_end_ForwardIntegrationStepLength " + str(self.ProbeAEI_to_end_ForwardIntegrationStepLength) + "\n")
    
            if (self.ProbeAEI_to_end_BackwardIntegrationStepLength != 86400 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#probe AEI to end backward integration step length (seconds)\n")
                optionsFile.write("ProbeAEI_to_end_BackwardIntegrationStepLength " + str(self.ProbeAEI_to_end_BackwardIntegrationStepLength) + "\n")
    
            if (self.print_this_journey_options_no_matter_what != 0 or writeAll or self.print_this_journey_options_no_matter_what):
                optionsFile.write("#Always print this journey's options to the .emtgopt file?\n")
                optionsFile.write("print_this_journey_options_no_matter_what " + str(int(self.print_this_journey_options_no_matter_what)) + "\n")
    
            optionsFile.write("\n")
            optionsFile.write("#Maneuver constraint code\n")
            optionsFile.write("#Works for absolute and relative epochs and also magnitudes\n")
            optionsFile.write("BEGIN_MANEUVER_CONSTRAINT_BLOCK\n")
            for ManeuverConstraintDefinition in self.ManeuverConstraintDefinitions:
                optionsFile.write(ManeuverConstraintDefinition + "\n")
            optionsFile.write("END_MANEUVER_CONSTRAINT_BLOCK\n")
            optionsFile.write("\n")
            
            optionsFile.write("\n")
            optionsFile.write("#Boundary constraint code\n")
            optionsFile.write("BEGIN_BOUNDARY_CONSTRAINT_BLOCK\n")
            for BoundaryConstraintDefinition in self.BoundaryConstraintDefinitions:
                optionsFile.write(BoundaryConstraintDefinition + "\n")
            optionsFile.write("END_BOUNDARY_CONSTRAINT_BLOCK\n")
            optionsFile.write("\n")
            
            optionsFile.write("\n")
            optionsFile.write("#Phase distance constraint code\n")
            optionsFile.write("BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK\n")
            for PhaseDistanceConstraintDefinition in self.PhaseDistanceConstraintDefinitions:
                optionsFile.write(PhaseDistanceConstraintDefinition + "\n")
            optionsFile.write("END_PHASE_DISTANCE_CONSTRAINT_BLOCK\n")
            optionsFile.write("\n")
            
            if len(self.trialX) > 0:
                optionsFile.write("#trial decision vector\n")
                optionsFile.write("BEGIN_TRIALX\n")
                for entry in self.trialX:
                    optionsFile.write(entry[0] + "," + '%17.20f' % float(entry[1]) + "\n")
                optionsFile.write("END_TRIALX\n")
            optionsFile.write("\n")
            
            optionsFile.write("END_JOURNEY")
            
    #************************************************************************************convert decision vector
    def ConvertDecisionVector(self, ParallelShootingStateRepresentation, PeriapseBoundaryStateRepresentation):                                                                                            
        from StateConverter import StateConverter                                                                                                                                                                                 
        myStateConverter = StateConverter()                                                                                                                                                                                 
                                                                                                                                                                                                              
        stateRepresentationNames = ["Cartesian", "SphericalRADEC", "SphericalAZFPA", "COE", "MEE", "IncomingBplane", "OutgoingBplane"]                                                                                          
                                                                                                                                                                                                              
        mu = 1.0                                                                                                                                                                                              
        try:                                                                                                                                                                                                  
            import Universe                                                                                                                                                                                   
            myUniverse = Universe.Universe(self.universe_folder + "/" + self.journey_central_body + ".emtg_universe")                                                                                         
            mu = myUniverse.mu                                                                                                                                                                                
        except:                                                                                                                                                                                               
            print("Failed to find " + self.universe_folder + "/" + self.journey_central_body + ".emtg_universe" + "  Cannot find appropriate mu for decision vector conversion. Using 1.0. Good luck.")       
                                                                                                                                                                                                              
        #switch between MGALT/FBLT and PSBI/PSFB                                                                                                                                                              
        for entry in self.trialX:                                                                                                                                                                             
            if "MGALT" in entry[0] and (self.phase_type == 3):                                                                                                                                                
                entry[0] = entry[0].replace("MGALT","FBLT")                                                                                                                                                   
            elif "FBLT" in entry[0] and (self.phase_type == 2):                                                                                                                                               
                entry[0] = entry[0].replace("FBLT","MGALT")                                                                                                                                                   
            elif "PSBI" in entry[0] and (self.phase_type == 5):                                                                                                                                               
                entry[0] = entry[0].replace("PSBI","PSFB")                                                                                                                                                    
            elif "PSFB" in entry[0] and (self.phase_type == 4):                                                                                                                                               
                entry[0] = entry[0].replace("PSFB","PSBI")                                                                                                                                                    
                                                                                                                                                                                                              
            if "xdot" in entry[0]:                                                                                                                                                                            
                entry[0] = entry[0].replace("xdot", "vx")                                                                                                                                                     
            elif "ydot" in entry[0]:                                                                                                                                                                          
                entry[0] = entry[0].replace("ydot", "vy")                                                                                                                                                     
            elif "zdot" in entry[0]:                                                                                                                                                                          
                entry[0] = entry[0].replace("zdot", "vz")                                                                                                                                                     
                                                                                                                                                                                                              
        #old launch to new launch                                                                                                          
        if self.departure_class == 3 and self.departure_type == 0: #periapse launch                                                        
            import os, sys, inspect                                                                                                        
            currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))                                         
            sys.path.append(currentdir + "/Converters")                                                                               
            import convert_old_PeriapseLaunchOrImpulsiveDeparture_to_PeriapseLaunch as lc                                                  
                                                                                                                                           
            self = lc.convert_launch(self, mu)                                                                                             
                                                                                                                                           
        #ParallelShooting                                                                                                                  
        self.trialX = myStateConverter.convertDecisionVector(self.trialX,                                                                  
                                                            stateRepresentationNames[ParallelShootingStateRepresentation],                 
                                                            ["PSBI_Step", "PSFB_Step"],                                                    
                                                            mu)                                                                            
                                                                                                                                           
        #PeriapseBoundary                                                                                                                  
        self.trialX = myStateConverter.convertDecisionVector(self.trialX,                                                                  
                                                            stateRepresentationNames[PeriapseBoundaryStateRepresentation],                 
                                                            ["Periapse"],                                                                  
                                                            mu)                                                                            
                                                                                                                                           
        #FreePointBoundary departure                                                                                                       
        self.trialX = myStateConverter.convertDecisionVector(self.trialX,                                                                  
                                                            stateRepresentationNames[self.departure_elements_state_representation],        
                                                            ["FreePointDirectInsertion", "FreePointFreeDirectDeparture"],                  
                                                            mu)                                                                            
                                                                                                                                           
        #FreePointBoundary arrival                                                                                                         
        self.trialX = myStateConverter.convertDecisionVector(self.trialX,                                                                  
                                                            stateRepresentationNames[self.arrival_elements_state_representation],          
                                                            ["FreePointChemRendezvous", "FreePointIntercept", "FreePointLTRendezvous"],    
                                                            mu)                                                                            
                                                                                                                                           
        return                                                                                                                             
                                                                                                                                           
                                                                                                                                           
                                                                                                                                           
    #************************************************************************************getDecisionVariable()                             
    def getDecisionVariable(self, variableDefinition):                                                                                     
        for entry in self.trialX:                                                                                                          
            if entry[0].strip() == variableDefinition:                                                                                     
                return entry[1]                                                                                                            
                                                                                                                                           
        #if you made it here, something went wrong.                                                                                        
                                                                                                                                           
        raise Exception("Variable '" + variableDefinition + "' not found.")                                                              
                                                                                                                                           
                                                                                                                                           
    #************************************************************************************setDecisionVariable()                             
    def setDecisionVariable(self, variableDefinition, value):                                                                              
        for entryIndex in range(0, len(self.trialX)):                                                                                      
            if self.trialX[entryIndex][0].strip() == variableDefinition:                                                                   
                self.trialX[entryIndex][1] = value                                                                                         
                return                                                                                                                     
                                                                                                                                           
        #if you made it here, something went wrong.                                                                                        
                                                                                                                                           
        raise Exception("Variable '" + variableDefinition + "' not found.")                                                              
