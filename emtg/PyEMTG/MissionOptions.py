#PyEMTG MissionOptions class
#auto-generated by make_EMTG_missionoptions_journeyoptions.py

import JourneyOptions

class MissionOptions(object):

    #************************************************************************************constructor
    def __init__(self, optionsFileName = None):
        self.mission_name = "default" #mission name
        self.objective_type = 2 #objective type, see ObjectiveFunctionType in EMTG_enums.h
        self.objective_journey = 0 #Journey associated with objective function (if applicable)
        self.include_initial_impulse_in_cost = 0 #Include the initial impulse in calculating the delta-v objective function?
        self.global_timebounded = 1 #0: unbounded, 1: bounded total time (note that the global arrival date bound is by definition the same as the last journey's arrival date bound and is not duplicated
        self.launch_window_open_date = 53782 #launch window open date (MJD)
        self.total_flight_time_bounds = [0.0, 302] #flight time bounds (days)
        self.DLA_bounds = [-90.0, 90.0] #DLA in degrees
        self.RLA_bounds = [-2880.0, 2880.0] #RLA in degrees
        self.mission_type = 2 #mission type, #0: MGALTS, #1: FBLTS, #2: MGALT, #3: FBLT, #4: PSBI, #5: PSFB, #6: MGAnDSMs, #7: CoastPhase, #8: SundmanCoastPhase, #9: variable phase type, #10: ProbeEntryPhase, #11 ControlLawThrustPhase
        self.NLP_solver_type = 0 #NLP solver type,#0: SNOPT,#1: WORHP
        self.NLP_solver_mode = 1 #NLP solver mode,#0: find feasible point only,#1: find optimal solution,#2: satisfy equality constraints
        self.quiet_NLP = 1 #Quiet NLP solver?
        self.ACE_feasible_point_finder = 0 #Enable ACE feasible point finder?
        self.MBH_always_write_archive = 0 #Write every hop to the MBH archive, even if it is not an improvement?
        self.MBH_archive_state_vector = 0 #include state vector in MBH archive file?
        self.MBH_max_not_improve = 10000 #quantity Max_not_improve for MBH
        self.MBH_max_trials = 1000000 #maximum number of trials for MBH
        self.MBH_max_run_time = 60 #maximum run time for MBH, in seconds
        self.MBH_max_step_size = 1 #Maximum step size (uniform) or scale factor (other distributions)
        self.MBH_hop_distribution = 2 #MBH hop probabilty distribution,#0: uniform,#1: Cauchy,#2: Pareto,#3: Gaussian
        self.MBH_Pareto_alpha = 1.4 #Pareto distribution alpha
        self.MBH_write_every_improvement = 0 #Write every MBH improvement for later animation?
        self.MBH_time_hop_probability = 0.05 #probability of MBH time hop operation
        self.snopt_feasibility_tolerance = 1.00E-05 #feasibility tolerance
        self.snopt_optimality_tolerance = 1.00E-05 #optimality tolerance
        self.NLP_max_step = 1 #NLP max step
        self.snopt_major_iterations = 8000 #NLP major iterations
        self.snopt_minor_iterations = 500 #NLP minor iterations
        self.snopt_max_run_time = 15 #NLP max run time (seconds)
        self.enable_Scalatron = 1 #Enable Scalatron?
        self.enable_NLP_chaperone = 1 #Enable NLP chaperone?
        self.seed_MBH = 0 #Seed MBH?
        self.skip_first_nlp_run = 0 #Skip first NLP run in an MBH process?
        self.NLP_stop_on_goal_attain = 0 #Stop NLP on goal attain?
        self.NLP_objective_goal = 0 #Objective value at which NLP stops
        self.MBH_RNG_seed = -1 #MBH RNG seed (negative number means system clock)
        self.print_NLP_movie_frames = 0 #Print NLP movie frames?
        self.quiet_basinhopping = 0 #Quiet MBH?
        self.SPICE_leap_seconds_kernel = "naif0012.tls" #SPICE leap seconds kernel - required for SPICE to work
        self.SPICE_reference_frame_kernel = "pck00010.tpc" #SPICE_reference_frame_kernel
        self.universe_folder = "C:/Utilities/Universe" #Universe folder
        self.ephemeris_source = 2 #0: static, 1: SPICE (default to static if no SPICE file supplied for a body), 2: SplineEphem
        self.SplineEphem_points_per_period = 360 #How many sample points should SplineEphem use per orbital period of each body?
        self.SplineEphem_non_central_body_sun_points_per_period = 10000 #How many sample points should SplineEphem use per orbital period of the sun with respect to the central body?
        self.SplineEphem_truncate_ephemeris_at_maximum_mission_epoch = 0 #Truncate SplineEphem at maximum mission epoch?
        self.earliestPossibleEpoch = 51554.5 #Beginning of the SplineEphem data set
        self.latestPossibleEpoch = 88058 #End of the SplineEphem data set
        self.propagatorType = 0 #Propagator type,#0: Keplerian propagator,#1: Integrated propagator
        self.integratorType = 1 #Integrator type,#0: rk7813M adaptive step,#1: rk8 fixed step
        self.integrator_tolerance = 1.00E-08 #adaptive step integrator tolerance
        self.integration_time_step_size = 86400 #integration step size (maximum for adaptive, fixed for fixed)
        self.num_timesteps = 20 #number of timesteps per phase
        self.spiral_segments = 1 #number of spiral segments
        self.allow_initial_mass_to_vary = 0 #Allow the mass at the beginning of the first journey to vary up to the allowed maximum?
        self.maximum_mass = 525.2 #maximum possible mass of the spacecraft (kg)
        self.IspLT = 3000 #specific impulse of the engine used for low-thrust maneuvers
        self.IspLT_minimum = 1 #minimum specific impulse for variable specific impulse problems
        self.IspChem = 320 #specific impulse of the engine used for impulsive maneuvers
        self.Thrust = 0.1 #thrust of the spacecraft, in Newtons
        self.LV_margin = 0 #LV margin (as a fraction)
        self.LV_adapter_mass = 0 #LV adapter mass (kg)
        self.engine_type = 5 #low-thrust engine type, from original EMTGv8 list
        self.number_of_electric_propulsion_systems = 1 #number of thruster systems (used to be called number of engines)
        self.engine_duty_cycle = 1 #percentage of time that engine can operate
        self.duty_cycle_type = 0 #duty cycle type,#0: averaged,#1: realistic
        self.thrust_scale_factor = 1 #scale factor to apply to thrust ONLY, not mass flow rate, can use to approximate cosine loss
        self.power_at_1_AU = 5 #Power at 1 AU (kW)
        self.power_source_type = 1 #power source type, 0: fixed, 1: solar
        self.solar_power_model_type = 0 #Solar power model type,#0: classic Sauer model,#1: polynomial (0th order on the left)
        self.solar_power_gamma = [1.32077,-0.10848,-0.11665,0.10843,-0.01279,0.0,0.0] #solar power coefficients gamma_1 through gamma_5, if all gamma = [1 0 0 0 0], then solar power is a simple 1/r^2
        self.power_margin = 0 #power margin (fraction)
        self.power_decay_rate = 0 #power system decay rate (fraction per year)
        self.power_system_decay_reference_epoch = 51544.5 #reference date when the power system begins to decay
        self.throttle_sharpness = 100 #Throttle sharpness (higher means more precise, lower means smoother)
        self.throttle_logic_mode = 1 #Throttle logic mode #0: maximum number of thrusters,#1: minimum number of thrusters
        self.spacecraft_power_coefficients = [0,0,0] #spacecraft power coefficients A, B, and C represent the power requirements of the spacecraft at a distance r from the sun, #i.e. heaters, communications, etc
        self.engine_input_thrust_coefficients = [26.337459,-51.694393,90.486509,-36.720293,5.145602,0.0,0.0] #thrust polynomial coefficients
        self.engine_input_mass_flow_rate_coefficients = [2.5060,-5.3568,6.2539,-2.5372,0.36985,0.0,0.0] #mass flow rate polynomial coefficients
        self.engine_input_power_bounds = [0.525, 2.6] #thruster input power bounds (kW)
        self.user_defined_engine_efficiency = 0.7 #Propulsion system efficiency (fraction)
        self.spacecraft_power_model_type = 0 #spacecraft power model type
        self.TCM_Isp = 200 #Isp for TCMs
        self.TCM_post_launch = 0 #TCM magnitude post-launch (km/s)
        self.TCM_pre_flyby = 0 #TCM magnitude before flybys (km/s)
        self.TCM_maneuver_fraction = 0 #Post-DSM TCM magnitude as a fraction of DSM magnitude
        self.trackACS = 0 #Track ACS propellant consumption?
        self.ACS_kg_per_day = 0 #ACS propellant consumption (kg/day)
        self.final_mass_constraint_bounds = [0.0, 0.0] #Bounds on final mass constraints
        self.constrain_final_mass = 0 #Constrain final wet mass?
        self.constrain_dry_mass = 0 #Constrain dry mass?
        self.enable_electric_propellant_tank_constraint = 0 #Constrain electric propellant tank?
        self.maximum_electric_propellant = 1000 #Electric propellant tank capacity (kg)
        self.electric_propellant_margin = 0 #Electric propellant margin (fraction)
        self.enable_chemical_propellant_tank_constraint = 0 #Constrain chemical propellant?
        self.maximum_chemical_fuel = 1000 #Chemical fuel tank capacity (kg)
        self.maximum_chemical_oxidizer = 1000 #Chemical oxidizer tank capacity (kg)
        self.bipropellant_mixture_ratio = 0.925 #Bipropellant mixture ratio
        self.chemical_propellant_margin = 0 #Chemical propellant margin (fraction)
        self.SpacecraftModelInput = 2 #Spacecraft object input type,#0: Assemble from libraries,#1: Read .emtg_spacecraftoptions file,#2: Assemble from missionoptions object
        self.HardwarePath = "c:/Utilities/HardwareModels/" #HardwarePath
        self.ThrottleTableFile = "empty.ThrottleTable" #ThrottleTableFile
        self.LaunchVehicleLibraryFile = "default.emtg_launchvehicleopt" #LaunchVehicleLibraryFile
        self.PowerSystemsLibraryFile = "default.emtg_powersystemsopt" #PowerSystemsLibraryFile
        self.PropulsionSystemsLibraryFile = "default.emtg_propulsionsystemopt" #PropulsionSystemsLibraryFile
        self.SpacecraftOptionsFile = "default.emtg_spacecraftopt" #SpacecraftOptionsFile
        self.LaunchVehicleKey = "ExampleRocket" #LaunchVehicleKey
        self.PowerSystemKey = "5kW_basic" #PowerSystemKey
        self.ElectricPropulsionSystemKey = "defaultThruster" #ElectricPropulsionSystemKey
        self.ChemicalPropulsionSystemKey = "DefaultChemicalPropulsionSystem" #ChemicalPropulsionSystemKey
        self.perturb_SRP = 0 #solar radiation pressure?
        self.perturb_thirdbody = 0 #third body perturbations?
        self.perturb_J2 = 0 #J2?
        self.spacecraft_area = 70 #spacecraft area (for SRP, in m^2)
        self.coefficient_of_reflectivity = 1 #Coefficient of reflectivity
        self.solar_percentage = 1 #Percentage of the Sun seen by the spacecraft
        self.solar_flux = 1359.39 #Solar constant (flux density at 1 AU) [W/m^2 = kg/s^3]
        self.speed_of_light_vac = 299792458 #Speed of light in a vacuum [m/s]
        self.forced_post_launch_coast = 0 #Forced post-launch coast, in days
        self.forced_pre_flyby_coast = 0 #Forced pre-flyby coast, in days
        self.forced_post_flyby_coast = 0 #Forced post-flyby coast, in days
        self.waypoint_file_path = "./banana.ephemeris" #Path to waypoint file
        self.covariance_file_path = "./shampoo_bottle.ephemeris" #Path to covariance file
        self.ParallelShootingStateRepresentation = 1 #state representation for parallel shooting (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE)
        self.PeriapseBoundaryStateRepresentation = 1 #state representation for periapse boundary conditions (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)
        self.ParallelShootingConstraintStateRepresentation = 0 #state representation for parallel shooting constraints (Cartesian or same as encoded states)
        self.print_only_non_default_options = 1 #Write only options that are *not* default into the .emtgopt file?
        self.output_file_frame = 1 #reference frame for output file (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar)
        self.override_default_output_file_name = 0 #Override default output file name?
        self.forced_output_file_name = "forced_output_file_name" #User-defined output file name
        self.output_dormant_journeys = 0 #Output ephemeris for time spent waiting between journeys?
        self.post_mission_wait_time = 0 #How long to output an ephemeris after the mission end (days)
        self.override_working_directory = 0 #Override the working directory?
        self.forced_working_directory = "..//EMTG_v9_Results" #User-defined working directory
        self.override_mission_subfolder = 0 #Create a mission subfolder?
        self.forced_mission_subfolder = "mission_subfolder" #Mission subfolder
        self.short_output_file_names = 1 #Shorten output file names?
        self.generate_forward_integrated_ephemeris = 0 #Generate forward-integrated ephemeris?
        self.forward_integrated_ephemeris_central_body_SPICE_ID = 10 #SPICE ID of central body for forward integrated ephemeris
        self.add_control_switch_line_to_ephemeris = 0 #Add control switch line to ephemeris?
        self.append_mass_to_ephemeris_output = 0 #Append mass to ephemeris output?
        self.append_control_to_ephemeris_output = 0 #Append control vector to ephemeris output?
        self.append_thrust_to_ephemeris_output = 0 #Append thrust magnitude to ephemeris output?
        self.append_mdot_to_ephemeris_output = 0 #Append mass flow rate to ephemeris output?
        self.append_Isp_to_ephemeris_output = 0 #Append Isp to ephemeris output?
        self.append_active_power_to_ephemeris_output = 0 #Append active power to ephemeris output?
        self.append_number_of_active_engines_to_ephemeris_output = 0 #Append number of active propulsion systems to ephemeris output?
        self.append_throttle_level_to_ephemeris_output = 0 #Append throttle level to ephemeris output?
        self.call_system_to_generate_bsp = 0 #Should EMTG make a system call to clean the .ephemeris file and call python to call spice to generate the bsp?
        self.spice_utilities_path = "c:/utilities/cspice/exe" #Where are the spice utilities brief and mkspk located?
        self.spice_utility_extension = ".exe" #What is the file extension on the spice utlities? Likely either ".exe" for Windows or "" for *nix
        self.pyemtg_path = "c:/emtg/PyEMTG/" #Where is PyEMTG located?
        self.spacecraft_SPICE_ID = -52284 #SPICE ID of spacecraft for bsp
        self.background_mode = 0 #Close program after completion?
        self.output_STMs = 0 #Output STMs?
        self.output_maneuver_and_target_spec_files = 0 #Output maneuver and target spec files?
        self.generate_acceleration_model_instrumentation_file = 0 #generates a complete output of all acceleration model data at each integration time step (only works for numerically integrated trajectories
        self.stop_after_journey = 32767 #Stop after a particular journey? (if this value is greater than the number of journeys, do the whole mission)
        self.run_inner_loop = 1 #Which inner loop solver to run?
        self.check_derivatives = 0 #Check derivatives using NLP finite differencing?
        self.user_data = {} #Field for taking notes
        
        #empty master decision and constraint vectors - these exist only for interface with PyEMTG GUI and PEATSA
        self.trialX = []
        self.ManeuverConstraintDefinitions = []
        self.BoundaryConstraintDefinitions = []
        self.PhaseDistanceConstraintDefinitions = []
        
        if optionsFileName == None:
            self.Journeys = [JourneyOptions.JourneyOptions()]
            self.number_of_journeys = 1
        else:
            self.Journeys = []
            self.parse_mission(optionsFileName)
        self.filename = ""
        self.success = 1
        self.ActiveJourney = 0
        self.AU = 1.49597870691e+8
        self.G = 6.674280000000000367e-20
        self.g0 = 9.806649999999999423
        
   
    #************************************************************************************parse
    def parse_mission(self, optionsFileName):
        self.filename = optionsFileName
        
        inputFile = []
        lineNumber = 0
        from os.path import isfile
        if isfile(self.filename):
            inputFile = open(optionsFileName, "r")
            self.success = 1
        else:
            print("Unable to open", optionsFileName, "EMTG Error")
            return
        
        while True:
            line = inputFile.readline()
            if not line:
                break
            #strip off the newline character
            line = line.rstrip("\n\r ")
            
            lineNumber += 1
            
            #if we got this far, then this is a line worth reading
            #Note that unlike EMTG proper, PyEMTG does NOT length or bounds-check input files. But if you try to run an invalid .emtgopt, EMTG will notify you and help you fix it.
            
            if line.strip('\r') != "":
                if line[0] != "#":
                    #this is an active line, so it is space delimited
                    linecell = [entry.rstrip(" \r\n") for entry in line.split(" ")]
                    
                    if linecell[0] == "mission_name":
                        self.mission_name = linecell[1]
                  
                    elif linecell[0] == "objective_type":
                        self.objective_type = int(linecell[1])
                  
                    elif linecell[0] == "objective_journey":
                        self.objective_journey = int(linecell[1])
                  
                    elif linecell[0] == "include_initial_impulse_in_cost":
                        self.include_initial_impulse_in_cost = int(linecell[1])
                  
                    elif linecell[0] == "global_timebounded":
                        self.global_timebounded = int(linecell[1])
                  
                    elif linecell[0] == "launch_window_open_date":
                        self.launch_window_open_date = float(linecell[1])
                  
                    elif linecell[0] == "total_flight_time_bounds":
                        self.total_flight_time_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "DLA_bounds":
                        self.DLA_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "RLA_bounds":
                        self.RLA_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "mission_type":
                        self.mission_type = int(linecell[1])
                  
                    elif linecell[0] == "NLP_solver_type":
                        self.NLP_solver_type = int(linecell[1])
                  
                    elif linecell[0] == "NLP_solver_mode":
                        self.NLP_solver_mode = int(linecell[1])
                  
                    elif linecell[0] == "quiet_NLP":
                        self.quiet_NLP = int(linecell[1])
                  
                    elif linecell[0] == "ACE_feasible_point_finder":
                        self.ACE_feasible_point_finder = int(linecell[1])
                  
                    elif linecell[0] == "MBH_always_write_archive":
                        self.MBH_always_write_archive = int(linecell[1])
                  
                    elif linecell[0] == "MBH_archive_state_vector":
                        self.MBH_archive_state_vector = int(linecell[1])
                  
                    elif linecell[0] == "MBH_max_not_improve":
                        self.MBH_max_not_improve = int(linecell[1])
                  
                    elif linecell[0] == "MBH_max_trials":
                        self.MBH_max_trials = int(linecell[1])
                  
                    elif linecell[0] == "MBH_max_run_time":
                        self.MBH_max_run_time = int(linecell[1])
                  
                    elif linecell[0] == "MBH_max_step_size":
                        self.MBH_max_step_size = float(linecell[1])
                  
                    elif linecell[0] == "MBH_hop_distribution":
                        self.MBH_hop_distribution = int(linecell[1])
                  
                    elif linecell[0] == "MBH_Pareto_alpha":
                        self.MBH_Pareto_alpha = float(linecell[1])
                  
                    elif linecell[0] == "MBH_write_every_improvement":
                        self.MBH_write_every_improvement = int(linecell[1])
                  
                    elif linecell[0] == "MBH_time_hop_probability":
                        self.MBH_time_hop_probability = float(linecell[1])
                  
                    elif linecell[0] == "snopt_feasibility_tolerance":
                        self.snopt_feasibility_tolerance = float(linecell[1])
                  
                    elif linecell[0] == "snopt_optimality_tolerance":
                        self.snopt_optimality_tolerance = float(linecell[1])
                  
                    elif linecell[0] == "NLP_max_step":
                        self.NLP_max_step = float(linecell[1])
                  
                    elif linecell[0] == "snopt_major_iterations":
                        self.snopt_major_iterations = int(linecell[1])
                  
                    elif linecell[0] == "snopt_minor_iterations":
                        self.snopt_minor_iterations = int(linecell[1])
                  
                    elif linecell[0] == "snopt_max_run_time":
                        self.snopt_max_run_time = int(linecell[1])
                  
                    elif linecell[0] == "enable_Scalatron":
                        self.enable_Scalatron = int(linecell[1])
                  
                    elif linecell[0] == "enable_NLP_chaperone":
                        self.enable_NLP_chaperone = int(linecell[1])
                  
                    elif linecell[0] == "seed_MBH":
                        self.seed_MBH = int(linecell[1])
                  
                    elif linecell[0] == "skip_first_nlp_run":
                        self.skip_first_nlp_run = int(linecell[1])
                  
                    elif linecell[0] == "NLP_stop_on_goal_attain":
                        self.NLP_stop_on_goal_attain = int(linecell[1])
                  
                    elif linecell[0] == "NLP_objective_goal":
                        self.NLP_objective_goal = float(linecell[1])
                  
                    elif linecell[0] == "MBH_RNG_seed":
                        self.MBH_RNG_seed = int(linecell[1])
                  
                    elif linecell[0] == "print_NLP_movie_frames":
                        self.print_NLP_movie_frames = int(linecell[1])
                  
                    elif linecell[0] == "quiet_basinhopping":
                        self.quiet_basinhopping = int(linecell[1])
                  
                    elif linecell[0] == "SPICE_leap_seconds_kernel":
                        self.SPICE_leap_seconds_kernel = linecell[1]
                  
                    elif linecell[0] == "SPICE_reference_frame_kernel":
                        self.SPICE_reference_frame_kernel = linecell[1]
                  
                    elif linecell[0] == "universe_folder":
                        self.universe_folder = linecell[1]
                  
                    elif linecell[0] == "ephemeris_source":
                        self.ephemeris_source = int(linecell[1])
                  
                    elif linecell[0] == "SplineEphem_points_per_period":
                        self.SplineEphem_points_per_period = int(linecell[1])
                  
                    elif linecell[0] == "SplineEphem_non_central_body_sun_points_per_period":
                        self.SplineEphem_non_central_body_sun_points_per_period = int(linecell[1])
                  
                    elif linecell[0] == "SplineEphem_truncate_ephemeris_at_maximum_mission_epoch":
                        self.SplineEphem_truncate_ephemeris_at_maximum_mission_epoch = int(linecell[1])
                  
                    elif linecell[0] == "earliestPossibleEpoch":
                        self.earliestPossibleEpoch = float(linecell[1])
                  
                    elif linecell[0] == "latestPossibleEpoch":
                        self.latestPossibleEpoch = float(linecell[1])
                  
                    elif linecell[0] == "propagatorType":
                        self.propagatorType = int(linecell[1])
                  
                    elif linecell[0] == "integratorType":
                        self.integratorType = int(linecell[1])
                  
                    elif linecell[0] == "integrator_tolerance":
                        self.integrator_tolerance = float(linecell[1])
                  
                    elif linecell[0] == "integration_time_step_size":
                        self.integration_time_step_size = float(linecell[1])
                  
                    elif linecell[0] == "num_timesteps":
                        self.num_timesteps = int(linecell[1])
                  
                    elif linecell[0] == "spiral_segments":
                        self.spiral_segments = int(linecell[1])
                  
                    elif linecell[0] == "allow_initial_mass_to_vary":
                        self.allow_initial_mass_to_vary = int(linecell[1])
                  
                    elif linecell[0] == "maximum_mass":
                        self.maximum_mass = float(linecell[1])
                  
                    elif linecell[0] == "IspLT":
                        self.IspLT = float(linecell[1])
                  
                    elif linecell[0] == "IspLT_minimum":
                        self.IspLT_minimum = float(linecell[1])
                  
                    elif linecell[0] == "IspChem":
                        self.IspChem = float(linecell[1])
                  
                    elif linecell[0] == "Thrust":
                        self.Thrust = float(linecell[1])
                  
                    elif linecell[0] == "LV_margin":
                        self.LV_margin = float(linecell[1])
                  
                    elif linecell[0] == "LV_adapter_mass":
                        self.LV_adapter_mass = float(linecell[1])
                  
                    elif linecell[0] == "engine_type":
                        self.engine_type = int(linecell[1])
                  
                    elif linecell[0] == "number_of_electric_propulsion_systems":
                        self.number_of_electric_propulsion_systems = int(linecell[1])
                  
                    elif linecell[0] == "engine_duty_cycle":
                        self.engine_duty_cycle = float(linecell[1])
                  
                    elif linecell[0] == "duty_cycle_type":
                        self.duty_cycle_type = int(linecell[1])
                  
                    elif linecell[0] == "thrust_scale_factor":
                        self.thrust_scale_factor = float(linecell[1])
                  
                    elif linecell[0] == "power_at_1_AU":
                        self.power_at_1_AU = float(linecell[1])
                  
                    elif linecell[0] == "power_source_type":
                        self.power_source_type = int(linecell[1])
                  
                    elif linecell[0] == "solar_power_model_type":
                        self.solar_power_model_type = int(linecell[1])
                  
                    elif linecell[0] == "solar_power_gamma":
                        self.solar_power_gamma = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "power_margin":
                        self.power_margin = float(linecell[1])
                  
                    elif linecell[0] == "power_decay_rate":
                        self.power_decay_rate = float(linecell[1])
                  
                    elif linecell[0] == "power_system_decay_reference_epoch":
                        self.power_system_decay_reference_epoch = float(linecell[1])
                  
                    elif linecell[0] == "throttle_sharpness":
                        self.throttle_sharpness = float(linecell[1])
                  
                    elif linecell[0] == "throttle_logic_mode":
                        self.throttle_logic_mode = int(linecell[1])
                  
                    elif linecell[0] == "spacecraft_power_coefficients":
                        self.spacecraft_power_coefficients = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "engine_input_thrust_coefficients":
                        self.engine_input_thrust_coefficients = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "engine_input_mass_flow_rate_coefficients":
                        self.engine_input_mass_flow_rate_coefficients = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "engine_input_power_bounds":
                        self.engine_input_power_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "user_defined_engine_efficiency":
                        self.user_defined_engine_efficiency = float(linecell[1])
                  
                    elif linecell[0] == "spacecraft_power_model_type":
                        self.spacecraft_power_model_type = int(linecell[1])
                  
                    elif linecell[0] == "TCM_Isp":
                        self.TCM_Isp = float(linecell[1])
                  
                    elif linecell[0] == "TCM_post_launch":
                        self.TCM_post_launch = float(linecell[1])
                  
                    elif linecell[0] == "TCM_pre_flyby":
                        self.TCM_pre_flyby = float(linecell[1])
                  
                    elif linecell[0] == "TCM_maneuver_fraction":
                        self.TCM_maneuver_fraction = float(linecell[1])
                  
                    elif linecell[0] == "trackACS":
                        self.trackACS = int(linecell[1])
                  
                    elif linecell[0] == "ACS_kg_per_day":
                        self.ACS_kg_per_day = float(linecell[1])
                  
                    elif linecell[0] == "final_mass_constraint_bounds":
                        self.final_mass_constraint_bounds = [float(entry) for entry in linecell[1:]]
                  
                    elif linecell[0] == "constrain_final_mass":
                        self.constrain_final_mass = int(linecell[1])
                  
                    elif linecell[0] == "constrain_dry_mass":
                        self.constrain_dry_mass = int(linecell[1])
                  
                    elif linecell[0] == "enable_electric_propellant_tank_constraint":
                        self.enable_electric_propellant_tank_constraint = int(linecell[1])
                  
                    elif linecell[0] == "maximum_electric_propellant":
                        self.maximum_electric_propellant = float(linecell[1])
                  
                    elif linecell[0] == "electric_propellant_margin":
                        self.electric_propellant_margin = float(linecell[1])
                  
                    elif linecell[0] == "enable_chemical_propellant_tank_constraint":
                        self.enable_chemical_propellant_tank_constraint = int(linecell[1])
                  
                    elif linecell[0] == "maximum_chemical_fuel":
                        self.maximum_chemical_fuel = float(linecell[1])
                  
                    elif linecell[0] == "maximum_chemical_oxidizer":
                        self.maximum_chemical_oxidizer = float(linecell[1])
                  
                    elif linecell[0] == "bipropellant_mixture_ratio":
                        self.bipropellant_mixture_ratio = float(linecell[1])
                  
                    elif linecell[0] == "chemical_propellant_margin":
                        self.chemical_propellant_margin = float(linecell[1])
                  
                    elif linecell[0] == "SpacecraftModelInput":
                        self.SpacecraftModelInput = int(linecell[1])
                  
                    elif linecell[0] == "HardwarePath":
                        self.HardwarePath = linecell[1]
                  
                    elif linecell[0] == "ThrottleTableFile":
                        self.ThrottleTableFile = linecell[1]
                  
                    elif linecell[0] == "LaunchVehicleLibraryFile":
                        self.LaunchVehicleLibraryFile = linecell[1]
                  
                    elif linecell[0] == "PowerSystemsLibraryFile":
                        self.PowerSystemsLibraryFile = linecell[1]
                  
                    elif linecell[0] == "PropulsionSystemsLibraryFile":
                        self.PropulsionSystemsLibraryFile = linecell[1]
                  
                    elif linecell[0] == "SpacecraftOptionsFile":
                        self.SpacecraftOptionsFile = linecell[1]
                  
                    elif linecell[0] == "LaunchVehicleKey":
                        self.LaunchVehicleKey = linecell[1]
                  
                    elif linecell[0] == "PowerSystemKey":
                        self.PowerSystemKey = linecell[1]
                  
                    elif linecell[0] == "ElectricPropulsionSystemKey":
                        self.ElectricPropulsionSystemKey = linecell[1]
                  
                    elif linecell[0] == "ChemicalPropulsionSystemKey":
                        self.ChemicalPropulsionSystemKey = linecell[1]
                  
                    elif linecell[0] == "perturb_SRP":
                        self.perturb_SRP = int(linecell[1])
                  
                    elif linecell[0] == "perturb_thirdbody":
                        self.perturb_thirdbody = int(linecell[1])
                  
                    elif linecell[0] == "perturb_J2":
                        self.perturb_J2 = int(linecell[1])
                  
                    elif linecell[0] == "spacecraft_area":
                        self.spacecraft_area = float(linecell[1])
                  
                    elif linecell[0] == "coefficient_of_reflectivity":
                        self.coefficient_of_reflectivity = float(linecell[1])
                  
                    elif linecell[0] == "solar_percentage":
                        self.solar_percentage = float(linecell[1])
                  
                    elif linecell[0] == "solar_flux":
                        self.solar_flux = float(linecell[1])
                  
                    elif linecell[0] == "speed_of_light_vac":
                        self.speed_of_light_vac = float(linecell[1])
                  
                    elif linecell[0] == "forced_post_launch_coast":
                        self.forced_post_launch_coast = float(linecell[1])
                  
                    elif linecell[0] == "forced_pre_flyby_coast":
                        self.forced_pre_flyby_coast = float(linecell[1])
                  
                    elif linecell[0] == "forced_post_flyby_coast":
                        self.forced_post_flyby_coast = float(linecell[1])
                  
                    elif linecell[0] == "waypoint_file_path":
                        self.waypoint_file_path = linecell[1]
                  
                    elif linecell[0] == "covariance_file_path":
                        self.covariance_file_path = linecell[1]
                  
                    elif linecell[0] == "ParallelShootingStateRepresentation":
                        self.ParallelShootingStateRepresentation = int(linecell[1])
                  
                    elif linecell[0] == "PeriapseBoundaryStateRepresentation":
                        self.PeriapseBoundaryStateRepresentation = int(linecell[1])
                  
                    elif linecell[0] == "ParallelShootingConstraintStateRepresentation":
                        self.ParallelShootingConstraintStateRepresentation = int(linecell[1])
                  
                    elif linecell[0] == "print_only_non_default_options":
                        self.print_only_non_default_options = int(linecell[1])
                  
                    elif linecell[0] == "output_file_frame":
                        self.output_file_frame = int(linecell[1])
                  
                    elif linecell[0] == "override_default_output_file_name":
                        self.override_default_output_file_name = int(linecell[1])
                  
                    elif linecell[0] == "forced_output_file_name":
                        self.forced_output_file_name = linecell[1]
                  
                    elif linecell[0] == "output_dormant_journeys":
                        self.output_dormant_journeys = int(linecell[1])
                  
                    elif linecell[0] == "post_mission_wait_time":
                        self.post_mission_wait_time = float(linecell[1])
                  
                    elif linecell[0] == "override_working_directory":
                        self.override_working_directory = int(linecell[1])
                  
                    elif linecell[0] == "forced_working_directory":
                        self.forced_working_directory = linecell[1]
                  
                    elif linecell[0] == "override_mission_subfolder":
                        self.override_mission_subfolder = int(linecell[1])
                  
                    elif linecell[0] == "forced_mission_subfolder":
                        self.forced_mission_subfolder = linecell[1]
                  
                    elif linecell[0] == "short_output_file_names":
                        self.short_output_file_names = int(linecell[1])
                  
                    elif linecell[0] == "generate_forward_integrated_ephemeris":
                        self.generate_forward_integrated_ephemeris = int(linecell[1])
                  
                    elif linecell[0] == "forward_integrated_ephemeris_central_body_SPICE_ID":
                        self.forward_integrated_ephemeris_central_body_SPICE_ID = int(linecell[1])
                  
                    elif linecell[0] == "add_control_switch_line_to_ephemeris":
                        self.add_control_switch_line_to_ephemeris = int(linecell[1])
                  
                    elif linecell[0] == "append_mass_to_ephemeris_output":
                        self.append_mass_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_control_to_ephemeris_output":
                        self.append_control_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_thrust_to_ephemeris_output":
                        self.append_thrust_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_mdot_to_ephemeris_output":
                        self.append_mdot_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_Isp_to_ephemeris_output":
                        self.append_Isp_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_active_power_to_ephemeris_output":
                        self.append_active_power_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_number_of_active_engines_to_ephemeris_output":
                        self.append_number_of_active_engines_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "append_throttle_level_to_ephemeris_output":
                        self.append_throttle_level_to_ephemeris_output = int(linecell[1])
                  
                    elif linecell[0] == "call_system_to_generate_bsp":
                        self.call_system_to_generate_bsp = int(linecell[1])
                  
                    elif linecell[0] == "spice_utilities_path":
                        self.spice_utilities_path = linecell[1]
                  
                    elif linecell[0] == "spice_utility_extension":
                        self.spice_utility_extension = linecell[1]
                  
                    elif linecell[0] == "pyemtg_path":
                        self.pyemtg_path = linecell[1]
                  
                    elif linecell[0] == "spacecraft_SPICE_ID":
                        self.spacecraft_SPICE_ID = int(linecell[1])
                  
                    elif linecell[0] == "background_mode":
                        self.background_mode = int(linecell[1])
                  
                    elif linecell[0] == "output_STMs":
                        self.output_STMs = int(linecell[1])
                  
                    elif linecell[0] == "output_maneuver_and_target_spec_files":
                        self.output_maneuver_and_target_spec_files = int(linecell[1])
                  
                    elif linecell[0] == "generate_acceleration_model_instrumentation_file":
                        self.generate_acceleration_model_instrumentation_file = int(linecell[1])
                  
                    elif linecell[0] == "stop_after_journey":
                        self.stop_after_journey = int(linecell[1])
                  
                    elif linecell[0] == "run_inner_loop":
                        self.run_inner_loop = int(linecell[1])
                  
                    elif linecell[0] == "check_derivatives":
                        self.check_derivatives = int(linecell[1])
                  
                    elif linecell[0] == "user_data":
                        self.user_data = dict()                                                          
                        full_notes = line.lstrip("user_data").lstrip(" ").rstrip(" \r\n")                
                        if ":" in full_notes or full_notes.replace(" ","") != "":                        
                            full_notes = full_notes.split(":")                                           
                                                                                                         
                            for note in full_notes:                                                      
                                var = note.lstrip('("').split(",")[0].rstrip('"')                        
                                val = eval(note.lstrip("(").lstrip(var + '"').lstrip(", ").rstrip(") ")) 
                                self.user_data.update({var:val})                                         
                  
                    elif linecell[0] == "BEGIN_JOURNEY":
                        self.Journeys.append(JourneyOptions.JourneyOptions(inputFile, lineNumber))
        
        self.number_of_journeys = len(self.Journeys)
        
        for journeyIndex in range(0, len(self.Journeys)):
            self.Journeys[journeyIndex].universe_folder = self.universe_folder
        
        self.ConvertDecisionVector()
        self.AssembleMasterDecisionVector()
        self.AssembleMasterConstraintVectors()
        
    #************************************************************************************write
    def write_options_file(self, optionsFileName, writeAll = False):
        
        #Disassemble the master constraint and decision vectors, just in case we modified them. We want any changes to be reflected at the Journey level.
        self.DisassembleMasterDecisionVector()
        self.DisassembleMasterConstraintVectors()
        
        with open(optionsFileName, "w+") as optionsFile:
            optionsFile.write("#EMTGv9 .emtgopt file version 2\n")
            optionsFile.write("\n")
            
            if (self.mission_name != "default" or writeAll):
                optionsFile.write("#mission name\n")
                optionsFile.write("mission_name " + str(self.mission_name) + "\n")
    
            if (self.objective_type != 2 or writeAll):
                optionsFile.write("#objective function type\n#0: minimum deltaV\n#1: minimum time\n#2: maximum final mass\n#3: maximize initial mass\n#4: depart as late as possible in the window\n#5: depart as early as possible in the window\n#6: maximize orbit energy\n#7: minimize launch mass\n#8: arrive as early as possible\n#9: arrive as late as possible\n#10: <PLACEHOLDER FOR FUTURE OBJECTIVE FUNCTIONS>\n#11: maximum dry/wet ratio\n#12: maximum arrival kinetic energy\n#13: minimum BOL power\n#14: maximize log_10(final mass)\n#15: maximum log_e(final mass)\n#16: maximum dry mass margin\n#17: maximum dry mass\n#18: maximum log_10(dry mass)\n#19: maximum log_e(dry mass)\n#20: minimize chemical fuel\n#21: minimize chemical oxidizer\n#22: minimize electric propellant\n#23: minimize total propellant\n#24: minimize waypoint tracking error\n#25: minimize initial impulse magnitude\n#26: maximize distance from central body\n")
                optionsFile.write("objective_type " + str(self.objective_type) + "\n")
    
            if (self.objective_journey != 0 or writeAll):
                optionsFile.write("#Journey associated with objective function (if applicable)\n")
                optionsFile.write("objective_journey " + str(self.objective_journey) + "\n")
    
            if (self.include_initial_impulse_in_cost != 0 or writeAll):
                optionsFile.write("#Include the initial impulse in calculating the delta-v objective function?\n")
                optionsFile.write("include_initial_impulse_in_cost " + str(int(self.include_initial_impulse_in_cost)) + "\n")
    
            if (self.global_timebounded != 1 or writeAll):
                optionsFile.write("#0: unbounded, 1: bounded total time (note that the global arrival date bound is by definition the same as the last journey's arrival date bound and is not duplicated\n")
                optionsFile.write("global_timebounded " + str(int(self.global_timebounded)) + "\n")
    
            if (self.launch_window_open_date != 53782 or writeAll):
                optionsFile.write("#launch window open date (MJD)\n")
                optionsFile.write("launch_window_open_date " + str(self.launch_window_open_date) + "\n")
    
            if (self.total_flight_time_bounds != [0.0, 302] or writeAll):
                optionsFile.write("#flight time bounds (days)\n")
                optionsFile.write("total_flight_time_bounds")
                for entry in self.total_flight_time_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.DLA_bounds != [-90.0, 90.0] or writeAll):
                optionsFile.write("#DLA in degrees\n")
                optionsFile.write("DLA_bounds")
                for entry in self.DLA_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.RLA_bounds != [-2880.0, 2880.0] or writeAll):
                optionsFile.write("#RLA in degrees\n")
                optionsFile.write("RLA_bounds")
                for entry in self.RLA_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.mission_type != 2 or writeAll):
                optionsFile.write("#phase type\n#0: MGALTS\n#1: FBLTS\n#2: MGALT\n#3: FBLT\n#4: PSBI\n#5: PSFB\n#6: MGAnDSMs\n#7: CoastPhase\n#8: SundmanCoastPhase\n#9: variable phase type\n#10: ProbeEntryPhase\n#11 ControlLawThrustPhase\n")
                optionsFile.write("mission_type " + str(self.mission_type) + "\n")
    
            if (self.NLP_solver_type != 0 or writeAll):
                optionsFile.write("#NLP solver type\n#0: SNOPT\n#1: WORHP\n")
                optionsFile.write("NLP_solver_type " + str(self.NLP_solver_type) + "\n")
    
            if (self.NLP_solver_mode != 1 or writeAll):
                optionsFile.write("#NLP solver mode\n#0: find feasible point only\n#1: find optimal solution\n#2: satisfy equality constraints\n")
                optionsFile.write("NLP_solver_mode " + str(self.NLP_solver_mode) + "\n")
    
            if (self.quiet_NLP != 1 or writeAll):
                optionsFile.write("#Quiet NLP solver?\n")
                optionsFile.write("quiet_NLP " + str(int(self.quiet_NLP)) + "\n")
    
            if (self.ACE_feasible_point_finder != 0 or writeAll):
                optionsFile.write("#Enable ACE feasible point finder?\n")
                optionsFile.write("ACE_feasible_point_finder " + str(int(self.ACE_feasible_point_finder)) + "\n")
    
            if (self.MBH_always_write_archive != 0 or writeAll):
                optionsFile.write("#Write every hop to the MBH archive, even if it is not an improvement?\n")
                optionsFile.write("MBH_always_write_archive " + str(int(self.MBH_always_write_archive)) + "\n")
    
            if (self.MBH_archive_state_vector != 0 or writeAll):
                optionsFile.write("#include state vector in MBH archive file?\n")
                optionsFile.write("MBH_archive_state_vector " + str(int(self.MBH_archive_state_vector)) + "\n")
    
            if (self.MBH_max_not_improve != 10000 or writeAll):
                optionsFile.write("#quantity Max_not_improve for MBH\n")
                optionsFile.write("MBH_max_not_improve " + str(self.MBH_max_not_improve) + "\n")
    
            if (self.MBH_max_trials != 1000000 or writeAll):
                optionsFile.write("#maximum number of trials for MBH\n")
                optionsFile.write("MBH_max_trials " + str(self.MBH_max_trials) + "\n")
    
            if (self.MBH_max_run_time != 60 or writeAll):
                optionsFile.write("#maximum run time for MBH, in seconds\n")
                optionsFile.write("MBH_max_run_time " + str(self.MBH_max_run_time) + "\n")
    
            if (self.MBH_max_step_size != 1 or writeAll):
                optionsFile.write("#Maximum step size (uniform) or scale factor (other distributions)\n")
                optionsFile.write("MBH_max_step_size " + str(self.MBH_max_step_size) + "\n")
    
            if (self.MBH_hop_distribution != 2 or writeAll):
                optionsFile.write("#MBH hop probabilty distribution\n#0: uniform\n#1: Cauchy\n#2: Pareto\n#3: Gaussian\n")
                optionsFile.write("MBH_hop_distribution " + str(self.MBH_hop_distribution) + "\n")
    
            if (self.MBH_Pareto_alpha != 1.4 or writeAll):
                optionsFile.write("#Pareto distribution alpha\n")
                optionsFile.write("MBH_Pareto_alpha " + str(self.MBH_Pareto_alpha) + "\n")
    
            if (self.MBH_write_every_improvement != 0 or writeAll):
                optionsFile.write("#Write every MBH improvement for later animation?\n")
                optionsFile.write("MBH_write_every_improvement " + str(int(self.MBH_write_every_improvement)) + "\n")
    
            if (self.MBH_time_hop_probability != 0.05 or writeAll):
                optionsFile.write("#probability of MBH time hop operation\n")
                optionsFile.write("MBH_time_hop_probability " + str(self.MBH_time_hop_probability) + "\n")
    
            if (self.snopt_feasibility_tolerance != 1.00E-05 or writeAll):
                optionsFile.write("#feasibility tolerance\n")
                optionsFile.write("snopt_feasibility_tolerance " + str(self.snopt_feasibility_tolerance) + "\n")
    
            if (self.snopt_optimality_tolerance != 1.00E-05 or writeAll):
                optionsFile.write("#optimality tolerance\n")
                optionsFile.write("snopt_optimality_tolerance " + str(self.snopt_optimality_tolerance) + "\n")
    
            if (self.NLP_max_step != 1 or writeAll):
                optionsFile.write("#NLP max step\n")
                optionsFile.write("NLP_max_step " + str(self.NLP_max_step) + "\n")
    
            if (self.snopt_major_iterations != 8000 or writeAll):
                optionsFile.write("#NLP major iterations\n")
                optionsFile.write("snopt_major_iterations " + str(self.snopt_major_iterations) + "\n")
    
            if (self.snopt_minor_iterations != 500 or writeAll):
                optionsFile.write("#NLP minor iterations\n")
                optionsFile.write("snopt_minor_iterations " + str(self.snopt_minor_iterations) + "\n")
    
            if (self.snopt_max_run_time != 15 or writeAll):
                optionsFile.write("#NLP max run time (seconds)\n")
                optionsFile.write("snopt_max_run_time " + str(self.snopt_max_run_time) + "\n")
    
            if (self.enable_Scalatron != 1 or writeAll):
                optionsFile.write("#Enable Scalatron?\n")
                optionsFile.write("enable_Scalatron " + str(int(self.enable_Scalatron)) + "\n")
    
            if (self.enable_NLP_chaperone != 1 or writeAll):
                optionsFile.write("#Enable NLP chaperone?\n")
                optionsFile.write("enable_NLP_chaperone " + str(int(self.enable_NLP_chaperone)) + "\n")
    
            if (self.seed_MBH != 0 or writeAll):
                optionsFile.write("#Seed MBH?\n")
                optionsFile.write("seed_MBH " + str(int(self.seed_MBH)) + "\n")
    
            if (self.skip_first_nlp_run != 0 or writeAll):
                optionsFile.write("#Skip first NLP run in an MBH process?\n")
                optionsFile.write("skip_first_nlp_run " + str(int(self.skip_first_nlp_run)) + "\n")
    
            if (self.NLP_stop_on_goal_attain != 0 or writeAll):
                optionsFile.write("#Stop NLP on goal attain?\n")
                optionsFile.write("NLP_stop_on_goal_attain " + str(int(self.NLP_stop_on_goal_attain)) + "\n")
    
            if (self.NLP_objective_goal != 0 or writeAll):
                optionsFile.write("#Objective value at which NLP stops\n")
                optionsFile.write("NLP_objective_goal " + str(self.NLP_objective_goal) + "\n")
    
            if (self.MBH_RNG_seed != -1 or writeAll):
                optionsFile.write("#MBH RNG seed (negative number means system clock)\n")
                optionsFile.write("MBH_RNG_seed " + str(self.MBH_RNG_seed) + "\n")
    
            if (self.print_NLP_movie_frames != 0 or writeAll):
                optionsFile.write("#Print NLP movie frames?\n")
                optionsFile.write("print_NLP_movie_frames " + str(int(self.print_NLP_movie_frames)) + "\n")
    
            if (self.quiet_basinhopping != 0 or writeAll):
                optionsFile.write("#Quiet MBH?\n")
                optionsFile.write("quiet_basinhopping " + str(int(self.quiet_basinhopping)) + "\n")
    
            if (self.SPICE_leap_seconds_kernel != "naif0012.tls" or writeAll):
                optionsFile.write("#SPICE leap seconds kernel - required for SPICE to work\n")
                optionsFile.write("SPICE_leap_seconds_kernel " + str(self.SPICE_leap_seconds_kernel) + "\n")
    
            if (self.SPICE_reference_frame_kernel != "pck00010.tpc" or writeAll):
                optionsFile.write("#SPICE_reference_frame_kernel\n")
                optionsFile.write("SPICE_reference_frame_kernel " + str(self.SPICE_reference_frame_kernel) + "\n")
    
            if (self.universe_folder != "C:/Utilities/Universe" or writeAll):
                optionsFile.write("#Universe folder\n")
                optionsFile.write("universe_folder " + str(self.universe_folder) + "\n")
    
            if (self.ephemeris_source != 2 or writeAll):
                optionsFile.write("#0: static, 1: SPICE (default to static if no SPICE file supplied for a body), 2: SplineEphem\n")
                optionsFile.write("ephemeris_source " + str(self.ephemeris_source) + "\n")
    
            if (self.SplineEphem_points_per_period != 360 or writeAll):
                optionsFile.write("#How many sample points should SplineEphem use per orbital period of each body?\n")
                optionsFile.write("SplineEphem_points_per_period " + str(self.SplineEphem_points_per_period) + "\n")
    
            if (self.SplineEphem_non_central_body_sun_points_per_period != 10000 or writeAll):
                optionsFile.write("#How many sample points should SplineEphem use per orbital period of the sun with respect to the central body?\n")
                optionsFile.write("SplineEphem_non_central_body_sun_points_per_period " + str(self.SplineEphem_non_central_body_sun_points_per_period) + "\n")
    
            if (self.SplineEphem_truncate_ephemeris_at_maximum_mission_epoch != 0 or writeAll):
                optionsFile.write("#Truncate SplineEphem at maximum mission epoch?\n#If you enable this option, global search will be impeded but you will save a lot of memory\n#Useful for monte-carlo, launch period analysis, etc.\n")
                optionsFile.write("SplineEphem_truncate_ephemeris_at_maximum_mission_epoch " + str(int(self.SplineEphem_truncate_ephemeris_at_maximum_mission_epoch)) + "\n")
    
            if (self.earliestPossibleEpoch != 51554.5 or writeAll):
                optionsFile.write("#Beginning of the SplineEphem data set\n")
                optionsFile.write("earliestPossibleEpoch " + str(self.earliestPossibleEpoch) + "\n")
    
            if (self.latestPossibleEpoch != 88058 or writeAll):
                optionsFile.write("#End of the SplineEphem data set\n")
                optionsFile.write("latestPossibleEpoch " + str(self.latestPossibleEpoch) + "\n")
    
            if (self.propagatorType != 0 or writeAll):
                optionsFile.write("#Propagator type\n#0: Keplerian propagator\n#1: Integrated propagator\n")
                optionsFile.write("propagatorType " + str(self.propagatorType) + "\n")
    
            if (self.integratorType != 1 or writeAll):
                optionsFile.write("#Integrator type\n#0: rk7813M adaptive step\n#1: rk8 fixed step\n")
                optionsFile.write("integratorType " + str(self.integratorType) + "\n")
    
            if (self.integrator_tolerance != 1.00E-08 or writeAll):
                optionsFile.write("#adaptive step integrator tolerance\n")
                optionsFile.write("integrator_tolerance " + str(self.integrator_tolerance) + "\n")
    
            if (self.integration_time_step_size != 86400 or writeAll):
                optionsFile.write("#integration step size (maximum for adaptive, fixed for fixed)\n")
                optionsFile.write("integration_time_step_size " + str(self.integration_time_step_size) + "\n")
    
            if (self.num_timesteps != 20 or writeAll):
                optionsFile.write("#number of timesteps per phase\n")
                optionsFile.write("num_timesteps " + str(self.num_timesteps) + "\n")
    
            if (self.spiral_segments != 1 or writeAll):
                optionsFile.write("#number of spiral segments\n")
                optionsFile.write("spiral_segments " + str(self.spiral_segments) + "\n")
    
            if (self.allow_initial_mass_to_vary != 0 or writeAll):
                optionsFile.write("#Allow the mass at the beginning of the first journey to vary up to the allowed maximum?\n")
                optionsFile.write("allow_initial_mass_to_vary " + str(int(self.allow_initial_mass_to_vary)) + "\n")
    
            if (self.maximum_mass != 525.2 or writeAll):
                optionsFile.write("#maximum possible mass of the spacecraft (kg)\n")
                optionsFile.write("maximum_mass " + str(self.maximum_mass) + "\n")
    
            if (self.IspLT != 3000 or writeAll):
                optionsFile.write("#specific impulse of the engine used for low-thrust maneuvers\n")
                optionsFile.write("IspLT " + str(self.IspLT) + "\n")
    
            if (self.IspLT_minimum != 1 or writeAll):
                optionsFile.write("#minimum specific impulse for variable specific impulse problems\n")
                optionsFile.write("IspLT_minimum " + str(self.IspLT_minimum) + "\n")
    
            if (self.IspChem != 320 or writeAll):
                optionsFile.write("#specific impulse of the engine used for impulsive maneuvers\n")
                optionsFile.write("IspChem " + str(self.IspChem) + "\n")
    
            if (self.Thrust != 0.1 or writeAll):
                optionsFile.write("#thrust of the spacecraft, in Newtons\n")
                optionsFile.write("Thrust " + str(self.Thrust) + "\n")
    
            if (self.LV_margin != 0 or writeAll):
                optionsFile.write("#LV margin (as a fraction)\n")
                optionsFile.write("LV_margin " + str(self.LV_margin) + "\n")
    
            if (self.LV_adapter_mass != 0 or writeAll):
                optionsFile.write("#LV adapter mass (kg)\n")
                optionsFile.write("LV_adapter_mass " + str(self.LV_adapter_mass) + "\n")
    
            if (self.engine_type != 5 or writeAll):
                optionsFile.write("#low-thrust engine type\n#0: fixed thrust/Isp\n#1: constant Isp, efficiency, EMTG computes input power\n#2: choice of power model, constant efficiency, EMTG chooses Isp\n#3: choice of power model, constant efficiency and Isp\n#4: continuously-varying specific impulse\n#5: custom thrust and mass flow rate polynomial\n#6: NSTAR\n#7: XIPS-25\n#8: BPT-4000 High-Isp\n#9: BPT-4000 High-Thrust\n#10: BPT-4000 Ex-High-Isp\n#11: NEXT high-Isp v9\n#12: VASIMR (argon, using analytical model)\n#13: Hall Thruster (Xenon, using analytical model)\n#14: NEXT high-ISP v10\n#15: NEXT high-thrust v10\n#16: BPT-4000 MALTO\n#17: NEXIS Cardiff 8-15-201\n#18: H6MS Cardiff 8-15-2013\n#19: BHT20K Cardiff 8-16-2013\n#20: Aerojet HiVHAC EM\n#21: 13 kW STMD Hall high-Isp (not available in open-source)\n#22: 13 kW STMD Hall high-thrust (not available in open-source)\n#23: NEXT TT11 High-Thrust\n#24: NEXT TT11 High-Isp\n#25: NEXT TT11 Expanded Throttle Table\n#26: 13 kW STMD Hall high-Isp 10-1-2014 (not available in open-source)\n#27: 13 kW STMD Hall medium-thrust 10-1-2014 (not available in open-source)\n#28: 13 kW STMD Hall high-thrust 10-1-2014 (not available in open-source)\n#29: 2D Throttle table\n#30: 1D Throttle table high-thrust\n#31: 1D Throttle table high-Isp\n#32: 2D polynomial fit\n")
                optionsFile.write("engine_type " + str(self.engine_type) + "\n")
    
            if (self.number_of_electric_propulsion_systems != 1 or writeAll):
                optionsFile.write("#number of thruster systems (used to be called number of engines)\n")
                optionsFile.write("number_of_electric_propulsion_systems " + str(self.number_of_electric_propulsion_systems) + "\n")
    
            if (self.engine_duty_cycle != 1 or writeAll):
                optionsFile.write("#percentage of time that engine can operate\n")
                optionsFile.write("engine_duty_cycle " + str(self.engine_duty_cycle) + "\n")
    
            if (self.duty_cycle_type != 0 or writeAll):
                optionsFile.write("#duty cycle type\n#0: averaged\n#1: realistic\n")
                optionsFile.write("duty_cycle_type " + str(self.duty_cycle_type) + "\n")
    
            if (self.thrust_scale_factor != 1 or writeAll):
                optionsFile.write("#scale factor to apply to thrust ONLY, not mass flow rate, can use to approximate cosine loss\n")
                optionsFile.write("thrust_scale_factor " + str(self.thrust_scale_factor) + "\n")
    
            if (self.power_at_1_AU != 5 or writeAll):
                optionsFile.write("#Power at 1 AU (kW)\n")
                optionsFile.write("power_at_1_AU " + str(self.power_at_1_AU) + "\n")
    
            if (self.power_source_type != 1 or writeAll):
                optionsFile.write("#power source type, 0: fixed, 1: solar\n")
                optionsFile.write("power_source_type " + str(self.power_source_type) + "\n")
    
            if (self.solar_power_model_type != 0 or writeAll):
                optionsFile.write("#Solar power model type\n#0: classic Sauer model\n#1: polynomial (0th order on the left)\n")
                optionsFile.write("solar_power_model_type " + str(self.solar_power_model_type) + "\n")
    
            if (self.solar_power_gamma != [1.32077,-0.10848,-0.11665,0.10843,-0.01279,0.0,0.0] or writeAll):
                optionsFile.write("#solar power coefficients gamma_1 through gamma_5, if all gamma = [1 0 0 0 0], then solar power is a simple 1/r^2\n")
                optionsFile.write("solar_power_gamma")
                for entry in self.solar_power_gamma:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.power_margin != 0 or writeAll):
                optionsFile.write("#power margin (fraction)\n")
                optionsFile.write("power_margin " + str(self.power_margin) + "\n")
    
            if (self.power_decay_rate != 0 or writeAll):
                optionsFile.write("#power system decay rate (fraction per year)\n")
                optionsFile.write("power_decay_rate " + str(self.power_decay_rate) + "\n")
    
            if (self.power_system_decay_reference_epoch != 51544.5 or writeAll):
                optionsFile.write("#reference date when the power system begins to decay\n")
                optionsFile.write("power_system_decay_reference_epoch " + str(self.power_system_decay_reference_epoch) + "\n")
    
            if (self.throttle_sharpness != 100 or writeAll):
                optionsFile.write("#Throttle sharpness (higher means more precise, lower means smoother)\n")
                optionsFile.write("throttle_sharpness " + str(self.throttle_sharpness) + "\n")
    
            if (self.throttle_logic_mode != 1 or writeAll):
                optionsFile.write("#Throttle logic mode\n#0: maximum number of thrusters\n#1: minimum number of thrusters\n")
                optionsFile.write("throttle_logic_mode " + str(self.throttle_logic_mode) + "\n")
    
            if (self.spacecraft_power_coefficients != [0,0,0] or writeAll):
                optionsFile.write("#spacecraft power coefficients A, B, and C\n#represent the power requirements of the spacecraft at a distance r from the sun\n#i.e. heaters, communications, etc\n")
                optionsFile.write("spacecraft_power_coefficients")
                for entry in self.spacecraft_power_coefficients:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.engine_input_thrust_coefficients != [26.337459,-51.694393,90.486509,-36.720293,5.145602,0.0,0.0] or writeAll):
                optionsFile.write("#thrust polynomial coefficients\n")
                optionsFile.write("engine_input_thrust_coefficients")
                for entry in self.engine_input_thrust_coefficients:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.engine_input_mass_flow_rate_coefficients != [2.5060,-5.3568,6.2539,-2.5372,0.36985,0.0,0.0] or writeAll):
                optionsFile.write("#mass flow rate polynomial coefficients\n")
                optionsFile.write("engine_input_mass_flow_rate_coefficients")
                for entry in self.engine_input_mass_flow_rate_coefficients:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.engine_input_power_bounds != [0.525, 2.6] or writeAll):
                optionsFile.write("#thruster input power bounds (kW)\n")
                optionsFile.write("engine_input_power_bounds")
                for entry in self.engine_input_power_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.user_defined_engine_efficiency != 0.7 or writeAll):
                optionsFile.write("#Propulsion system efficiency (fraction)\n")
                optionsFile.write("user_defined_engine_efficiency " + str(self.user_defined_engine_efficiency) + "\n")
    
            if (self.spacecraft_power_model_type != 0 or writeAll):
                optionsFile.write("#spacecraft power model type\n#0: P_sc = A + B/r + C/r^2\n#1: P_sc = A if P > A, A + B(C - P) otherwise\n")
                optionsFile.write("spacecraft_power_model_type " + str(self.spacecraft_power_model_type) + "\n")
    
            if (self.TCM_Isp != 200 or writeAll):
                optionsFile.write("#Isp for TCMs\n")
                optionsFile.write("TCM_Isp " + str(self.TCM_Isp) + "\n")
    
            if (self.TCM_post_launch != 0 or writeAll):
                optionsFile.write("#TCM magnitude post-launch (km/s)\n")
                optionsFile.write("TCM_post_launch " + str(self.TCM_post_launch) + "\n")
    
            if (self.TCM_pre_flyby != 0 or writeAll):
                optionsFile.write("#TCM magnitude before flybys (km/s)\n")
                optionsFile.write("TCM_pre_flyby " + str(self.TCM_pre_flyby) + "\n")
    
            if (self.TCM_maneuver_fraction != 0 or writeAll):
                optionsFile.write("#Post-DSM TCM magnitude as a fraction of DSM magnitude\n")
                optionsFile.write("TCM_maneuver_fraction " + str(self.TCM_maneuver_fraction) + "\n")
    
            if (self.trackACS != 0 or writeAll):
                optionsFile.write("#Track ACS propellant consumption?\n")
                optionsFile.write("trackACS " + str(int(self.trackACS)) + "\n")
    
            if (self.ACS_kg_per_day != 0 or writeAll):
                optionsFile.write("#ACS propellant consumption (kg/day)\n")
                optionsFile.write("ACS_kg_per_day " + str(self.ACS_kg_per_day) + "\n")
    
            if (self.final_mass_constraint_bounds != [0.0, 0.0] or writeAll):
                optionsFile.write("#Bounds on final mass constraints\n")
                optionsFile.write("final_mass_constraint_bounds")
                for entry in self.final_mass_constraint_bounds:
                    optionsFile.write(" " + str(entry))
                optionsFile.write("\n")
    
            if (self.constrain_final_mass != 0 or writeAll):
                optionsFile.write("#Constrain final wet mass?\n")
                optionsFile.write("constrain_final_mass " + str(int(self.constrain_final_mass)) + "\n")
    
            if (self.constrain_dry_mass != 0 or writeAll):
                optionsFile.write("#Constrain dry mass?\n")
                optionsFile.write("constrain_dry_mass " + str(int(self.constrain_dry_mass)) + "\n")
    
            if (self.enable_electric_propellant_tank_constraint != 0 or writeAll):
                optionsFile.write("#Constrain electric propellant tank?\n")
                optionsFile.write("enable_electric_propellant_tank_constraint " + str(int(self.enable_electric_propellant_tank_constraint)) + "\n")
    
            if (self.maximum_electric_propellant != 1000 or writeAll):
                optionsFile.write("#Electric propellant tank capacity (kg)\n")
                optionsFile.write("maximum_electric_propellant " + str(self.maximum_electric_propellant) + "\n")
    
            if (self.electric_propellant_margin != 0 or writeAll):
                optionsFile.write("#Electric propellant margin (fraction)\n")
                optionsFile.write("electric_propellant_margin " + str(self.electric_propellant_margin) + "\n")
    
            if (self.enable_chemical_propellant_tank_constraint != 0 or writeAll):
                optionsFile.write("#Constrain chemical propellant?\n")
                optionsFile.write("enable_chemical_propellant_tank_constraint " + str(int(self.enable_chemical_propellant_tank_constraint)) + "\n")
    
            if (self.maximum_chemical_fuel != 1000 or writeAll):
                optionsFile.write("#Chemical fuel tank capacity (kg)\n")
                optionsFile.write("maximum_chemical_fuel " + str(self.maximum_chemical_fuel) + "\n")
    
            if (self.maximum_chemical_oxidizer != 1000 or writeAll):
                optionsFile.write("#Chemical oxidizer tank capacity (kg)\n")
                optionsFile.write("maximum_chemical_oxidizer " + str(self.maximum_chemical_oxidizer) + "\n")
    
            if (self.bipropellant_mixture_ratio != 0.925 or writeAll):
                optionsFile.write("#Bipropellant mixture ratio\n")
                optionsFile.write("bipropellant_mixture_ratio " + str(self.bipropellant_mixture_ratio) + "\n")
    
            if (self.chemical_propellant_margin != 0 or writeAll):
                optionsFile.write("#Chemical propellant margin (fraction)\n")
                optionsFile.write("chemical_propellant_margin " + str(self.chemical_propellant_margin) + "\n")
    
            if (self.SpacecraftModelInput != 2 or writeAll):
                optionsFile.write("#Spacecraft object input type\n#0: Assemble from libraries\n#1: Read .emtg_spacecraftoptions file\n#2: Assemble from missionoptions object\n")
                optionsFile.write("SpacecraftModelInput " + str(self.SpacecraftModelInput) + "\n")
    
            if (self.HardwarePath != "c:/Utilities/HardwareModels/" or writeAll):
                optionsFile.write("#HardwarePath\n")
                optionsFile.write("HardwarePath " + str(self.HardwarePath) + "\n")
    
            if (self.ThrottleTableFile != "empty.ThrottleTable" or writeAll):
                optionsFile.write("#ThrottleTableFile\n")
                optionsFile.write("ThrottleTableFile " + str(self.ThrottleTableFile) + "\n")
    
            if (self.LaunchVehicleLibraryFile != "default.emtg_launchvehicleopt" or writeAll):
                optionsFile.write("#LaunchVehicleLibraryFile\n")
                optionsFile.write("LaunchVehicleLibraryFile " + str(self.LaunchVehicleLibraryFile) + "\n")
    
            if (self.PowerSystemsLibraryFile != "default.emtg_powersystemsopt" or writeAll):
                optionsFile.write("#PowerSystemsLibraryFile\n")
                optionsFile.write("PowerSystemsLibraryFile " + str(self.PowerSystemsLibraryFile) + "\n")
    
            if (self.PropulsionSystemsLibraryFile != "default.emtg_propulsionsystemopt" or writeAll):
                optionsFile.write("#PropulsionSystemsLibraryFile\n")
                optionsFile.write("PropulsionSystemsLibraryFile " + str(self.PropulsionSystemsLibraryFile) + "\n")
    
            if (self.SpacecraftOptionsFile != "default.emtg_spacecraftopt" or writeAll):
                optionsFile.write("#SpacecraftOptionsFile\n")
                optionsFile.write("SpacecraftOptionsFile " + str(self.SpacecraftOptionsFile) + "\n")
    
            if (self.LaunchVehicleKey != "ExampleRocket" or writeAll):
                optionsFile.write("#LaunchVehicleKey\n")
                optionsFile.write("LaunchVehicleKey " + str(self.LaunchVehicleKey) + "\n")
    
            if (self.PowerSystemKey != "5kW_basic" or writeAll):
                optionsFile.write("#PowerSystemKey\n")
                optionsFile.write("PowerSystemKey " + str(self.PowerSystemKey) + "\n")
    
            if (self.ElectricPropulsionSystemKey != "defaultThruster" or writeAll):
                optionsFile.write("#ElectricPropulsionSystemKey\n")
                optionsFile.write("ElectricPropulsionSystemKey " + str(self.ElectricPropulsionSystemKey) + "\n")
    
            if (self.ChemicalPropulsionSystemKey != "DefaultChemicalPropulsionSystem" or writeAll):
                optionsFile.write("#ChemicalPropulsionSystemKey\n")
                optionsFile.write("ChemicalPropulsionSystemKey " + str(self.ChemicalPropulsionSystemKey) + "\n")
    
            if (self.perturb_SRP != 0 or writeAll):
                optionsFile.write("#solar radiation pressure?\n")
                optionsFile.write("perturb_SRP " + str(int(self.perturb_SRP)) + "\n")
    
            if (self.perturb_thirdbody != 0 or writeAll):
                optionsFile.write("#third body perturbations?\n")
                optionsFile.write("perturb_thirdbody " + str(int(self.perturb_thirdbody)) + "\n")
    
            if (self.perturb_J2 != 0 or writeAll):
                optionsFile.write("#J2?\n")
                optionsFile.write("perturb_J2 " + str(int(self.perturb_J2)) + "\n")
    
            if (self.spacecraft_area != 70 or writeAll):
                optionsFile.write("#spacecraft area (for SRP, in m^2)\n")
                optionsFile.write("spacecraft_area " + str(self.spacecraft_area) + "\n")
    
            if (self.coefficient_of_reflectivity != 1 or writeAll):
                optionsFile.write("#Coefficient of reflectivity\n")
                optionsFile.write("coefficient_of_reflectivity " + str(self.coefficient_of_reflectivity) + "\n")
    
            if (self.solar_percentage != 1 or writeAll):
                optionsFile.write("#Percentage of the Sun seen by the spacecraft\n")
                optionsFile.write("solar_percentage " + str(self.solar_percentage) + "\n")
    
            if (self.solar_flux != 1359.39 or writeAll):
                optionsFile.write("#Solar constant (flux density at 1 AU) [W/m^2 = kg/s^3]\n")
                optionsFile.write("solar_flux " + str(self.solar_flux) + "\n")
    
            if (self.speed_of_light_vac != 299792458 or writeAll):
                optionsFile.write("#Speed of light in a vacuum [m/s]\n")
                optionsFile.write("speed_of_light_vac " + str(self.speed_of_light_vac) + "\n")
    
            if (self.forced_post_launch_coast != 0 or writeAll):
                optionsFile.write("#Forced post-launch coast, in days\n")
                optionsFile.write("forced_post_launch_coast " + str(self.forced_post_launch_coast) + "\n")
    
            if (self.forced_pre_flyby_coast != 0 or writeAll):
                optionsFile.write("#Forced pre-flyby coast, in days\n")
                optionsFile.write("forced_pre_flyby_coast " + str(self.forced_pre_flyby_coast) + "\n")
    
            if (self.forced_post_flyby_coast != 0 or writeAll):
                optionsFile.write("#Forced post-flyby coast, in days\n")
                optionsFile.write("forced_post_flyby_coast " + str(self.forced_post_flyby_coast) + "\n")
    
            if (self.waypoint_file_path != "./banana.ephemeris" or writeAll):
                optionsFile.write("#Path to waypoint file\n")
                optionsFile.write("waypoint_file_path " + str(self.waypoint_file_path) + "\n")
    
            if (self.covariance_file_path != "./shampoo_bottle.ephemeris" or writeAll):
                optionsFile.write("#Path to covariance file\n")
                optionsFile.write("covariance_file_path " + str(self.covariance_file_path) + "\n")
    
            if (self.ParallelShootingStateRepresentation != 1 or writeAll):
                optionsFile.write("#state representation for parallel shooting (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE)\n")
                optionsFile.write("ParallelShootingStateRepresentation " + str(self.ParallelShootingStateRepresentation) + "\n")
    
            if (self.PeriapseBoundaryStateRepresentation != 1 or writeAll):
                optionsFile.write("#state representation for periapse boundary conditions (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)\n")
                optionsFile.write("PeriapseBoundaryStateRepresentation " + str(self.PeriapseBoundaryStateRepresentation) + "\n")
    
            if (self.ParallelShootingConstraintStateRepresentation != 0 or writeAll):
                optionsFile.write("#state representation for parallel shooting constraints (Cartesian or same as encoded states)\n")
                optionsFile.write("ParallelShootingConstraintStateRepresentation " + str(self.ParallelShootingConstraintStateRepresentation) + "\n")
    
            if (self.print_only_non_default_options != 1 or writeAll):
                optionsFile.write("#Write only options that are *not* default into the .emtgopt file?\n")
                optionsFile.write("print_only_non_default_options " + str(int(self.print_only_non_default_options)) + "\n")
    
            if (self.output_file_frame != 1 or writeAll):
                optionsFile.write("#reference frame for output file (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar)\n")
                optionsFile.write("output_file_frame " + str(self.output_file_frame) + "\n")
    
            if (self.override_default_output_file_name != 0 or writeAll):
                optionsFile.write("#Override default output file name?\n")
                optionsFile.write("override_default_output_file_name " + str(int(self.override_default_output_file_name)) + "\n")
    
            if (self.forced_output_file_name != "forced_output_file_name" or writeAll):
                optionsFile.write("#User-defined output file name\n")
                optionsFile.write("forced_output_file_name " + str(self.forced_output_file_name) + "\n")
    
            if (self.output_dormant_journeys != 0 or writeAll):
                optionsFile.write("#Output ephemeris for time spent waiting between journeys?\n")
                optionsFile.write("output_dormant_journeys " + str(int(self.output_dormant_journeys)) + "\n")
    
            if (self.post_mission_wait_time != 0 or writeAll):
                optionsFile.write("#How long to output an ephemeris after the mission end (days)\n")
                optionsFile.write("post_mission_wait_time " + str(self.post_mission_wait_time) + "\n")
    
            if (self.override_working_directory != 0 or writeAll):
                optionsFile.write("#Override the working directory?\n")
                optionsFile.write("override_working_directory " + str(int(self.override_working_directory)) + "\n")
    
            if (self.forced_working_directory != "..//EMTG_v9_Results" or writeAll):
                optionsFile.write("#User-defined working directory\n")
                optionsFile.write("forced_working_directory " + str(self.forced_working_directory) + "\n")
    
            if (self.override_mission_subfolder != 0 or writeAll):
                optionsFile.write("#Create a mission subfolder?\n")
                optionsFile.write("override_mission_subfolder " + str(int(self.override_mission_subfolder)) + "\n")
    
            if (self.forced_mission_subfolder != "mission_subfolder" or writeAll):
                optionsFile.write("#Mission subfolder\n")
                optionsFile.write("forced_mission_subfolder " + str(self.forced_mission_subfolder) + "\n")
    
            if (self.short_output_file_names != 1 or writeAll):
                optionsFile.write("#Shorten output file names?\n")
                optionsFile.write("short_output_file_names " + str(int(self.short_output_file_names)) + "\n")
    
            if (self.generate_forward_integrated_ephemeris != 0 or writeAll):
                optionsFile.write("#Generate forward-integrated ephemeris?\n")
                optionsFile.write("generate_forward_integrated_ephemeris " + str(int(self.generate_forward_integrated_ephemeris)) + "\n")
    
            if (self.forward_integrated_ephemeris_central_body_SPICE_ID != 10 or writeAll):
                optionsFile.write("#SPICE ID of central body for forward integrated ephemeris\n")
                optionsFile.write("forward_integrated_ephemeris_central_body_SPICE_ID " + str(self.forward_integrated_ephemeris_central_body_SPICE_ID) + "\n")
    
            if (self.add_control_switch_line_to_ephemeris != 0 or writeAll):
                optionsFile.write("#Add control switch line to ephemeris?\n")
                optionsFile.write("add_control_switch_line_to_ephemeris " + str(int(self.add_control_switch_line_to_ephemeris)) + "\n")
    
            if (self.append_mass_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append mass to ephemeris output?\n")
                optionsFile.write("append_mass_to_ephemeris_output " + str(int(self.append_mass_to_ephemeris_output)) + "\n")
    
            if (self.append_control_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append control vector to ephemeris output?\n")
                optionsFile.write("append_control_to_ephemeris_output " + str(int(self.append_control_to_ephemeris_output)) + "\n")
    
            if (self.append_thrust_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append thrust magnitude to ephemeris output?\n")
                optionsFile.write("append_thrust_to_ephemeris_output " + str(int(self.append_thrust_to_ephemeris_output)) + "\n")
    
            if (self.append_mdot_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append mass flow rate to ephemeris output?\n")
                optionsFile.write("append_mdot_to_ephemeris_output " + str(int(self.append_mdot_to_ephemeris_output)) + "\n")
    
            if (self.append_Isp_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append Isp to ephemeris output?\n")
                optionsFile.write("append_Isp_to_ephemeris_output " + str(int(self.append_Isp_to_ephemeris_output)) + "\n")
    
            if (self.append_active_power_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append active power to ephemeris output?\n")
                optionsFile.write("append_active_power_to_ephemeris_output " + str(int(self.append_active_power_to_ephemeris_output)) + "\n")
    
            if (self.append_number_of_active_engines_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append number of active propulsion systems to ephemeris output?\n")
                optionsFile.write("append_number_of_active_engines_to_ephemeris_output " + str(int(self.append_number_of_active_engines_to_ephemeris_output)) + "\n")
    
            if (self.append_throttle_level_to_ephemeris_output != 0 or writeAll):
                optionsFile.write("#Append throttle level to ephemeris output?\n")
                optionsFile.write("append_throttle_level_to_ephemeris_output " + str(int(self.append_throttle_level_to_ephemeris_output)) + "\n")
    
            if (self.call_system_to_generate_bsp != 0 or writeAll):
                optionsFile.write("#Generate bsp?\n")
                optionsFile.write("call_system_to_generate_bsp " + str(int(self.call_system_to_generate_bsp)) + "\n")
    
            if (self.spice_utilities_path != "c:/utilities/cspice/exe" or writeAll):
                optionsFile.write("#Where are spice utilities?\n")
                optionsFile.write("spice_utilities_path " + str(self.spice_utilities_path) + "\n")
    
            if (self.spice_utility_extension != ".exe" or writeAll):
                optionsFile.write("#Spice utility extension\n")
                optionsFile.write("spice_utility_extension " + str(self.spice_utility_extension) + "\n")
    
            if (self.pyemtg_path != "c:/emtg/PyEMTG/" or writeAll):
                optionsFile.write("#PyEMTG path\n")
                optionsFile.write("pyemtg_path " + str(self.pyemtg_path) + "\n")
    
            if (self.spacecraft_SPICE_ID != -52284 or writeAll):
                optionsFile.write("#SPICE ID of spacecraft\n")
                optionsFile.write("spacecraft_SPICE_ID " + str(self.spacecraft_SPICE_ID) + "\n")
    
            if (self.background_mode != 0 or writeAll):
                optionsFile.write("#Close program after completion?\n")
                optionsFile.write("background_mode " + str(int(self.background_mode)) + "\n")
    
            if (self.output_STMs != 0 or writeAll):
                optionsFile.write("#Output STMs?\n")
                optionsFile.write("output_STMs " + str(int(self.output_STMs)) + "\n")
    
            if (self.output_maneuver_and_target_spec_files != 0 or writeAll):
                optionsFile.write("#Output maneuver and target spec files?\n")
                optionsFile.write("output_maneuver_and_target_spec_files " + str(int(self.output_maneuver_and_target_spec_files)) + "\n")
    
            if (self.generate_acceleration_model_instrumentation_file != 0 or writeAll):
                optionsFile.write("#generates a complete output of all acceleration model data at each integration time step (only works for numerically integrated trajectories\n")
                optionsFile.write("generate_acceleration_model_instrumentation_file " + str(int(self.generate_acceleration_model_instrumentation_file)) + "\n")
    
            if (self.stop_after_journey != 32767 or writeAll):
                optionsFile.write("#Stop after a particular journey? (if this value is greater than the number of journeys, do the whole mission)\n")
                optionsFile.write("stop_after_journey " + str(self.stop_after_journey) + "\n")
    
            if (self.run_inner_loop != 1 or writeAll):
                optionsFile.write("#which inner loop solver to run?\n#0: none, evaluate trialX\n#1: run MBH\n#2: run constrained DE\n#3: run NLP using trialX as initial guess\n#4: filament walker\n")
                optionsFile.write("run_inner_loop " + str(self.run_inner_loop) + "\n")
    
            if (self.check_derivatives != 0 or writeAll):
                optionsFile.write("#Check derivatives using NLP finite differencing?\n")
                optionsFile.write("check_derivatives " + str(int(self.check_derivatives)) + "\n")
    
            optionsFile.write("#Enter any user data that should be appended to the .emtg file.\n")
            optionsFile.write("#This is typically used in python wrappers\n")
            optionsFile.write("user_data ")
            first_entry = True
            for entry in self.user_data.keys():
                if first_entry == True:
                    first_entry = False
                else:
                    optionsFile.write(":")
                optionsFile.write('("' + entry + '",')
                if isinstance(self.user_data[entry],str):
                    optionsFile.write("'" + str(self.user_data[entry]) + "')") 
                else:
                    optionsFile.write(str(self.user_data[entry]) + ")")
            optionsFile.write("\n")
            optionsFile.write("\n")
            
            optionsFile.close()
            
            for Journey in self.Journeys:
                Journey.write(optionsFileName, writeAll)
            
    #************************************************************************************convert decision vector
    def ConvertDecisionVector(self):
        for Journey in self.Journeys:
            Journey.ConvertDecisionVector(self.ParallelShootingStateRepresentation, self.PeriapseBoundaryStateRepresentation)
        
    #************************************************************************************assemble master decision vector
    def AssembleMasterDecisionVector(self):
        self.trialX = []
        for journeyIndex in range(0, len(self.Journeys)):
            for entry in self.Journeys[journeyIndex].trialX:
                self.trialX.append(["j" + str(journeyIndex) + entry[0], entry[1]])
        
    #************************************************************************************assemble master constraint vectors
    def AssembleMasterConstraintVectors(self):
        self.ManeuverConstraintDefinitions = []
        self.BoundaryConstraintDefinitions = []
        self.PhaseDistanceConstraintDefinitions = []
        for journeyIndex in range(0, len(self.Journeys)):
            for entry in self.Journeys[journeyIndex].ManeuverConstraintDefinitions:
                if "#" in entry:
                    self.ManeuverConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\r\n").lstrip("#"))
                else:
                    self.ManeuverConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\r\n"))
            for entry in self.Journeys[journeyIndex].BoundaryConstraintDefinitions:
                if "#" in entry:
                    self.BoundaryConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\r\n").lstrip("#"))
                else:
                    self.BoundaryConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\r\n"))
            for entry in self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions:
                if "#" in entry:
                    self.PhaseDistanceConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\r\n").lstrip("#"))
                else:
                    self.PhaseDistanceConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\r\n"))
        
    #************************************************************************************disassemble master decision vector
    def DisassembleMasterDecisionVector(self):
        #clear the journey trialX vectors
        for Journey in self.Journeys:
            Journey.trialX = []
        
        for entry in self.trialX:
            journeyIndex = int(entry[0][0:entry[0].find("p")].strip("j"))
            
            if journeyIndex < len(self.Journeys):
                self.Journeys[journeyIndex].trialX.append([entry[0][entry[0].find("p"):], entry[1]])
        
    #************************************************************************************disassemble master constraint vectors
    def DisassembleMasterConstraintVectors(self):
        #clear the journey constraint vectors
        for Journey in self.Journeys:
            Journey.ManeuverConstraintDefinitions = []
            Journey.BoundaryConstraintDefinitions = []
            Journey.PhaseDistanceConstraintDefinitions = []
        
        for entry in self.ManeuverConstraintDefinitions:
            if entry.rstrip("\r\n"):
                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))
                
                commentCharacter = ""
                if "#" in entry:
                    commentCharacter = "#"
                
                if journeyIndex < len(self.Journeys):
                    self.Journeys[journeyIndex].ManeuverConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\r\n"))
            
        for entry in self.BoundaryConstraintDefinitions:
            if entry.rstrip("\r\n"):
                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))
                
                commentCharacter = ""
                if "#" in entry:
                    commentCharacter = "#"
                
                if journeyIndex < len(self.Journeys):
                    self.Journeys[journeyIndex].BoundaryConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\r\n"))
            
        for entry in self.PhaseDistanceConstraintDefinitions:
            if entry.rstrip("\r\n"):
                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))
                
                commentCharacter = ""
                if "#" in entry:
                    commentCharacter = "#"
                
                if journeyIndex < len(self.Journeys):
                    self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\r\n"))
        
        
    #************************************************************************************getJourneyIndex()
    def getJourneyIndex(self, journeyNameString):
        for journeyIndex in range(0, len(self.Journeys)):
            if self.Journeys[journeyIndex].journey_name == journeyNameString:
                return journeyIndex
        
        #if you get this far, something went wrong                                                                 
        raise Exception("Journey '" + journeyNameString + "' not found.")  
