def make_PyEMTG_MissionOptions(OptionsDefinitions, now, path = '.'):    
    with open(path + "/MissionOptions.py","w") as file:
        
        file.write('#PyEMTG MissionOptions class\n')
        file.write('#auto-generated by make_EMTG_missionoptions_journeyoptions.py\n')
        file.write('\n')
        file.write('import JourneyOptions\n')
        file.write('\n')

        file.write('class MissionOptions(object):\n')
        file.write('\n')

        file.write('    #************************************************************************************constructor\n')
        file.write('    def __init__(self, optionsFileName = None):\n')

        for option in OptionsDefinitions:
            if option['name'] == 'user_data':
                file.write('        self.' + option['name'] + ' = {} #' + option['comment'] + '\n')
            elif 'string' in option['dataType']:
                file.write('        self.' + option['name'] + ' = "' + str(option['defaultValue']) + '" #' + option['comment'] + '\n')
            else:
                file.write('        self.' + option['name'] + ' = ' + str(option['defaultValue']) + ' #' + option['comment'] + '\n')
            
        file.write('        \n')    
        file.write('        #empty master decision and constraint vectors - these exist only for interface with PyEMTG GUI and PEATSA\n')
        file.write('        self.trialX = []\n')
        file.write('        self.ManeuverConstraintDefinitions = []\n')
        file.write('        self.BoundaryConstraintDefinitions = []\n')
        file.write('        self.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        \n')
        file.write('        if optionsFileName == None:\n')
        file.write('            self.Journeys = [JourneyOptions.JourneyOptions()]\n')
        file.write('            self.number_of_journeys = 1\n')
        file.write('        else:\n')
        file.write('            self.Journeys = []\n')
        file.write('            self.parse_mission(optionsFileName)\n')
        file.write('        self.filename = ""\n')
        file.write('        self.success = 1\n')
        file.write('        self.ActiveJourney = 0\n')
        file.write('        self.AU = 1.49597870691e+8\n')
        file.write('        self.G = 6.674280000000000367e-20\n')
        file.write('        self.g0 = 9.806649999999999423\n')
        file.write('        \n')

        file.write('   \n')
        file.write('    #************************************************************************************parse\n')
        file.write('    def parse_mission(self, optionsFileName):\n')
        file.write('        self.filename = optionsFileName\n')
        file.write('        \n')
        file.write('        inputFile = []\n')
        file.write('        lineNumber = 0\n')
        file.write('        from os.path import isfile\n')
        file.write('        if isfile(self.filename):\n')
        file.write('            inputFile = open(optionsFileName, "r")\n')
        file.write('            self.success = 1\n')
        file.write('        else:\n')
        file.write('            print("Unable to open", optionsFileName, "EMTG Error")\n')
        file.write('            return\n')
        file.write('        \n')
        file.write('        while True:\n')
        file.write('            line = inputFile.readline()\n')
        file.write('            if not line:\n')
        file.write('                break\n')
        file.write('            #strip off the newline character\n')
        file.write('            line = line.rstrip("\\n\\r ")\n')
        file.write('            \n')
        file.write('            lineNumber += 1\n')
        file.write('            \n')
        file.write('            #if we got this far, then this is a line worth reading\n')
        file.write('            #Note that unlike EMTG proper, PyEMTG does NOT length or bounds-check input files. But if you try to run an invalid .emtgopt, EMTG will notify you and help you fix it.\n')
        file.write('            \n')
        file.write('            if line.strip(\'\\r\') != "":\n')
        file.write('                if line[0] != "#":\n')
        file.write('                    #this is an active line, so it is space delimited\n')
        file.write('                    linecell = [entry.rstrip(" \\r\\n") for entry in line.split(" ")]\n')
        file.write('                    \n')

        ifelse = ''
        for option in OptionsDefinitions:
            length = 1
            if 'std::vector' in option['dataType']:
                length = len(option['defaultValue'])
            converter_in = ''
            converter_out = ''

            if 'double' in option['dataType']:
                converter_in = 'float('
                converter_out = ')'
            elif 'string' not in option['dataType']:#bool, size_t, int, time_t, or any enum
                converter_in = 'int('
                converter_out = ')'
            
            
            file.write('                    ' + ifelse + 'if linecell[0] == "' + option['name'] + '":\n')
            if option['name'] == 'user_data':
                file.write('                        self.user_data = dict()                                                          \n')
                file.write('                        full_notes = line.lstrip("user_data").lstrip(" ").rstrip(" \\r\\n")                \n')
                file.write('                        if ":" in full_notes or full_notes.replace(" ","") != "":                        \n')
                file.write('                            full_notes = full_notes.split(":")                                           \n')
                file.write('                                                                                                         \n')
                file.write('                            for note in full_notes:                                                      \n')
                file.write('                                var = note.lstrip(\'("\').split(",")[0].rstrip(\'"\')                        \n')
                file.write('                                val = eval(note.lstrip("(").lstrip(var + \'"\').lstrip(", ").rstrip(") ")) \n')
                file.write('                                self.user_data.update({var:val})                                         \n')
            else:
                if length == 1:
                    file.write('                        self.' + option['name'] + ' = ' + converter_in + 'linecell[1]' + converter_out + '\n')
                else:
                    file.write('                        self.' + option['name'] + ' = [' + converter_in + 'entry' + converter_out + ' for entry in linecell[1:]]\n')
            file.write('                  \n')
            ifelse = 'el'

        
        file.write('                    elif linecell[0] == "BEGIN_JOURNEY":\n')
        file.write('                        self.Journeys.append(JourneyOptions.JourneyOptions(inputFile, lineNumber))\n')
        file.write('        \n')
        file.write('        self.number_of_journeys = len(self.Journeys)\n')
        file.write('        \n')

        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            self.Journeys[journeyIndex].universe_folder = self.universe_folder\n')
        file.write('        \n')
        file.write('        self.ConvertDecisionVector()\n')
        file.write('        self.AssembleMasterDecisionVector()\n')
        file.write('        self.AssembleMasterConstraintVectors()\n')
        file.write('        \n')

        file.write('    #************************************************************************************write\n')
        file.write('    def write_options_file(self, optionsFileName, writeAll = False):\n')
        file.write('        \n')
        file.write('        #Disassemble the master constraint and decision vectors, just in case we modified them. We want any changes to be reflected at the Journey level.\n')
        file.write('        self.DisassembleMasterDecisionVector()\n')
        file.write('        self.DisassembleMasterConstraintVectors()\n')
        file.write('        \n')
        file.write('        with open(optionsFileName, "w+") as optionsFile:\n')
        file.write('            optionsFile.write("#EMTGv9 .emtgopt file version 2\\n")\n')
        file.write('            optionsFile.write("\\n")\n')
        file.write('            \n')

        for option in OptionsDefinitions:
            name = option['name']

            if name == 'user_data':
                file.write('            optionsFile.write("#Enter any user data that should be appended to the .emtg file.\\n")\n')
                file.write('            optionsFile.write("#This is typically used in python wrappers\\n")\n')
                file.write('            optionsFile.write("user_data ")\n')
                file.write('            first_entry = True\n')
                file.write('            for entry in self.user_data.keys():\n')
                file.write('                if first_entry == True:\n')
                file.write('                    first_entry = False\n')
                file.write('                else:\n')
                file.write('                    optionsFile.write(":")\n')
                file.write('                optionsFile.write(\'("\' + entry + \'",\')\n')
                file.write('                if isinstance(self.user_data[entry],str):\n')
                file.write('                    optionsFile.write("\'" + str(self.user_data[entry]) + "\')") \n')
                file.write('                else:\n')
                file.write('                    optionsFile.write(str(self.user_data[entry]) + ")")\n')
                file.write('            optionsFile.write("\\n")\n')
                file.write('            optionsFile.write("\\n")\n')

            else:
                defaultValue = ''
                if option['dataType'] == 'std::string':
                    defaultValue = '"' + str(option['defaultValue']) + '"'
                else:
                    defaultValue = str(option['defaultValue'])

                file.write('            if (self.' + name + ' != ' + defaultValue + ' or writeAll):\n')
                file.write('                optionsFile.write("#' + option['description'] + '\\n")\n')
                if 'std::vector' in option['dataType']:
                    elementType = option['dataType'].replace('std::vector<','').replace('>','')
                    file.write('                optionsFile.write("' + name + '")\n')
                    file.write('                for entry in self.' + name + ':\n')
                    if 'bool' in option['dataType']:
                        file.write('                    optionsFile.write(" " + str(int(entry)))\n')
                    else:
                        file.write('                    optionsFile.write(" " + str(entry))\n')
                    file.write('                optionsFile.write("\\n")\n')
                else:
                    if 'bool' in option['dataType']:
                        file.write('                optionsFile.write("' + name + ' " + str(int(self.' + name + ')) + "\\n")\n')
                    else:
                        file.write('                optionsFile.write("' + name + ' " + str(self.' + name + ') + "\\n")\n')
                file.write('    \n')        
        
        file.write('            \n')
        file.write('            optionsFile.close()\n')
        file.write('            \n')
        file.write('            for Journey in self.Journeys:\n')
        file.write('                Journey.write(optionsFileName, writeAll)\n')
        file.write('            \n') 

        
        file.write('    #************************************************************************************convert decision vector\n')
        file.write('    def ConvertDecisionVector(self):\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.ConvertDecisionVector(self.ParallelShootingStateRepresentation, self.PeriapseBoundaryStateRepresentation)\n')
        file.write('        \n')
        
        
        file.write('    #************************************************************************************assemble master decision vector\n')
        file.write('    def AssembleMasterDecisionVector(self):\n')
        file.write('        self.trialX = []\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            for entry in self.Journeys[journeyIndex].trialX:\n')
        file.write('                self.trialX.append(["j" + str(journeyIndex) + entry[0], entry[1]])\n')
        file.write('        \n')

        file.write('    #************************************************************************************assemble master constraint vectors\n')
        file.write('    def AssembleMasterConstraintVectors(self):\n')
        file.write('        self.ManeuverConstraintDefinitions = []\n')
        file.write('        self.BoundaryConstraintDefinitions = []\n')
        file.write('        self.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            for entry in self.Journeys[journeyIndex].ManeuverConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.ManeuverConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.ManeuverConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('            for entry in self.Journeys[journeyIndex].BoundaryConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.BoundaryConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.BoundaryConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('            for entry in self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions:\n')
        file.write('                if "#" in entry:\n')
        file.write('                    self.PhaseDistanceConstraintDefinitions.append("#j" + str(journeyIndex) + entry.rstrip("\\r\\n").lstrip("#"))\n')
        file.write('                else:\n')
        file.write('                    self.PhaseDistanceConstraintDefinitions.append("j" + str(journeyIndex) + entry.rstrip("\\r\\n"))\n')
        file.write('        \n')
        
        file.write('    #************************************************************************************disassemble master decision vector\n')
        file.write('    def DisassembleMasterDecisionVector(self):\n')
        file.write('        #clear the journey trialX vectors\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.trialX = []\n')
        file.write('        \n')
        file.write('        for entry in self.trialX:\n')
        file.write('            journeyIndex = int(entry[0][0:entry[0].find("p")].strip("j"))\n')
        file.write('            \n')
        file.write('            if journeyIndex < len(self.Journeys):\n')
        file.write('                self.Journeys[journeyIndex].trialX.append([entry[0][entry[0].find("p"):], entry[1]])\n')
        file.write('        \n')

        file.write('    #************************************************************************************disassemble master constraint vectors\n')
        file.write('    def DisassembleMasterConstraintVectors(self):\n')
        file.write('        #clear the journey constraint vectors\n')
        file.write('        for Journey in self.Journeys:\n')
        file.write('            Journey.ManeuverConstraintDefinitions = []\n')
        file.write('            Journey.BoundaryConstraintDefinitions = []\n')
        file.write('            Journey.PhaseDistanceConstraintDefinitions = []\n')
        file.write('        \n')
        file.write('        for entry in self.ManeuverConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].ManeuverConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('            \n')
        file.write('        for entry in self.BoundaryConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].BoundaryConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('            \n')
        file.write('        for entry in self.PhaseDistanceConstraintDefinitions:\n')
        file.write('            if entry.rstrip("\\r\\n"):\n')
        file.write('                journeyIndex = int(entry[0:entry.find("p")].strip("#j"))\n')
        file.write('                \n')
        file.write('                commentCharacter = ""\n')
        file.write('                if "#" in entry:\n')
        file.write('                    commentCharacter = "#"\n')
        file.write('                \n')
        file.write('                if journeyIndex < len(self.Journeys):\n')
        file.write('                    self.Journeys[journeyIndex].PhaseDistanceConstraintDefinitions.append(commentCharacter + entry[entry.find("p"):].rstrip("\\r\\n"))\n')
        file.write('        \n')
        file.write('        \n')
        file.write('    #************************************************************************************getJourneyIndex()\n')
        file.write('    def getJourneyIndex(self, journeyNameString):\n')
        file.write('        for journeyIndex in range(0, len(self.Journeys)):\n')
        file.write('            if self.Journeys[journeyIndex].journey_name == journeyNameString:\n')
        file.write('                return journeyIndex\n')
        file.write('        \n')
        file.write('        #if you get this far, something went wrong                                                                 \n')
        file.write('        raise Exception("Journey \'" + journeyNameString + "\' not found.")  \n')
