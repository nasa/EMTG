def make_journeyoptions_source(OptionsDefinitions, now, path = '.'):
    with open(path + "/journeyoptions.cpp","w") as file:

        file.write('//journeyoptions class\n')
        file.write('//auto-generated by make_EMTG_missionoptions_journeyoptions.py\n')
        file.write('\n')
        file.write('#include "journeyoptions.h"\n')
        file.write('#include "file_utilities.h"\n')
        file.write('#include "EMTG_math.h"\n')
        file.write('\n')
        file.write('#include <boost/algorithm/string.hpp>\n')
        file.write('\n')
        file.write('#include <iostream>\n')
        file.write('#include <fstream>\n')
        file.write('#include <sstream>\n')
        file.write('#include <exception>\n')
        file.write('\n')
        file.write('namespace EMTG\n')
        file.write('{\n')

        file.write('    //constructor - just initializes everything\n')
        file.write('    JourneyOptions::JourneyOptions()\n')
        file.write('    {\n')

        file.write('        //values\n')
        for option in OptionsDefinitions:                
            name = option['name']                          
            dataType = option['dataType']
            scale = ''
            if 'scale' in option:
                if option['scale'] != None:
                    scale = ' * ' + str(option['scale']) + '.0'

            if 'std::vector' in option['dataType']:
                if (len(eval(option['defaultValue'])) > 0):#sometimes an vector option has no default value, which means that it defaults to empty
                    elementType = dataType.replace('std::vector<','').replace('>','')
                    file.write('        this->' + option['name'] + ' = ' + dataType + "({ ")
                    file.write(str(eval(option['defaultValue'])[0]) + scale)
                    for entry in eval(option['defaultValue'])[1:]:
                        file.write(', ' + str(entry) + scale)
                    file.write('}); \n')
            else:                              
                if dataType == 'std::string':
                    file.write('        this->' + name + ' = "' + str(option['defaultValue']).strip('"') + '";\n')
                elif dataType in ['double', 'int', 'size_t']:
                    file.write('        this->' + name + ' = ' + str(option['defaultValue']) + scale + ';\n')
                else:
                    file.write('        this->' + name + ' = (' + dataType + ') ' + str(option['defaultValue']) + ';\n')
                
        file.write('        \n')
        file.write('        this->number_of_phases = this->sequence.size() + 1;\n')
        file.write('        this->maximum_mass = 1000.0;\n')
        file.write('        \n')
        file.write('        //bounds\n')
        for option in OptionsDefinitions:
            scale = ''
            if 'scale' in option:
                if option['scale'] != None:
                    scale = ' * ' + str(option['scale']) + '.0'
            if 'std::vector' in option['dataType']:
                elementType = option['dataType'].replace('std::vector<','').replace('>','')
                dataType = option['dataType']                         
                name = option['name']

                bigThing = ''
                if 'double' in dataType:
                    bigThing = 'math::LARGE'
                elif 'int' in dataType:
                    bigThing = 'INT_MAX'
                elif 'size_t' in dataType:
                    bigThing = 'SIZE_MAX'

                if 'std::string' not in option['dataType'] and 'bool' not in option['dataType']:
                    if '[' in str(option['upperBound']) and ']' in str(option['upperBound']):#is this a string containing a list - we need vector bounds
                        lowerBoundVec = option['lowerBound'].replace('[','').replace(']','')
                        lowerBoundCell = lowerBoundVec.split(',')
                        upperBoundVec = option['upperBound'].replace('[','').replace(']','')
                        upperBoundCell = upperBoundVec.split(',')

                        file.write('        this->' + name + '_lowerBound = ' + dataType + "({ ")
                        lowerBound = str(lowerBoundCell[0]).replace('inf', bigThing)
                        file.write(lowerBound + scale)
                        for entry in lowerBoundCell[1:]:
                            lowerBound = str(entry).replace('inf', bigThing)
                            file.write(', ' + lowerBound + scale)
                        file.write('}); \n')

                        file.write('        this->' + name + '_upperBound = ' + dataType + "({ ")
                        upperBound = str(upperBoundCell[0]).replace('inf', bigThing)
                        file.write(upperBound + scale)
                        for entry in upperBoundCell[1:]:
                            upperBound = str(entry).replace('inf', bigThing)
                            file.write(', ' + upperBound + scale)
                        file.write('}); \n')

                    else:#scalar bounds for this vector option
                        lowerBound = str(option['lowerBound']).replace('inf', bigThing)
                        upperBound = str(option['upperBound']).replace('inf', bigThing)
                        if elementType in ['double', 'int', 'size_t']:
                            file.write('        this->' + option['name'] + '_lowerBound = ' + lowerBound + scale + ';\n')
                            file.write('        this->' + option['name'] + '_upperBound = ' + upperBound + scale + ';\n')
                        else: #need to typecast
                            file.write('        this->' + option['name'] + '_lowerBound = (' + elementType + ') ' + lowerBound + scale + ';\n')
                            file.write('        this->' + option['name'] + '_upperBound = (' + elementType + ') ' + upperBound + scale + ';\n')
            else:#scalar option                                   
                name = option['name']                          
                dataType = option['dataType']

                bigThing = ''
                if 'double' in dataType:
                    bigThing = 'math::LARGE'
                elif 'int' in dataType:
                    bigThing = 'INT_MAX'
                elif 'size_t' in dataType:
                    bigThing = 'SIZE_MAX'

                if dataType in ['double', 'int', 'size_t']:
                    lowerBound = str(option['lowerBound']).replace('inf', bigThing)
                    upperBound = str(option['upperBound']).replace('inf', bigThing)
                    file.write('        this->' + name + '_lowerBound = ' + lowerBound + scale + ';\n')
                    file.write('        this->' + name + '_upperBound = ' + upperBound + scale + ';\n')
                elif 'std::string' not in dataType and 'bool' not in dataType:
                    file.write('        this->' + name + '_lowerBound = (' + dataType + ') ' + str(option['lowerBound']) + scale + ';\n')
                    file.write('        this->' + name + '_upperBound = (' + dataType + ') ' + str(option['upperBound']) + scale + ';\n')
        file.write('    }//end constructor\n')
        file.write('    \n')

        file.write('    JourneyOptions::JourneyOptions(std::string optionsfilename) : JourneyOptions()\n')
        file.write('    {\n')
        file.write('        size_t lineNumber = 0;\n')
        file.write('        std::ifstream optionsFileStream;\n')
        file.write('        optionsFileStream.open(optionsfilename);\n')
        file.write('        \n')
        file.write('        if (!optionsFileStream.is_open())\n')
        file.write('        {\n')
        file.write('            throw std::invalid_argument("Cannot find options file: " + optionsfilename);\n')
        file.write('        }\n')
        file.write('        \n')
        file.write('        this->parse_journey(optionsFileStream, lineNumber);\n')
        file.write('    }//end constructor with input filename\n')
        file.write('    \n')

        file.write('    JourneyOptions::JourneyOptions(std::ifstream& optionsFileStream, size_t& lineNumber) : JourneyOptions()\n')
        file.write('    {\n')
        file.write('        this->parse_journey(optionsFileStream, lineNumber);\n')
        file.write('    }//end constructor with input filestream\n')
        file.write('    \n')

        file.write('    //parsers\n')
        file.write('    void JourneyOptions::parse_journey(std::ifstream& optionsFileStream, size_t& lineNumber)\n')
        file.write('    {\n')
        file.write('        std::string line;\n')
        file.write('        \n')
        file.write('        while (EMTG::file_utilities::safeGetline(optionsFileStream, line))\n')
        file.write('        {\n')
        file.write('            if (line.size() > 0) //skip blank lines\n')
        file.write('            {\n')
        file.write('                if (line.front() == *"#") //skip comment lines\n')
        file.write('                {\n')
        file.write('                    ++lineNumber;\n')
        file.write('                }\n')
        file.write('                else if (line == "BEGIN_JOURNEY")\n')
        file.write('                {\n')
        file.write('                    ++lineNumber;\n')
        file.write('                }\n')
        file.write('                else if (line == "END_JOURNEY")\n')
        file.write('                {\n')
        file.write('                    this->number_of_phases = this->sequence.size() + 1;\n')
        file.write('                    \n')
        file.write('                    ++lineNumber;\n')
        file.write('                    return;\n')
        file.write('                }\n')
        file.write('                else\n')
        file.write('                {\n')
        file.write('                    this->parse_line(line, lineNumber, optionsFileStream);\n')
        file.write('                }\n')
        file.write('            }\n')
        file.write('        }\n')
        file.write('    }//end parse_journey()\n')
        file.write('    \n')

        file.write('   void JourneyOptions::parse_line(const std::string& line, size_t& lineNumber, std::ifstream& optionsFileStream)\n')
        file.write('   {\n')
        file.write('       ++lineNumber;\n')
        file.write('       \n')
        file.write('       std::vector<std::string> linecell;\n')
        file.write('       boost::split(linecell, line, boost::is_any_of(" "), boost::token_compress_on);\n')
        file.write('       \n')

        for option in OptionsDefinitions:
            name = option['name']
            scale = ''
            if 'scale' in option:
                if option['scale'] != None:
                    scale = ' * ' + str(option['scale']) + '.0'

            file.write('        if (linecell[0] == "' + name + '")\n')
            file.write('        {\n')
            #bounds check and assignment
            if 'std::vector' in option['dataType']:
                #length check
                length = str(option['length'])
                if length != 'inf':
                    file.write('            if (linecell.size() - 1 != ' + length + ')\n')
                    file.write('            {\n')
                    file.write('                throw std::invalid_argument("Input option ' + name + ' has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires ' + length + ' arguments.");\n')
                    file.write('            }\n')
                    file.write('            \n')
                #assign
                dataType = option['dataType']
                elementType = option['dataType'].replace('std::vector<','').replace('>','')
                file.write('            this->' + name + '.clear();\n')
                file.write('            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)\n')
                file.write('            {\n')
                file.write('                this->' + name + '.push_back(')
                if elementType == 'std::string':
                    file.write('linecell[entryIndex + 1]')
                else:
                    if elementType in ['int','size_t']:
                        file.write('std::stoi(linecell[entryIndex + 1])' + scale)
                    elif elementType == 'double':
                        file.write('std::stod(linecell[entryIndex + 1])' + scale)
                    elif elementType == 'bool':
                        file.write('(bool) std::stoi(linecell[entryIndex + 1])')
                    else:
                        print('unknown datatype for option ' + name + '(' + dataType + ')')
                        stop
                file.write(');\n')
                file.write('            }\n')
                
                #bounds check       
                if 'std::string' not in dataType and 'bool' not in dataType: 
                    file.write('            \n')
                    file.write('            //bounds check\n')
                    boundsislist = '[' in str(option['upperBound']) and ']' in str(option['upperBound'])#is this a string containing a list
                    if length != 'inf' and boundsislist:
                            file.write('            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)\n')
                            file.write('            {\n')
                            file.write('               if (this->' + name + '[entryIndex] < this->' + name + '_lowerBound[entryIndex] || this->' + name + '[entryIndex] > this->' + name + '_upperBound[entryIndex])\n')
                            file.write('               {\n')
                            file.write('                   throw std::out_of_range("Input option ' + name + '[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->' + name + '[entryIndex]) + ", bounds are [" + std::to_string(this->' + name + '_lowerBound[entryIndex]) + ", " + std::to_string(this->' + name + '_upperBound[entryIndex]) + "].");\n')
                            file.write('               }\n')
                            file.write('            }\n')
                    else: #an array of unknown length
                            file.write('            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)\n')
                            file.write('            {\n')
                            file.write('               if (this->' + name + '[entryIndex] < this->' + name + '_lowerBound || this->' + name + '[entryIndex] > this->' + name + '_upperBound)\n')
                            file.write('               {\n')
                            file.write('                   throw std::out_of_range("Input option ' + name + '[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->' + name + '[entryIndex]) + ", bounds are [" + std::to_string(this->' + name + '_lowerBound) + ", " + std::to_string(this->' + name + '_upperBound) + "].");\n')
                            file.write('               }\n')
                            file.write('            }\n')

            else: #any scalar type
                dataType = option['dataType']
                file.write('            this->' + name + ' = ')
                if dataType == 'std::string':
                    file.write('linecell[1];\n')
                else:
                    if dataType in ['int','size_t']:
                        file.write('std::stoi(linecell[1])' + scale + ';\n')
                    elif dataType == 'double':
                        file.write('std::stod(linecell[1])' + scale + ';\n')
                    else: #this is an enum, so we will need to typecast it
                        file.write('(' + option['dataType'] + ') std::stoi(linecell[1]);\n')
                    #bounds check
                    if 'bool' not in dataType:
                        file.write('            \n')
                        file.write('            //bounds check\n')
                        file.write('            if (this->' + name + ' < this->' + name + '_lowerBound || this->' + name + ' > this->' + name + '_upperBound)\n')
                        file.write('            {\n')
                        file.write('                throw std::out_of_range("Input option ' + name + ' is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->' + name + ') + ", bounds are [" + std::to_string(this->' + name + '_lowerBound) + ", " + std::to_string(this->' + name + '_upperBound) + "].");\n')
                        file.write('            }\n')
            file.write('            return;\n')
            file.write('        }\n')
            
        file.write('        \n')
        file.write('        //specialized maneuver constraints(epoch and magnitude)\n')
        file.write('        if (linecell[0] == "BEGIN_MANEUVER_CONSTRAINT_BLOCK")\n')
        file.write('        {\n')
        file.write('            std::string line;\n')
        file.write('            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))\n')
        file.write('            {\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\r\'), line.end() );\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\n\'), line.end() );\n')
        file.write('                if (line.size() > 0)\n')
        file.write('                {\n')
        file.write('                    if (line == "END_MANEUVER_CONSTRAINT_BLOCK")\n')
        file.write('                        return;\n')
        file.write('                    else\n')
        file.write('                        this->ManeuverConstraintDefinitions.push_back(line);\n')
        file.write('\n')
        file.write('                }\n')
        file.write('            }\n')
        file.write('        }\n')
        file.write('\n')
        file.write('        //specialized boundary constraints\n')
        file.write('        if (linecell[0] == "BEGIN_BOUNDARY_CONSTRAINT_BLOCK")\n')
        file.write('        {\n')
        file.write('            std::string line;\n')
        file.write('            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))\n')
        file.write('            {\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\r\'), line.end() );\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\n\'), line.end() );\n')
        file.write('                if (line.size() > 0)\n')
        file.write('                {\n')
        file.write('                    if (line == "END_BOUNDARY_CONSTRAINT_BLOCK")\n')
        file.write('                        return;\n')
        file.write('                    else\n')
        file.write('                        this->BoundaryConstraintDefinitions.push_back(line);\n')
        file.write('\n')
        file.write('                }\n')
        file.write('            }\n')
        file.write('        }\n')
        file.write('\n')
        file.write('        //phase distance constraints\n')
        file.write('        if (linecell[0] == "BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK")\n')
        file.write('        {\n')
        file.write('            std::string line;\n')
        file.write('            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))\n')
        file.write('            {\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\r\'), line.end() );\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\n\'), line.end() );\n')
        file.write('                if (line.size() > 0)\n')
        file.write('                {\n')
        file.write('                    if (line == "END_PHASE_DISTANCE_CONSTRAINT_BLOCK")\n')
        file.write('                        return;\n')
        file.write('                    else\n')
        file.write('                        this->PhaseDistanceConstraintDefinitions.push_back(line);\n')
        file.write('\n')
        file.write('                }\n')
        file.write('            }\n')
        file.write('        }\n')
        file.write('\n')
        file.write('        //decision vector guess\n')
        file.write('        if (linecell[0] == "BEGIN_TRIALX")\n')
        file.write('        {\n')
        file.write('            std::string line;\n')
        file.write('            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))\n')
        file.write('            {\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\r\'), line.end() );\n')
        file.write('                line.erase( std::remove(line.begin(), line.end(), \'\\n\'), line.end() );\n')
        file.write('                if (line.size() > 0)\n')
        file.write('                {\n')
        file.write('                    if (line == "END_TRIALX")\n')
        file.write('                        return;\n')
        file.write('                    else\n')
        file.write('                    {\n')
        file.write('                        std::vector<std::string> linecell;\n')
        file.write('                        boost::split(linecell, line, boost::is_any_of(","), boost::algorithm::token_compress_on);\n')
        file.write('                        boost::trim(linecell[0]);\n')
        file.write('                        this->trialX.push_back({ linecell[0], std::stod(linecell[1]) });\n')
        file.write('                    }\n')
        file.write('\n')
        file.write('                }\n')
        file.write('            }\n')
        file.write('\n')
        file.write('            return;\n')
        file.write('        }\n')
        file.write('        \n')
        file.write('        //If we got this far, then the option was not recognized\n')
        file.write('        std::cout << "Option " << linecell[0] << " on line " << lineNumber << " is not recognized. Moving on with life..." << std::endl;\n')
        file.write('    }//end parse_line()\n')
        file.write('    \n')

        file.write('    void JourneyOptions::write(const std::string& optionsFileName, const bool& newFile, const bool& writeAll)\n')
        file.write('    {\n')
        file.write('        std::ofstream optionsFileStream;\n')
        file.write('        if (newFile)\n')
        file.write('            optionsFileStream = std::ofstream(optionsFileName, std::ios::trunc);\n')
        file.write('        else\n')
        file.write('            optionsFileStream = std::ofstream(optionsFileName, std::ios::app);\n')
        file.write('        optionsFileStream.precision(20);\n')
        file.write('        \n')
        file.write('        optionsFileStream << "BEGIN_JOURNEY" << std::endl;\n')
        file.write('        \n')

        for option in OptionsDefinitions:
            name = option['name']
            dataType = option['dataType']
            scale = ''
            defaultValue = ''
            if 'scale' in option:
                if option['scale'] != None:
                    scale = ' / ' + str(option['scale']) + '.0'

            if 'std::vector' in option['dataType']:
                if (len(eval(option['defaultValue'])) > 0):#sometimes an vector option has no default value, which means that it defaults to empty
                    elementType = dataType.replace('std::vector<','').replace('>','')
                    defaultValue = dataType + "({ "
                    defaultValue += str(eval(option['defaultValue'])[0]) + scale.replace('/','*')
                    for entry in eval(option['defaultValue'])[1:]:
                        defaultValue += ', ' + str(entry) + scale.replace('/','*')
                    defaultValue += '})'
                                        
                    file.write('        if (this->' + name + ' != ' + defaultValue + ' || writeAll || this->print_this_journey_options_no_matter_what)\n')
                    file.write('        {\n')
                    file.write('            optionsFileStream << "#' + option['description'] + '" << std::endl;\n')
                    elementType = option['dataType'].replace('std::vector<','').replace('>','')
                    file.write('            optionsFileStream << "' + name +'";\n')
                    file.write('            for (' + elementType + ' entry : this->' + name + ')\n')
                    file.write('                optionsFileStream << " " << entry' + scale + ';\n')
                    file.write('            optionsFileStream << std::endl;\n')
                    file.write('        }\n')
                    file.write('        \n')
                else:
                    file.write('        optionsFileStream << "#' + option['description'] + '" << std::endl;\n')
                    elementType = option['dataType'].replace('std::vector<','').replace('>','')
                    file.write('        optionsFileStream << "' + name +'";\n')
                    file.write('        for (' + elementType + ' entry : this->' + name + ')\n')
                    file.write('            optionsFileStream << " " << entry' + scale + ';\n')
                    file.write('        optionsFileStream << std::endl;\n')
                    file.write('        \n')
            else:                                              
                if dataType == 'std::string':
                    defaultValue = '"' + str(option['defaultValue']).strip('"') + '"'
                elif dataType in ['double', 'int', 'size_t']:
                    defaultValue = str(option['defaultValue']) + scale.replace('/','*')
                else:
                    defaultValue = str(option['defaultValue'])

                file.write('        if (this->' + name + ' != ' + defaultValue + ' || writeAll || this->print_this_journey_options_no_matter_what)\n')
                file.write('        {\n')
                file.write('            optionsFileStream << "#' + option['description'] + '" << std::endl;\n')
                file.write('            optionsFileStream << "' + name + ' " << this->' + name + scale + ' << std::endl;\n')
                file.write('        }\n')
                file.write('    \n')
    
        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << "#Maneuver constraint code" << std::endl;\n')
        file.write('        optionsFileStream << "#Works for absolute and relative epochs and also magnitudes" << std::endl;\n')
        file.write('        optionsFileStream << "BEGIN_MANEUVER_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        for (std::string& entry : this->ManeuverConstraintDefinitions)\n')
        file.write('        {\n')
        file.write('            optionsFileStream << entry << std::endl;\n')
        file.write('        }\n')
        file.write('        optionsFileStream << "END_MANEUVER_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('            \n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << "#Boundary constraint code" << std::endl;\n')
        file.write('        optionsFileStream << "BEGIN_BOUNDARY_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        for (std::string& entry : this->BoundaryConstraintDefinitions)\n')
        file.write('        {\n')
        file.write('            optionsFileStream << entry << std::endl;\n')
        file.write('        }\n')
        file.write('        optionsFileStream << "END_BOUNDARY_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << "#Phase distance constraint code" << std::endl;\n')
        file.write('        optionsFileStream << "BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        for (std::string& entry : this->PhaseDistanceConstraintDefinitions)\n')
        file.write('        {\n')
        file.write('            optionsFileStream << entry << std::endl;\n')
        file.write('        }\n')
        file.write('        optionsFileStream << "END_PHASE_DISTANCE_CONSTRAINT_BLOCK" << std::endl;\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << "#trial decision vector" << std::endl;\n')
        file.write('        optionsFileStream << "BEGIN_TRIALX" << std::endl;\n')
        file.write('        optionsFileStream.precision(20);\n')
        file.write('        for (std::tuple<std::string, double> entry : this->trialX)\n')
        file.write('            optionsFileStream << std::get<0>(entry) << " ," << std::get<1>(entry) << std::endl;\n')
        file.write('        optionsFileStream << "END_TRIALX" << std::endl;\n')

        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << "END_JOURNEY";\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('        optionsFileStream << std::endl;\n')
        file.write('    }//end write()\n')
        file.write('    \n')

        file.write('}//close namespace EMTG\n')