//journeyoptions class
//auto-generated by make_EMTG_missionoptions_journeyoptions.py

#include "journeyoptions.h"
#include "file_utilities.h"
#include "EMTG_math.h"

#include <boost/algorithm/string.hpp>

#include <iostream>
#include <fstream>
#include <sstream>
#include <exception>

namespace EMTG
{
    //constructor - just initializes everything
    JourneyOptions::JourneyOptions()
    {
        //values
        this->journey_name = "default";
        this->journey_central_body = "Sun";
        this->destination_list = std::vector<int>({ 3, 4}); 
        this->phase_type = (PhaseType) 2;
        this->impulses_per_phase = 1;
        this->thrust_control_law = (ThrustControlLaw) 1;
        this->force_unit_magnitude_control = (ControlMagnitudeType) 0;
        this->force_fixed_inertial_control = (bool) 0;
        this->override_num_steps = (bool) 0;
        this->number_of_steps = 20;
        this->override_duty_cycle = (bool) 0;
        this->duty_cycle = 1;
        this->override_PropagatorType = (bool) 0;
        this->propagatorType = (PropagatorType) 1;
        this->override_integration_step_size = (bool) 0;
        this->integration_step_size = 86400;
        this->override_flyby_altitude_bounds = (bool) 0;
        this->flyby_altitude_bounds = std::vector<double>({ 300.0, 1000000.0}); 
        this->PeriapseArrival_override_altitude = (bool) 1;
        this->PeriapseArrival_altitude_bounds = std::vector<double>({ 300.0, 1000000.0}); 
        this->PeriapseDeparture_altitude_bounds = std::vector<double>({ 185.0, 185.0}); 
        this->num_interior_control_points = 1;
        this->CoastPhaseMatchPointFraction = 0.5;
        this->CoastPhaseForwardIntegrationStepLength = 86400;
        this->CoastPhaseBackwardIntegrationStepLength = 86400;
        this->journey_end_TCM = 0;
        this->enable_periapse_burns = (bool) 0;
        this->bounded_departure_date = (bool) 0;
        this->timebounded = 0;
        this->departure_date_bounds = std::vector<double>({ 0.0 * 86400.0, 0.0 * 86400.0}); 
        this->wait_time_bounds = std::vector<double>({ 0.0 * 86400.0, 1000.0 * 86400.0}); 
        this->flight_time_bounds = std::vector<double>({ 0.0 * 86400.0, 0.0 * 86400.0}); 
        this->arrival_date_bounds = std::vector<double>({ 51544.5 * 86400.0, 60000.0 * 86400.0}); 
        this->departure_type = (DepartureType) 0;
        this->initial_impulse_bounds = std::vector<double>({ 0.0, 6.97}); 
        this->force_free_point_direct_insertion_along_velocity_vector = (bool) 0;
        this->departure_elements_vary_flag = std::vector<bool>({ 0, 0, 0, 0, 0, 0}); 
        this->departure_elements = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->departure_elements_bounds = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->departure_elements_reference_epoch = 51544.5 * 86400.0;
        this->departure_elements_state_representation = (StateRepresentation) 0;
        this->departure_elements_frame = (ReferenceFrame) 0;
        this->AllowJourneyFreePointDepartureToPropagate = (bool) 0;
        this->maximum_starting_mass_increment = 0;
        this->minimum_starting_mass_increment = 0;
        this->fixed_starting_mass_increment = 0;
        this->fixed_ending_mass_increment = 0;
        this->variable_mass_increment = (bool) 0;
        this->constrain_initial_mass = (bool) 0;
        this->maximum_initial_mass = 0;
        this->departure_class = (BoundaryClass) 0;
        this->departure_ellipsoid_axes = std::vector<double>({ 1e-08, 1e-08, 1e-08}); 
        this->arrival_type = (ArrivalType) 3;
        this->arrival_elements_vary_flag = std::vector<bool>({ 0, 0, 0, 0, 0, 0}); 
        this->arrival_elements = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->arrival_elements_bounds = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->arrival_elements_reference_epoch = 51544.5 * 86400.0;
        this->arrival_elements_state_representation = (StateRepresentation) 0;
        this->arrival_elements_frame = (ReferenceFrame) 0;
        this->AllowJourneyFreePointArrivalToPropagate = (bool) 0;
        this->final_velocity = std::vector<double>({ 0.0, 20.0, 0.0}); 
        this->forced_terminal_coast = 0 * 86400.0;
        this->forced_initial_coast = 0 * 86400.0;
        this->arrival_class = (BoundaryClass) 0;
        this->arrival_ellipsoid_axes = std::vector<double>({ 1e-08, 1e-08, 1e-08}); 
        this->zero_turn_flyby_distance = 1000;
        this->terminal_intercept_flyby_distance = 1000;
        this->escape_spiral_starting_radius = 6678;
        this->escape_spiral_final_radius = 6678;
        this->capture_spiral_final_radius = 6678;
        this->capture_spiral_starting_radius = 6678;
        this->FreePointArrival_print_target_spec = (bool) 1;
        this->journey_end_deltav = 0;
        this->journey_end_propulsion_system = (PropulsionSystemChoice) 0;
        this->stage_after_departure = (bool) 0;
        this->stage_before_arrival = (bool) 0;
        this->stage_after_arrival = (bool) 0;
        this->freeze_decision_variables = (bool) 0;
        this->ephemeris_pegged_orbit_insertion_SMA = 6678;
        this->ephemeris_pegged_orbit_insertion_ECC = 0;
        this->impact_momentum_enhancement_factor = 1;
        this->perturb_drag = (bool) 0;
        this->spacecraft_drag_area = 70;
        this->coefficient_of_drag = 2.2;
        this->AtmosphericDensityModelKey = "Exponential";
        this->AtmosphericDensityModelDataFile = "DoesNotExist.emtg_densityopt";
        this->probe_separation_impulse = 1;
        this->probe_mass = 100.0;
        this->Probe_AEI_elements_vary_flag = std::vector<bool>({ 0, 0, 0, 0, 0, 0}); 
        this->Probe_AEI_elements = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->Probe_AEI_elements_bounds = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->Probe_AEI_elements_reference_epoch = 51544.5 * 86400.0;
        this->Probe_AEI_elements_state_representation = (StateRepresentation) 0;
        this->Probe_AEI_elements_frame = (ReferenceFrame) 0;
        this->Probe_End_elements_vary_flag = std::vector<bool>({ 0, 0, 0, 0, 0, 0}); 
        this->Probe_End_elements = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->Probe_End_elements_bounds = std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}); 
        this->Probe_End_elements_reference_epoch = 51544.5 * 86400.0;
        this->Probe_End_elements_state_representation = (StateRepresentation) 0;
        this->Probe_End_elements_frame = (ReferenceFrame) 0;
        this->ModelProbeSecondPhase = (bool) 0;
        this->AllowJourneyProbeAEIToPropagate = (bool) 0;
        this->AllowJourneyProbeEndToPropagate = (bool) 0;
        this->probe_communication_distance_bounds = std::vector<double>({ 2000.0, 10000.0}); 
        this->perturb_drag_probe_separation_to_AEI = (bool) 0;
        this->perturb_drag_probe_AEI_to_end = (bool) 0;
        this->probe_drag_area_probe_separation_to_AEI = 70;
        this->probe_drag_area_probe_AEI_to_end = 70;
        this->probe_coefficient_of_drag_probe_separation_to_AEI = 2.2;
        this->probe_coefficient_of_drag_probe_AEI_to_end = 2.2;
        this->probe_AEI_velocity = std::vector<double>({ 0.0, 20.0, 0.0}); 
        this->probe_end_velocity = std::vector<double>({ 0.0, 20.0, 0.0}); 
        this->ProbeSeparationToAEI_MatchPointFraction = 0.5;
        this->ProbeSeparationToAEI_ForwardIntegrationStepLength = 86400;
        this->ProbeSeparationToAEI_BackwardIntegrationStepLength = 86400;
        this->ProbeAEI_to_end_MatchPointFraction = 0.5;
        this->ProbeAEI_to_end_ForwardIntegrationStepLength = 86400;
        this->ProbeAEI_to_end_BackwardIntegrationStepLength = 86400;
        this->print_this_journey_options_no_matter_what = (bool) 0;
        
        this->number_of_phases = this->sequence.size() + 1;
        this->maximum_mass = 1000.0;
        
        //bounds
        this->destination_list_lowerBound = std::vector<int>({ -1,  -1}); 
        this->destination_list_upperBound = std::vector<int>({ INT_MAX,  INT_MAX}); 
        this->sequence_lowerBound = 1;
        this->sequence_upperBound = INT_MAX;
        this->phase_type_lowerBound = (PhaseType) 0;
        this->phase_type_upperBound = (PhaseType) 11;
        this->impulses_per_phase_lowerBound = 0;
        this->impulses_per_phase_upperBound = SIZE_MAX;
        this->thrust_control_law_lowerBound = (ThrustControlLaw) 1;
        this->thrust_control_law_upperBound = (ThrustControlLaw) 2;
        this->force_unit_magnitude_control_lowerBound = (ControlMagnitudeType) 0;
        this->force_unit_magnitude_control_upperBound = (ControlMagnitudeType) 2;
        this->number_of_steps_lowerBound = 1;
        this->number_of_steps_upperBound = SIZE_MAX;
        this->duty_cycle_lowerBound = 0;
        this->duty_cycle_upperBound = 1;
        this->propagatorType_lowerBound = (PropagatorType) 0;
        this->propagatorType_upperBound = (PropagatorType) 1;
        this->integration_step_size_lowerBound = 0;
        this->integration_step_size_upperBound = 1000000;
        this->flyby_altitude_bounds_lowerBound = std::vector<double>({ 0.0,  1.0}); 
        this->flyby_altitude_bounds_upperBound = std::vector<double>({ math::LARGE,  math::LARGE}); 
        this->PeriapseArrival_altitude_bounds_lowerBound = std::vector<double>({ 0.0,  1.0}); 
        this->PeriapseArrival_altitude_bounds_upperBound = std::vector<double>({ math::LARGE,  math::LARGE}); 
        this->PeriapseDeparture_altitude_bounds_lowerBound = std::vector<double>({ 0.0,  1.0}); 
        this->PeriapseDeparture_altitude_bounds_upperBound = std::vector<double>({ math::LARGE,  math::LARGE}); 
        this->num_interior_control_points_lowerBound = 1;
        this->num_interior_control_points_upperBound = SIZE_MAX;
        this->CoastPhaseMatchPointFraction_lowerBound = 0;
        this->CoastPhaseMatchPointFraction_upperBound = 1;
        this->CoastPhaseForwardIntegrationStepLength_lowerBound = 0;
        this->CoastPhaseForwardIntegrationStepLength_upperBound = 1000000;
        this->CoastPhaseBackwardIntegrationStepLength_lowerBound = 0;
        this->CoastPhaseBackwardIntegrationStepLength_upperBound = 1000000;
        this->journey_end_TCM_lowerBound = 0;
        this->journey_end_TCM_upperBound = math::LARGE;
        this->timebounded_lowerBound = 0;
        this->timebounded_upperBound = 3;
        this->departure_date_bounds_lowerBound = 0 * 86400.0;
        this->departure_date_bounds_upperBound = math::LARGE * 86400.0;
        this->wait_time_bounds_lowerBound = -math::LARGE * 86400.0;
        this->wait_time_bounds_upperBound = math::LARGE * 86400.0;
        this->flight_time_bounds_lowerBound = 0 * 86400.0;
        this->flight_time_bounds_upperBound = math::LARGE * 86400.0;
        this->arrival_date_bounds_lowerBound = 0 * 86400.0;
        this->arrival_date_bounds_upperBound = math::LARGE * 86400.0;
        this->departure_type_lowerBound = (DepartureType) 0;
        this->departure_type_upperBound = (DepartureType) 6;
        this->initial_impulse_bounds_lowerBound = 0;
        this->initial_impulse_bounds_upperBound = math::LARGE;
        this->departure_elements_lowerBound = -math::LARGE;
        this->departure_elements_upperBound = math::LARGE;
        this->departure_elements_bounds_lowerBound = -math::LARGE;
        this->departure_elements_bounds_upperBound = math::LARGE;
        this->departure_elements_reference_epoch_lowerBound = 0 * 86400.0;
        this->departure_elements_reference_epoch_upperBound = math::LARGE * 86400.0;
        this->departure_elements_state_representation_lowerBound = (StateRepresentation) 0;
        this->departure_elements_state_representation_upperBound = (StateRepresentation) 6;
        this->departure_elements_frame_lowerBound = (ReferenceFrame) 0;
        this->departure_elements_frame_upperBound = (ReferenceFrame) 9;
        this->maximum_starting_mass_increment_lowerBound = -math::LARGE;
        this->maximum_starting_mass_increment_upperBound = math::LARGE;
        this->minimum_starting_mass_increment_lowerBound = -math::LARGE;
        this->minimum_starting_mass_increment_upperBound = math::LARGE;
        this->fixed_starting_mass_increment_lowerBound = -math::LARGE;
        this->fixed_starting_mass_increment_upperBound = math::LARGE;
        this->fixed_ending_mass_increment_lowerBound = -math::LARGE;
        this->fixed_ending_mass_increment_upperBound = math::LARGE;
        this->maximum_initial_mass_lowerBound = 0;
        this->maximum_initial_mass_upperBound = math::LARGE;
        this->departure_class_lowerBound = (BoundaryClass) 0;
        this->departure_class_upperBound = (BoundaryClass) 3;
        this->departure_ellipsoid_axes_lowerBound = 0;
        this->departure_ellipsoid_axes_upperBound = math::LARGE;
        this->arrival_type_lowerBound = (ArrivalType) 0;
        this->arrival_type_upperBound = (ArrivalType) 7;
        this->arrival_elements_lowerBound = -math::LARGE;
        this->arrival_elements_upperBound = math::LARGE;
        this->arrival_elements_bounds_lowerBound = -math::LARGE;
        this->arrival_elements_bounds_upperBound = math::LARGE;
        this->arrival_elements_reference_epoch_lowerBound = 0 * 86400.0;
        this->arrival_elements_reference_epoch_upperBound = math::LARGE * 86400.0;
        this->arrival_elements_state_representation_lowerBound = (StateRepresentation) 0;
        this->arrival_elements_state_representation_upperBound = (StateRepresentation) 6;
        this->arrival_elements_frame_lowerBound = (ReferenceFrame) 0;
        this->arrival_elements_frame_upperBound = (ReferenceFrame) 9;
        this->final_velocity_lowerBound = 0;
        this->final_velocity_upperBound = math::LARGE;
        this->forced_terminal_coast_lowerBound = 0 * 86400.0;
        this->forced_terminal_coast_upperBound = math::LARGE * 86400.0;
        this->forced_initial_coast_lowerBound = 0 * 86400.0;
        this->forced_initial_coast_upperBound = math::LARGE * 86400.0;
        this->arrival_class_lowerBound = (BoundaryClass) 0;
        this->arrival_class_upperBound = (BoundaryClass) 3;
        this->arrival_ellipsoid_axes_lowerBound = 0;
        this->arrival_ellipsoid_axes_upperBound = math::LARGE;
        this->zero_turn_flyby_distance_lowerBound = 0;
        this->zero_turn_flyby_distance_upperBound = math::LARGE;
        this->terminal_intercept_flyby_distance_lowerBound = 0;
        this->terminal_intercept_flyby_distance_upperBound = math::LARGE;
        this->escape_spiral_starting_radius_lowerBound = 0;
        this->escape_spiral_starting_radius_upperBound = math::LARGE;
        this->escape_spiral_final_radius_lowerBound = 0;
        this->escape_spiral_final_radius_upperBound = math::LARGE;
        this->capture_spiral_final_radius_lowerBound = 0;
        this->capture_spiral_final_radius_upperBound = math::LARGE;
        this->capture_spiral_starting_radius_lowerBound = 0;
        this->capture_spiral_starting_radius_upperBound = math::LARGE;
        this->journey_end_deltav_lowerBound = 0;
        this->journey_end_deltav_upperBound = math::LARGE;
        this->journey_end_propulsion_system_lowerBound = (PropulsionSystemChoice) 0;
        this->journey_end_propulsion_system_upperBound = (PropulsionSystemChoice) 1;
        this->perturbation_bodies_lowerBound = 1;
        this->perturbation_bodies_upperBound = SIZE_MAX;
        this->ephemeris_pegged_orbit_insertion_SMA_lowerBound = 0;
        this->ephemeris_pegged_orbit_insertion_SMA_upperBound = math::LARGE;
        this->ephemeris_pegged_orbit_insertion_ECC_lowerBound = 0;
        this->ephemeris_pegged_orbit_insertion_ECC_upperBound = math::LARGE;
        this->impact_momentum_enhancement_factor_lowerBound = 0.0;
        this->impact_momentum_enhancement_factor_upperBound = math::LARGE;
        this->spacecraft_drag_area_lowerBound = 0;
        this->spacecraft_drag_area_upperBound = math::LARGE;
        this->coefficient_of_drag_lowerBound = 0;
        this->coefficient_of_drag_upperBound = math::LARGE;
        this->probe_separation_impulse_lowerBound = 0;
        this->probe_separation_impulse_upperBound = math::LARGE;
        this->probe_mass_lowerBound = 1e-13;
        this->probe_mass_upperBound = math::LARGE;
        this->Probe_AEI_elements_lowerBound = -math::LARGE;
        this->Probe_AEI_elements_upperBound = math::LARGE;
        this->Probe_AEI_elements_bounds_lowerBound = -math::LARGE;
        this->Probe_AEI_elements_bounds_upperBound = math::LARGE;
        this->Probe_AEI_elements_reference_epoch_lowerBound = 0 * 86400.0;
        this->Probe_AEI_elements_reference_epoch_upperBound = math::LARGE * 86400.0;
        this->Probe_AEI_elements_state_representation_lowerBound = (StateRepresentation) 0;
        this->Probe_AEI_elements_state_representation_upperBound = (StateRepresentation) 3;
        this->Probe_AEI_elements_frame_lowerBound = (ReferenceFrame) 0;
        this->Probe_AEI_elements_frame_upperBound = (ReferenceFrame) 8;
        this->Probe_End_elements_lowerBound = -math::LARGE;
        this->Probe_End_elements_upperBound = math::LARGE;
        this->Probe_End_elements_bounds_lowerBound = -math::LARGE;
        this->Probe_End_elements_bounds_upperBound = math::LARGE;
        this->Probe_End_elements_reference_epoch_lowerBound = 0 * 86400.0;
        this->Probe_End_elements_reference_epoch_upperBound = math::LARGE * 86400.0;
        this->Probe_End_elements_state_representation_lowerBound = (StateRepresentation) 0;
        this->Probe_End_elements_state_representation_upperBound = (StateRepresentation) 3;
        this->Probe_End_elements_frame_lowerBound = (ReferenceFrame) 0;
        this->Probe_End_elements_frame_upperBound = (ReferenceFrame) 8;
        this->probe_communication_distance_bounds_lowerBound = 0.0;
        this->probe_communication_distance_bounds_upperBound = math::LARGE;
        this->probe_drag_area_probe_separation_to_AEI_lowerBound = 0;
        this->probe_drag_area_probe_separation_to_AEI_upperBound = math::LARGE;
        this->probe_drag_area_probe_AEI_to_end_lowerBound = 0;
        this->probe_drag_area_probe_AEI_to_end_upperBound = math::LARGE;
        this->probe_coefficient_of_drag_probe_separation_to_AEI_lowerBound = 0;
        this->probe_coefficient_of_drag_probe_separation_to_AEI_upperBound = math::LARGE;
        this->probe_coefficient_of_drag_probe_AEI_to_end_lowerBound = 0;
        this->probe_coefficient_of_drag_probe_AEI_to_end_upperBound = math::LARGE;
        this->probe_AEI_velocity_lowerBound = 0;
        this->probe_AEI_velocity_upperBound = math::LARGE;
        this->probe_end_velocity_lowerBound = 0;
        this->probe_end_velocity_upperBound = math::LARGE;
        this->ProbeSeparationToAEI_MatchPointFraction_lowerBound = 0;
        this->ProbeSeparationToAEI_MatchPointFraction_upperBound = 1;
        this->ProbeSeparationToAEI_ForwardIntegrationStepLength_lowerBound = 0;
        this->ProbeSeparationToAEI_ForwardIntegrationStepLength_upperBound = 1000000;
        this->ProbeSeparationToAEI_BackwardIntegrationStepLength_lowerBound = 0;
        this->ProbeSeparationToAEI_BackwardIntegrationStepLength_upperBound = 1000000;
        this->ProbeAEI_to_end_MatchPointFraction_lowerBound = 0;
        this->ProbeAEI_to_end_MatchPointFraction_upperBound = 1;
        this->ProbeAEI_to_end_ForwardIntegrationStepLength_lowerBound = 0;
        this->ProbeAEI_to_end_ForwardIntegrationStepLength_upperBound = 1000000;
        this->ProbeAEI_to_end_BackwardIntegrationStepLength_lowerBound = 0;
        this->ProbeAEI_to_end_BackwardIntegrationStepLength_upperBound = 1000000;
    }//end constructor
    
    JourneyOptions::JourneyOptions(std::string optionsfilename) : JourneyOptions()
    {
        size_t lineNumber = 0;
        std::ifstream optionsFileStream;
        optionsFileStream.open(optionsfilename);
        
        if (!optionsFileStream.is_open())
        {
            throw std::invalid_argument("Cannot find options file: " + optionsfilename);
        }
        
        this->parse_journey(optionsFileStream, lineNumber);
    }//end constructor with input filename
    
    JourneyOptions::JourneyOptions(std::ifstream& optionsFileStream, size_t& lineNumber) : JourneyOptions()
    {
        this->parse_journey(optionsFileStream, lineNumber);
    }//end constructor with input filestream
    
    //parsers
    void JourneyOptions::parse_journey(std::ifstream& optionsFileStream, size_t& lineNumber)
    {
        std::string line;
        
        while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
        {
            if (line.size() > 0) //skip blank lines
            {
                if (line.front() == *"#") //skip comment lines
                {
                    ++lineNumber;
                }
                else if (line == "BEGIN_JOURNEY")
                {
                    ++lineNumber;
                }
                else if (line == "END_JOURNEY")
                {
                    this->number_of_phases = this->sequence.size() + 1;
                    
                    ++lineNumber;
                    return;
                }
                else
                {
                    this->parse_line(line, lineNumber, optionsFileStream);
                }
            }
        }
    }//end parse_journey()
    
   void JourneyOptions::parse_line(const std::string& line, size_t& lineNumber, std::ifstream& optionsFileStream)
   {
       ++lineNumber;
       
       std::vector<std::string> linecell;
       boost::split(linecell, line, boost::is_any_of(" "), boost::token_compress_on);
       
        if (linecell[0] == "journey_name")
        {
            this->journey_name = linecell[1];
            return;
        }
        if (linecell[0] == "journey_central_body")
        {
            this->journey_central_body = linecell[1];
            return;
        }
        if (linecell[0] == "destination_list")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option destination_list has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->destination_list.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->destination_list.push_back(std::stoi(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->destination_list[entryIndex] < this->destination_list_lowerBound[entryIndex] || this->destination_list[entryIndex] > this->destination_list_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option destination_list[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->destination_list[entryIndex]) + ", bounds are [" + std::to_string(this->destination_list_lowerBound[entryIndex]) + ", " + std::to_string(this->destination_list_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "sequence")
        {
            this->sequence.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->sequence.push_back(std::stoi(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->sequence[entryIndex] < this->sequence_lowerBound || this->sequence[entryIndex] > this->sequence_upperBound)
               {
                   throw std::out_of_range("Input option sequence[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->sequence[entryIndex]) + ", bounds are [" + std::to_string(this->sequence_lowerBound) + ", " + std::to_string(this->sequence_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "phase_type")
        {
            this->phase_type = (PhaseType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->phase_type < this->phase_type_lowerBound || this->phase_type > this->phase_type_upperBound)
            {
                throw std::out_of_range("Input option phase_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->phase_type) + ", bounds are [" + std::to_string(this->phase_type_lowerBound) + ", " + std::to_string(this->phase_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "impulses_per_phase")
        {
            this->impulses_per_phase = std::stoi(linecell[1]);
            
            //bounds check
            if (this->impulses_per_phase < this->impulses_per_phase_lowerBound || this->impulses_per_phase > this->impulses_per_phase_upperBound)
            {
                throw std::out_of_range("Input option impulses_per_phase is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->impulses_per_phase) + ", bounds are [" + std::to_string(this->impulses_per_phase_lowerBound) + ", " + std::to_string(this->impulses_per_phase_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "thrust_control_law")
        {
            this->thrust_control_law = (ThrustControlLaw) std::stoi(linecell[1]);
            
            //bounds check
            if (this->thrust_control_law < this->thrust_control_law_lowerBound || this->thrust_control_law > this->thrust_control_law_upperBound)
            {
                throw std::out_of_range("Input option thrust_control_law is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->thrust_control_law) + ", bounds are [" + std::to_string(this->thrust_control_law_lowerBound) + ", " + std::to_string(this->thrust_control_law_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "force_unit_magnitude_control")
        {
            this->force_unit_magnitude_control = (ControlMagnitudeType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->force_unit_magnitude_control < this->force_unit_magnitude_control_lowerBound || this->force_unit_magnitude_control > this->force_unit_magnitude_control_upperBound)
            {
                throw std::out_of_range("Input option force_unit_magnitude_control is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->force_unit_magnitude_control) + ", bounds are [" + std::to_string(this->force_unit_magnitude_control_lowerBound) + ", " + std::to_string(this->force_unit_magnitude_control_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "force_fixed_inertial_control")
        {
            this->force_fixed_inertial_control = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "override_num_steps")
        {
            this->override_num_steps = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "number_of_steps")
        {
            this->number_of_steps = std::stoi(linecell[1]);
            
            //bounds check
            if (this->number_of_steps < this->number_of_steps_lowerBound || this->number_of_steps > this->number_of_steps_upperBound)
            {
                throw std::out_of_range("Input option number_of_steps is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->number_of_steps) + ", bounds are [" + std::to_string(this->number_of_steps_lowerBound) + ", " + std::to_string(this->number_of_steps_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_duty_cycle")
        {
            this->override_duty_cycle = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "duty_cycle")
        {
            this->duty_cycle = std::stod(linecell[1]);
            
            //bounds check
            if (this->duty_cycle < this->duty_cycle_lowerBound || this->duty_cycle > this->duty_cycle_upperBound)
            {
                throw std::out_of_range("Input option duty_cycle is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->duty_cycle) + ", bounds are [" + std::to_string(this->duty_cycle_lowerBound) + ", " + std::to_string(this->duty_cycle_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_PropagatorType")
        {
            this->override_PropagatorType = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "propagatorType")
        {
            this->propagatorType = (PropagatorType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->propagatorType < this->propagatorType_lowerBound || this->propagatorType > this->propagatorType_upperBound)
            {
                throw std::out_of_range("Input option propagatorType is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->propagatorType) + ", bounds are [" + std::to_string(this->propagatorType_lowerBound) + ", " + std::to_string(this->propagatorType_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_integration_step_size")
        {
            this->override_integration_step_size = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "integration_step_size")
        {
            this->integration_step_size = std::stod(linecell[1]);
            
            //bounds check
            if (this->integration_step_size < this->integration_step_size_lowerBound || this->integration_step_size > this->integration_step_size_upperBound)
            {
                throw std::out_of_range("Input option integration_step_size is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->integration_step_size) + ", bounds are [" + std::to_string(this->integration_step_size_lowerBound) + ", " + std::to_string(this->integration_step_size_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_flyby_altitude_bounds")
        {
            this->override_flyby_altitude_bounds = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "flyby_altitude_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option flyby_altitude_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->flyby_altitude_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->flyby_altitude_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->flyby_altitude_bounds[entryIndex] < this->flyby_altitude_bounds_lowerBound[entryIndex] || this->flyby_altitude_bounds[entryIndex] > this->flyby_altitude_bounds_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option flyby_altitude_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->flyby_altitude_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->flyby_altitude_bounds_lowerBound[entryIndex]) + ", " + std::to_string(this->flyby_altitude_bounds_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "PeriapseArrival_override_altitude")
        {
            this->PeriapseArrival_override_altitude = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "PeriapseArrival_altitude_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option PeriapseArrival_altitude_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->PeriapseArrival_altitude_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->PeriapseArrival_altitude_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->PeriapseArrival_altitude_bounds[entryIndex] < this->PeriapseArrival_altitude_bounds_lowerBound[entryIndex] || this->PeriapseArrival_altitude_bounds[entryIndex] > this->PeriapseArrival_altitude_bounds_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option PeriapseArrival_altitude_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->PeriapseArrival_altitude_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->PeriapseArrival_altitude_bounds_lowerBound[entryIndex]) + ", " + std::to_string(this->PeriapseArrival_altitude_bounds_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "PeriapseDeparture_altitude_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option PeriapseDeparture_altitude_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->PeriapseDeparture_altitude_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->PeriapseDeparture_altitude_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->PeriapseDeparture_altitude_bounds[entryIndex] < this->PeriapseDeparture_altitude_bounds_lowerBound[entryIndex] || this->PeriapseDeparture_altitude_bounds[entryIndex] > this->PeriapseDeparture_altitude_bounds_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option PeriapseDeparture_altitude_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->PeriapseDeparture_altitude_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->PeriapseDeparture_altitude_bounds_lowerBound[entryIndex]) + ", " + std::to_string(this->PeriapseDeparture_altitude_bounds_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "num_interior_control_points")
        {
            this->num_interior_control_points = std::stoi(linecell[1]);
            
            //bounds check
            if (this->num_interior_control_points < this->num_interior_control_points_lowerBound || this->num_interior_control_points > this->num_interior_control_points_upperBound)
            {
                throw std::out_of_range("Input option num_interior_control_points is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->num_interior_control_points) + ", bounds are [" + std::to_string(this->num_interior_control_points_lowerBound) + ", " + std::to_string(this->num_interior_control_points_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "CoastPhaseMatchPointFraction")
        {
            this->CoastPhaseMatchPointFraction = std::stod(linecell[1]);
            
            //bounds check
            if (this->CoastPhaseMatchPointFraction < this->CoastPhaseMatchPointFraction_lowerBound || this->CoastPhaseMatchPointFraction > this->CoastPhaseMatchPointFraction_upperBound)
            {
                throw std::out_of_range("Input option CoastPhaseMatchPointFraction is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->CoastPhaseMatchPointFraction) + ", bounds are [" + std::to_string(this->CoastPhaseMatchPointFraction_lowerBound) + ", " + std::to_string(this->CoastPhaseMatchPointFraction_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "CoastPhaseForwardIntegrationStepLength")
        {
            this->CoastPhaseForwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->CoastPhaseForwardIntegrationStepLength < this->CoastPhaseForwardIntegrationStepLength_lowerBound || this->CoastPhaseForwardIntegrationStepLength > this->CoastPhaseForwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option CoastPhaseForwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->CoastPhaseForwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->CoastPhaseForwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->CoastPhaseForwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "CoastPhaseBackwardIntegrationStepLength")
        {
            this->CoastPhaseBackwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->CoastPhaseBackwardIntegrationStepLength < this->CoastPhaseBackwardIntegrationStepLength_lowerBound || this->CoastPhaseBackwardIntegrationStepLength > this->CoastPhaseBackwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option CoastPhaseBackwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->CoastPhaseBackwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->CoastPhaseBackwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->CoastPhaseBackwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "journey_end_TCM")
        {
            this->journey_end_TCM = std::stod(linecell[1]);
            
            //bounds check
            if (this->journey_end_TCM < this->journey_end_TCM_lowerBound || this->journey_end_TCM > this->journey_end_TCM_upperBound)
            {
                throw std::out_of_range("Input option journey_end_TCM is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->journey_end_TCM) + ", bounds are [" + std::to_string(this->journey_end_TCM_lowerBound) + ", " + std::to_string(this->journey_end_TCM_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "enable_periapse_burns")
        {
            this->enable_periapse_burns = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "bounded_departure_date")
        {
            this->bounded_departure_date = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "timebounded")
        {
            this->timebounded = std::stoi(linecell[1]);
            
            //bounds check
            if (this->timebounded < this->timebounded_lowerBound || this->timebounded > this->timebounded_upperBound)
            {
                throw std::out_of_range("Input option timebounded is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->timebounded) + ", bounds are [" + std::to_string(this->timebounded_lowerBound) + ", " + std::to_string(this->timebounded_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "departure_date_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option departure_date_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->departure_date_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->departure_date_bounds.push_back(std::stod(linecell[entryIndex + 1]) * 86400.0);
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->departure_date_bounds[entryIndex] < this->departure_date_bounds_lowerBound || this->departure_date_bounds[entryIndex] > this->departure_date_bounds_upperBound)
               {
                   throw std::out_of_range("Input option departure_date_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_date_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->departure_date_bounds_lowerBound) + ", " + std::to_string(this->departure_date_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "wait_time_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option wait_time_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->wait_time_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->wait_time_bounds.push_back(std::stod(linecell[entryIndex + 1]) * 86400.0);
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->wait_time_bounds[entryIndex] < this->wait_time_bounds_lowerBound || this->wait_time_bounds[entryIndex] > this->wait_time_bounds_upperBound)
               {
                   throw std::out_of_range("Input option wait_time_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->wait_time_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->wait_time_bounds_lowerBound) + ", " + std::to_string(this->wait_time_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "flight_time_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option flight_time_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->flight_time_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->flight_time_bounds.push_back(std::stod(linecell[entryIndex + 1]) * 86400.0);
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->flight_time_bounds[entryIndex] < this->flight_time_bounds_lowerBound || this->flight_time_bounds[entryIndex] > this->flight_time_bounds_upperBound)
               {
                   throw std::out_of_range("Input option flight_time_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->flight_time_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->flight_time_bounds_lowerBound) + ", " + std::to_string(this->flight_time_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "arrival_date_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option arrival_date_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->arrival_date_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->arrival_date_bounds.push_back(std::stod(linecell[entryIndex + 1]) * 86400.0);
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->arrival_date_bounds[entryIndex] < this->arrival_date_bounds_lowerBound || this->arrival_date_bounds[entryIndex] > this->arrival_date_bounds_upperBound)
               {
                   throw std::out_of_range("Input option arrival_date_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_date_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->arrival_date_bounds_lowerBound) + ", " + std::to_string(this->arrival_date_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "departure_type")
        {
            this->departure_type = (DepartureType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->departure_type < this->departure_type_lowerBound || this->departure_type > this->departure_type_upperBound)
            {
                throw std::out_of_range("Input option departure_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_type) + ", bounds are [" + std::to_string(this->departure_type_lowerBound) + ", " + std::to_string(this->departure_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "initial_impulse_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option initial_impulse_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->initial_impulse_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->initial_impulse_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->initial_impulse_bounds[entryIndex] < this->initial_impulse_bounds_lowerBound || this->initial_impulse_bounds[entryIndex] > this->initial_impulse_bounds_upperBound)
               {
                   throw std::out_of_range("Input option initial_impulse_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->initial_impulse_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->initial_impulse_bounds_lowerBound) + ", " + std::to_string(this->initial_impulse_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "force_free_point_direct_insertion_along_velocity_vector")
        {
            this->force_free_point_direct_insertion_along_velocity_vector = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "departure_elements_vary_flag")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option departure_elements_vary_flag has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->departure_elements_vary_flag.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->departure_elements_vary_flag.push_back((bool) std::stoi(linecell[entryIndex + 1]));
            }
            return;
        }
        if (linecell[0] == "departure_elements")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option departure_elements has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->departure_elements.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->departure_elements.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->departure_elements[entryIndex] < this->departure_elements_lowerBound || this->departure_elements[entryIndex] > this->departure_elements_upperBound)
               {
                   throw std::out_of_range("Input option departure_elements[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_elements[entryIndex]) + ", bounds are [" + std::to_string(this->departure_elements_lowerBound) + ", " + std::to_string(this->departure_elements_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "departure_elements_bounds")
        {
            if (linecell.size() - 1 != 12)
            {
                throw std::invalid_argument("Input option departure_elements_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 12 arguments.");
            }
            
            this->departure_elements_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->departure_elements_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->departure_elements_bounds[entryIndex] < this->departure_elements_bounds_lowerBound || this->departure_elements_bounds[entryIndex] > this->departure_elements_bounds_upperBound)
               {
                   throw std::out_of_range("Input option departure_elements_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_elements_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->departure_elements_bounds_lowerBound) + ", " + std::to_string(this->departure_elements_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "departure_elements_reference_epoch")
        {
            this->departure_elements_reference_epoch = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->departure_elements_reference_epoch < this->departure_elements_reference_epoch_lowerBound || this->departure_elements_reference_epoch > this->departure_elements_reference_epoch_upperBound)
            {
                throw std::out_of_range("Input option departure_elements_reference_epoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_elements_reference_epoch) + ", bounds are [" + std::to_string(this->departure_elements_reference_epoch_lowerBound) + ", " + std::to_string(this->departure_elements_reference_epoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "departure_elements_state_representation")
        {
            this->departure_elements_state_representation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->departure_elements_state_representation < this->departure_elements_state_representation_lowerBound || this->departure_elements_state_representation > this->departure_elements_state_representation_upperBound)
            {
                throw std::out_of_range("Input option departure_elements_state_representation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_elements_state_representation) + ", bounds are [" + std::to_string(this->departure_elements_state_representation_lowerBound) + ", " + std::to_string(this->departure_elements_state_representation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "departure_elements_frame")
        {
            this->departure_elements_frame = (ReferenceFrame) std::stoi(linecell[1]);
            
            //bounds check
            if (this->departure_elements_frame < this->departure_elements_frame_lowerBound || this->departure_elements_frame > this->departure_elements_frame_upperBound)
            {
                throw std::out_of_range("Input option departure_elements_frame is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_elements_frame) + ", bounds are [" + std::to_string(this->departure_elements_frame_lowerBound) + ", " + std::to_string(this->departure_elements_frame_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "AllowJourneyFreePointDepartureToPropagate")
        {
            this->AllowJourneyFreePointDepartureToPropagate = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "maximum_starting_mass_increment")
        {
            this->maximum_starting_mass_increment = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_starting_mass_increment < this->maximum_starting_mass_increment_lowerBound || this->maximum_starting_mass_increment > this->maximum_starting_mass_increment_upperBound)
            {
                throw std::out_of_range("Input option maximum_starting_mass_increment is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_starting_mass_increment) + ", bounds are [" + std::to_string(this->maximum_starting_mass_increment_lowerBound) + ", " + std::to_string(this->maximum_starting_mass_increment_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "minimum_starting_mass_increment")
        {
            this->minimum_starting_mass_increment = std::stod(linecell[1]);
            
            //bounds check
            if (this->minimum_starting_mass_increment < this->minimum_starting_mass_increment_lowerBound || this->minimum_starting_mass_increment > this->minimum_starting_mass_increment_upperBound)
            {
                throw std::out_of_range("Input option minimum_starting_mass_increment is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->minimum_starting_mass_increment) + ", bounds are [" + std::to_string(this->minimum_starting_mass_increment_lowerBound) + ", " + std::to_string(this->minimum_starting_mass_increment_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "fixed_starting_mass_increment")
        {
            this->fixed_starting_mass_increment = std::stod(linecell[1]);
            
            //bounds check
            if (this->fixed_starting_mass_increment < this->fixed_starting_mass_increment_lowerBound || this->fixed_starting_mass_increment > this->fixed_starting_mass_increment_upperBound)
            {
                throw std::out_of_range("Input option fixed_starting_mass_increment is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->fixed_starting_mass_increment) + ", bounds are [" + std::to_string(this->fixed_starting_mass_increment_lowerBound) + ", " + std::to_string(this->fixed_starting_mass_increment_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "fixed_ending_mass_increment")
        {
            this->fixed_ending_mass_increment = std::stod(linecell[1]);
            
            //bounds check
            if (this->fixed_ending_mass_increment < this->fixed_ending_mass_increment_lowerBound || this->fixed_ending_mass_increment > this->fixed_ending_mass_increment_upperBound)
            {
                throw std::out_of_range("Input option fixed_ending_mass_increment is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->fixed_ending_mass_increment) + ", bounds are [" + std::to_string(this->fixed_ending_mass_increment_lowerBound) + ", " + std::to_string(this->fixed_ending_mass_increment_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "variable_mass_increment")
        {
            this->variable_mass_increment = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "constrain_initial_mass")
        {
            this->constrain_initial_mass = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "maximum_initial_mass")
        {
            this->maximum_initial_mass = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_initial_mass < this->maximum_initial_mass_lowerBound || this->maximum_initial_mass > this->maximum_initial_mass_upperBound)
            {
                throw std::out_of_range("Input option maximum_initial_mass is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_initial_mass) + ", bounds are [" + std::to_string(this->maximum_initial_mass_lowerBound) + ", " + std::to_string(this->maximum_initial_mass_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "departure_class")
        {
            this->departure_class = (BoundaryClass) std::stoi(linecell[1]);
            
            //bounds check
            if (this->departure_class < this->departure_class_lowerBound || this->departure_class > this->departure_class_upperBound)
            {
                throw std::out_of_range("Input option departure_class is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_class) + ", bounds are [" + std::to_string(this->departure_class_lowerBound) + ", " + std::to_string(this->departure_class_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "departure_ellipsoid_axes")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option departure_ellipsoid_axes has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->departure_ellipsoid_axes.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->departure_ellipsoid_axes.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->departure_ellipsoid_axes[entryIndex] < this->departure_ellipsoid_axes_lowerBound || this->departure_ellipsoid_axes[entryIndex] > this->departure_ellipsoid_axes_upperBound)
               {
                   throw std::out_of_range("Input option departure_ellipsoid_axes[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->departure_ellipsoid_axes[entryIndex]) + ", bounds are [" + std::to_string(this->departure_ellipsoid_axes_lowerBound) + ", " + std::to_string(this->departure_ellipsoid_axes_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "arrival_type")
        {
            this->arrival_type = (ArrivalType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->arrival_type < this->arrival_type_lowerBound || this->arrival_type > this->arrival_type_upperBound)
            {
                throw std::out_of_range("Input option arrival_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_type) + ", bounds are [" + std::to_string(this->arrival_type_lowerBound) + ", " + std::to_string(this->arrival_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "arrival_elements_vary_flag")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option arrival_elements_vary_flag has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->arrival_elements_vary_flag.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->arrival_elements_vary_flag.push_back((bool) std::stoi(linecell[entryIndex + 1]));
            }
            return;
        }
        if (linecell[0] == "arrival_elements")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option arrival_elements has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->arrival_elements.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->arrival_elements.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->arrival_elements[entryIndex] < this->arrival_elements_lowerBound || this->arrival_elements[entryIndex] > this->arrival_elements_upperBound)
               {
                   throw std::out_of_range("Input option arrival_elements[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_elements[entryIndex]) + ", bounds are [" + std::to_string(this->arrival_elements_lowerBound) + ", " + std::to_string(this->arrival_elements_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "arrival_elements_bounds")
        {
            if (linecell.size() - 1 != 12)
            {
                throw std::invalid_argument("Input option arrival_elements_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 12 arguments.");
            }
            
            this->arrival_elements_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->arrival_elements_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->arrival_elements_bounds[entryIndex] < this->arrival_elements_bounds_lowerBound || this->arrival_elements_bounds[entryIndex] > this->arrival_elements_bounds_upperBound)
               {
                   throw std::out_of_range("Input option arrival_elements_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_elements_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->arrival_elements_bounds_lowerBound) + ", " + std::to_string(this->arrival_elements_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "arrival_elements_reference_epoch")
        {
            this->arrival_elements_reference_epoch = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->arrival_elements_reference_epoch < this->arrival_elements_reference_epoch_lowerBound || this->arrival_elements_reference_epoch > this->arrival_elements_reference_epoch_upperBound)
            {
                throw std::out_of_range("Input option arrival_elements_reference_epoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_elements_reference_epoch) + ", bounds are [" + std::to_string(this->arrival_elements_reference_epoch_lowerBound) + ", " + std::to_string(this->arrival_elements_reference_epoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "arrival_elements_state_representation")
        {
            this->arrival_elements_state_representation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->arrival_elements_state_representation < this->arrival_elements_state_representation_lowerBound || this->arrival_elements_state_representation > this->arrival_elements_state_representation_upperBound)
            {
                throw std::out_of_range("Input option arrival_elements_state_representation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_elements_state_representation) + ", bounds are [" + std::to_string(this->arrival_elements_state_representation_lowerBound) + ", " + std::to_string(this->arrival_elements_state_representation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "arrival_elements_frame")
        {
            this->arrival_elements_frame = (ReferenceFrame) std::stoi(linecell[1]);
            
            //bounds check
            if (this->arrival_elements_frame < this->arrival_elements_frame_lowerBound || this->arrival_elements_frame > this->arrival_elements_frame_upperBound)
            {
                throw std::out_of_range("Input option arrival_elements_frame is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_elements_frame) + ", bounds are [" + std::to_string(this->arrival_elements_frame_lowerBound) + ", " + std::to_string(this->arrival_elements_frame_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "AllowJourneyFreePointArrivalToPropagate")
        {
            this->AllowJourneyFreePointArrivalToPropagate = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "final_velocity")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option final_velocity has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->final_velocity.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->final_velocity.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->final_velocity[entryIndex] < this->final_velocity_lowerBound || this->final_velocity[entryIndex] > this->final_velocity_upperBound)
               {
                   throw std::out_of_range("Input option final_velocity[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->final_velocity[entryIndex]) + ", bounds are [" + std::to_string(this->final_velocity_lowerBound) + ", " + std::to_string(this->final_velocity_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "forced_terminal_coast")
        {
            this->forced_terminal_coast = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->forced_terminal_coast < this->forced_terminal_coast_lowerBound || this->forced_terminal_coast > this->forced_terminal_coast_upperBound)
            {
                throw std::out_of_range("Input option forced_terminal_coast is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forced_terminal_coast) + ", bounds are [" + std::to_string(this->forced_terminal_coast_lowerBound) + ", " + std::to_string(this->forced_terminal_coast_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "forced_initial_coast")
        {
            this->forced_initial_coast = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->forced_initial_coast < this->forced_initial_coast_lowerBound || this->forced_initial_coast > this->forced_initial_coast_upperBound)
            {
                throw std::out_of_range("Input option forced_initial_coast is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forced_initial_coast) + ", bounds are [" + std::to_string(this->forced_initial_coast_lowerBound) + ", " + std::to_string(this->forced_initial_coast_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "arrival_class")
        {
            this->arrival_class = (BoundaryClass) std::stoi(linecell[1]);
            
            //bounds check
            if (this->arrival_class < this->arrival_class_lowerBound || this->arrival_class > this->arrival_class_upperBound)
            {
                throw std::out_of_range("Input option arrival_class is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_class) + ", bounds are [" + std::to_string(this->arrival_class_lowerBound) + ", " + std::to_string(this->arrival_class_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "arrival_ellipsoid_axes")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option arrival_ellipsoid_axes has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->arrival_ellipsoid_axes.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->arrival_ellipsoid_axes.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->arrival_ellipsoid_axes[entryIndex] < this->arrival_ellipsoid_axes_lowerBound || this->arrival_ellipsoid_axes[entryIndex] > this->arrival_ellipsoid_axes_upperBound)
               {
                   throw std::out_of_range("Input option arrival_ellipsoid_axes[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->arrival_ellipsoid_axes[entryIndex]) + ", bounds are [" + std::to_string(this->arrival_ellipsoid_axes_lowerBound) + ", " + std::to_string(this->arrival_ellipsoid_axes_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "zero_turn_flyby_distance")
        {
            this->zero_turn_flyby_distance = std::stod(linecell[1]);
            
            //bounds check
            if (this->zero_turn_flyby_distance < this->zero_turn_flyby_distance_lowerBound || this->zero_turn_flyby_distance > this->zero_turn_flyby_distance_upperBound)
            {
                throw std::out_of_range("Input option zero_turn_flyby_distance is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->zero_turn_flyby_distance) + ", bounds are [" + std::to_string(this->zero_turn_flyby_distance_lowerBound) + ", " + std::to_string(this->zero_turn_flyby_distance_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "terminal_intercept_flyby_distance")
        {
            this->terminal_intercept_flyby_distance = std::stod(linecell[1]);
            
            //bounds check
            if (this->terminal_intercept_flyby_distance < this->terminal_intercept_flyby_distance_lowerBound || this->terminal_intercept_flyby_distance > this->terminal_intercept_flyby_distance_upperBound)
            {
                throw std::out_of_range("Input option terminal_intercept_flyby_distance is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->terminal_intercept_flyby_distance) + ", bounds are [" + std::to_string(this->terminal_intercept_flyby_distance_lowerBound) + ", " + std::to_string(this->terminal_intercept_flyby_distance_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "escape_spiral_starting_radius")
        {
            this->escape_spiral_starting_radius = std::stod(linecell[1]);
            
            //bounds check
            if (this->escape_spiral_starting_radius < this->escape_spiral_starting_radius_lowerBound || this->escape_spiral_starting_radius > this->escape_spiral_starting_radius_upperBound)
            {
                throw std::out_of_range("Input option escape_spiral_starting_radius is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->escape_spiral_starting_radius) + ", bounds are [" + std::to_string(this->escape_spiral_starting_radius_lowerBound) + ", " + std::to_string(this->escape_spiral_starting_radius_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "escape_spiral_final_radius")
        {
            this->escape_spiral_final_radius = std::stod(linecell[1]);
            
            //bounds check
            if (this->escape_spiral_final_radius < this->escape_spiral_final_radius_lowerBound || this->escape_spiral_final_radius > this->escape_spiral_final_radius_upperBound)
            {
                throw std::out_of_range("Input option escape_spiral_final_radius is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->escape_spiral_final_radius) + ", bounds are [" + std::to_string(this->escape_spiral_final_radius_lowerBound) + ", " + std::to_string(this->escape_spiral_final_radius_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "capture_spiral_final_radius")
        {
            this->capture_spiral_final_radius = std::stod(linecell[1]);
            
            //bounds check
            if (this->capture_spiral_final_radius < this->capture_spiral_final_radius_lowerBound || this->capture_spiral_final_radius > this->capture_spiral_final_radius_upperBound)
            {
                throw std::out_of_range("Input option capture_spiral_final_radius is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->capture_spiral_final_radius) + ", bounds are [" + std::to_string(this->capture_spiral_final_radius_lowerBound) + ", " + std::to_string(this->capture_spiral_final_radius_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "capture_spiral_starting_radius")
        {
            this->capture_spiral_starting_radius = std::stod(linecell[1]);
            
            //bounds check
            if (this->capture_spiral_starting_radius < this->capture_spiral_starting_radius_lowerBound || this->capture_spiral_starting_radius > this->capture_spiral_starting_radius_upperBound)
            {
                throw std::out_of_range("Input option capture_spiral_starting_radius is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->capture_spiral_starting_radius) + ", bounds are [" + std::to_string(this->capture_spiral_starting_radius_lowerBound) + ", " + std::to_string(this->capture_spiral_starting_radius_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "FreePointArrival_print_target_spec")
        {
            this->FreePointArrival_print_target_spec = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "journey_end_deltav")
        {
            this->journey_end_deltav = std::stod(linecell[1]);
            
            //bounds check
            if (this->journey_end_deltav < this->journey_end_deltav_lowerBound || this->journey_end_deltav > this->journey_end_deltav_upperBound)
            {
                throw std::out_of_range("Input option journey_end_deltav is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->journey_end_deltav) + ", bounds are [" + std::to_string(this->journey_end_deltav_lowerBound) + ", " + std::to_string(this->journey_end_deltav_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "journey_end_propulsion_system")
        {
            this->journey_end_propulsion_system = (PropulsionSystemChoice) std::stoi(linecell[1]);
            
            //bounds check
            if (this->journey_end_propulsion_system < this->journey_end_propulsion_system_lowerBound || this->journey_end_propulsion_system > this->journey_end_propulsion_system_upperBound)
            {
                throw std::out_of_range("Input option journey_end_propulsion_system is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->journey_end_propulsion_system) + ", bounds are [" + std::to_string(this->journey_end_propulsion_system_lowerBound) + ", " + std::to_string(this->journey_end_propulsion_system_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "perturbation_bodies")
        {
            this->perturbation_bodies.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->perturbation_bodies.push_back(std::stoi(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->perturbation_bodies[entryIndex] < this->perturbation_bodies_lowerBound || this->perturbation_bodies[entryIndex] > this->perturbation_bodies_upperBound)
               {
                   throw std::out_of_range("Input option perturbation_bodies[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->perturbation_bodies[entryIndex]) + ", bounds are [" + std::to_string(this->perturbation_bodies_lowerBound) + ", " + std::to_string(this->perturbation_bodies_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "stage_after_departure")
        {
            this->stage_after_departure = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "stage_before_arrival")
        {
            this->stage_before_arrival = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "stage_after_arrival")
        {
            this->stage_after_arrival = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "freeze_decision_variables")
        {
            this->freeze_decision_variables = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "ephemeris_pegged_orbit_insertion_SMA")
        {
            this->ephemeris_pegged_orbit_insertion_SMA = std::stod(linecell[1]);
            
            //bounds check
            if (this->ephemeris_pegged_orbit_insertion_SMA < this->ephemeris_pegged_orbit_insertion_SMA_lowerBound || this->ephemeris_pegged_orbit_insertion_SMA > this->ephemeris_pegged_orbit_insertion_SMA_upperBound)
            {
                throw std::out_of_range("Input option ephemeris_pegged_orbit_insertion_SMA is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ephemeris_pegged_orbit_insertion_SMA) + ", bounds are [" + std::to_string(this->ephemeris_pegged_orbit_insertion_SMA_lowerBound) + ", " + std::to_string(this->ephemeris_pegged_orbit_insertion_SMA_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ephemeris_pegged_orbit_insertion_ECC")
        {
            this->ephemeris_pegged_orbit_insertion_ECC = std::stod(linecell[1]);
            
            //bounds check
            if (this->ephemeris_pegged_orbit_insertion_ECC < this->ephemeris_pegged_orbit_insertion_ECC_lowerBound || this->ephemeris_pegged_orbit_insertion_ECC > this->ephemeris_pegged_orbit_insertion_ECC_upperBound)
            {
                throw std::out_of_range("Input option ephemeris_pegged_orbit_insertion_ECC is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ephemeris_pegged_orbit_insertion_ECC) + ", bounds are [" + std::to_string(this->ephemeris_pegged_orbit_insertion_ECC_lowerBound) + ", " + std::to_string(this->ephemeris_pegged_orbit_insertion_ECC_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "impact_momentum_enhancement_factor")
        {
            this->impact_momentum_enhancement_factor = std::stod(linecell[1]);
            
            //bounds check
            if (this->impact_momentum_enhancement_factor < this->impact_momentum_enhancement_factor_lowerBound || this->impact_momentum_enhancement_factor > this->impact_momentum_enhancement_factor_upperBound)
            {
                throw std::out_of_range("Input option impact_momentum_enhancement_factor is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->impact_momentum_enhancement_factor) + ", bounds are [" + std::to_string(this->impact_momentum_enhancement_factor_lowerBound) + ", " + std::to_string(this->impact_momentum_enhancement_factor_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "perturb_drag")
        {
            this->perturb_drag = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "spacecraft_drag_area")
        {
            this->spacecraft_drag_area = std::stod(linecell[1]);
            
            //bounds check
            if (this->spacecraft_drag_area < this->spacecraft_drag_area_lowerBound || this->spacecraft_drag_area > this->spacecraft_drag_area_upperBound)
            {
                throw std::out_of_range("Input option spacecraft_drag_area is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spacecraft_drag_area) + ", bounds are [" + std::to_string(this->spacecraft_drag_area_lowerBound) + ", " + std::to_string(this->spacecraft_drag_area_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "coefficient_of_drag")
        {
            this->coefficient_of_drag = std::stod(linecell[1]);
            
            //bounds check
            if (this->coefficient_of_drag < this->coefficient_of_drag_lowerBound || this->coefficient_of_drag > this->coefficient_of_drag_upperBound)
            {
                throw std::out_of_range("Input option coefficient_of_drag is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->coefficient_of_drag) + ", bounds are [" + std::to_string(this->coefficient_of_drag_lowerBound) + ", " + std::to_string(this->coefficient_of_drag_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "AtmosphericDensityModelKey")
        {
            this->AtmosphericDensityModelKey = linecell[1];
            return;
        }
        if (linecell[0] == "AtmosphericDensityModelDataFile")
        {
            this->AtmosphericDensityModelDataFile = linecell[1];
            return;
        }
        if (linecell[0] == "probe_separation_impulse")
        {
            this->probe_separation_impulse = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_separation_impulse < this->probe_separation_impulse_lowerBound || this->probe_separation_impulse > this->probe_separation_impulse_upperBound)
            {
                throw std::out_of_range("Input option probe_separation_impulse is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_separation_impulse) + ", bounds are [" + std::to_string(this->probe_separation_impulse_lowerBound) + ", " + std::to_string(this->probe_separation_impulse_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "probe_mass")
        {
            this->probe_mass = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_mass < this->probe_mass_lowerBound || this->probe_mass > this->probe_mass_upperBound)
            {
                throw std::out_of_range("Input option probe_mass is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_mass) + ", bounds are [" + std::to_string(this->probe_mass_lowerBound) + ", " + std::to_string(this->probe_mass_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements_vary_flag")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option Probe_AEI_elements_vary_flag has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->Probe_AEI_elements_vary_flag.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_AEI_elements_vary_flag.push_back((bool) std::stoi(linecell[entryIndex + 1]));
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option Probe_AEI_elements has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->Probe_AEI_elements.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_AEI_elements.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->Probe_AEI_elements[entryIndex] < this->Probe_AEI_elements_lowerBound || this->Probe_AEI_elements[entryIndex] > this->Probe_AEI_elements_upperBound)
               {
                   throw std::out_of_range("Input option Probe_AEI_elements[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_AEI_elements[entryIndex]) + ", bounds are [" + std::to_string(this->Probe_AEI_elements_lowerBound) + ", " + std::to_string(this->Probe_AEI_elements_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements_bounds")
        {
            if (linecell.size() - 1 != 12)
            {
                throw std::invalid_argument("Input option Probe_AEI_elements_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 12 arguments.");
            }
            
            this->Probe_AEI_elements_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_AEI_elements_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->Probe_AEI_elements_bounds[entryIndex] < this->Probe_AEI_elements_bounds_lowerBound || this->Probe_AEI_elements_bounds[entryIndex] > this->Probe_AEI_elements_bounds_upperBound)
               {
                   throw std::out_of_range("Input option Probe_AEI_elements_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_AEI_elements_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->Probe_AEI_elements_bounds_lowerBound) + ", " + std::to_string(this->Probe_AEI_elements_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements_reference_epoch")
        {
            this->Probe_AEI_elements_reference_epoch = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->Probe_AEI_elements_reference_epoch < this->Probe_AEI_elements_reference_epoch_lowerBound || this->Probe_AEI_elements_reference_epoch > this->Probe_AEI_elements_reference_epoch_upperBound)
            {
                throw std::out_of_range("Input option Probe_AEI_elements_reference_epoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_AEI_elements_reference_epoch) + ", bounds are [" + std::to_string(this->Probe_AEI_elements_reference_epoch_lowerBound) + ", " + std::to_string(this->Probe_AEI_elements_reference_epoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements_state_representation")
        {
            this->Probe_AEI_elements_state_representation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->Probe_AEI_elements_state_representation < this->Probe_AEI_elements_state_representation_lowerBound || this->Probe_AEI_elements_state_representation > this->Probe_AEI_elements_state_representation_upperBound)
            {
                throw std::out_of_range("Input option Probe_AEI_elements_state_representation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_AEI_elements_state_representation) + ", bounds are [" + std::to_string(this->Probe_AEI_elements_state_representation_lowerBound) + ", " + std::to_string(this->Probe_AEI_elements_state_representation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_AEI_elements_frame")
        {
            this->Probe_AEI_elements_frame = (ReferenceFrame) std::stoi(linecell[1]);
            
            //bounds check
            if (this->Probe_AEI_elements_frame < this->Probe_AEI_elements_frame_lowerBound || this->Probe_AEI_elements_frame > this->Probe_AEI_elements_frame_upperBound)
            {
                throw std::out_of_range("Input option Probe_AEI_elements_frame is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_AEI_elements_frame) + ", bounds are [" + std::to_string(this->Probe_AEI_elements_frame_lowerBound) + ", " + std::to_string(this->Probe_AEI_elements_frame_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements_vary_flag")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option Probe_End_elements_vary_flag has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->Probe_End_elements_vary_flag.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_End_elements_vary_flag.push_back((bool) std::stoi(linecell[entryIndex + 1]));
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements")
        {
            if (linecell.size() - 1 != 6)
            {
                throw std::invalid_argument("Input option Probe_End_elements has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 6 arguments.");
            }
            
            this->Probe_End_elements.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_End_elements.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->Probe_End_elements[entryIndex] < this->Probe_End_elements_lowerBound || this->Probe_End_elements[entryIndex] > this->Probe_End_elements_upperBound)
               {
                   throw std::out_of_range("Input option Probe_End_elements[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_End_elements[entryIndex]) + ", bounds are [" + std::to_string(this->Probe_End_elements_lowerBound) + ", " + std::to_string(this->Probe_End_elements_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements_bounds")
        {
            if (linecell.size() - 1 != 12)
            {
                throw std::invalid_argument("Input option Probe_End_elements_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 12 arguments.");
            }
            
            this->Probe_End_elements_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->Probe_End_elements_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->Probe_End_elements_bounds[entryIndex] < this->Probe_End_elements_bounds_lowerBound || this->Probe_End_elements_bounds[entryIndex] > this->Probe_End_elements_bounds_upperBound)
               {
                   throw std::out_of_range("Input option Probe_End_elements_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_End_elements_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->Probe_End_elements_bounds_lowerBound) + ", " + std::to_string(this->Probe_End_elements_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements_reference_epoch")
        {
            this->Probe_End_elements_reference_epoch = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->Probe_End_elements_reference_epoch < this->Probe_End_elements_reference_epoch_lowerBound || this->Probe_End_elements_reference_epoch > this->Probe_End_elements_reference_epoch_upperBound)
            {
                throw std::out_of_range("Input option Probe_End_elements_reference_epoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_End_elements_reference_epoch) + ", bounds are [" + std::to_string(this->Probe_End_elements_reference_epoch_lowerBound) + ", " + std::to_string(this->Probe_End_elements_reference_epoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements_state_representation")
        {
            this->Probe_End_elements_state_representation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->Probe_End_elements_state_representation < this->Probe_End_elements_state_representation_lowerBound || this->Probe_End_elements_state_representation > this->Probe_End_elements_state_representation_upperBound)
            {
                throw std::out_of_range("Input option Probe_End_elements_state_representation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_End_elements_state_representation) + ", bounds are [" + std::to_string(this->Probe_End_elements_state_representation_lowerBound) + ", " + std::to_string(this->Probe_End_elements_state_representation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Probe_End_elements_frame")
        {
            this->Probe_End_elements_frame = (ReferenceFrame) std::stoi(linecell[1]);
            
            //bounds check
            if (this->Probe_End_elements_frame < this->Probe_End_elements_frame_lowerBound || this->Probe_End_elements_frame > this->Probe_End_elements_frame_upperBound)
            {
                throw std::out_of_range("Input option Probe_End_elements_frame is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Probe_End_elements_frame) + ", bounds are [" + std::to_string(this->Probe_End_elements_frame_lowerBound) + ", " + std::to_string(this->Probe_End_elements_frame_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ModelProbeSecondPhase")
        {
            this->ModelProbeSecondPhase = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "AllowJourneyProbeAEIToPropagate")
        {
            this->AllowJourneyProbeAEIToPropagate = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "AllowJourneyProbeEndToPropagate")
        {
            this->AllowJourneyProbeEndToPropagate = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "probe_communication_distance_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option probe_communication_distance_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->probe_communication_distance_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->probe_communication_distance_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->probe_communication_distance_bounds[entryIndex] < this->probe_communication_distance_bounds_lowerBound || this->probe_communication_distance_bounds[entryIndex] > this->probe_communication_distance_bounds_upperBound)
               {
                   throw std::out_of_range("Input option probe_communication_distance_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_communication_distance_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->probe_communication_distance_bounds_lowerBound) + ", " + std::to_string(this->probe_communication_distance_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "perturb_drag_probe_separation_to_AEI")
        {
            this->perturb_drag_probe_separation_to_AEI = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "perturb_drag_probe_AEI_to_end")
        {
            this->perturb_drag_probe_AEI_to_end = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "probe_drag_area_probe_separation_to_AEI")
        {
            this->probe_drag_area_probe_separation_to_AEI = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_drag_area_probe_separation_to_AEI < this->probe_drag_area_probe_separation_to_AEI_lowerBound || this->probe_drag_area_probe_separation_to_AEI > this->probe_drag_area_probe_separation_to_AEI_upperBound)
            {
                throw std::out_of_range("Input option probe_drag_area_probe_separation_to_AEI is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_drag_area_probe_separation_to_AEI) + ", bounds are [" + std::to_string(this->probe_drag_area_probe_separation_to_AEI_lowerBound) + ", " + std::to_string(this->probe_drag_area_probe_separation_to_AEI_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "probe_drag_area_probe_AEI_to_end")
        {
            this->probe_drag_area_probe_AEI_to_end = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_drag_area_probe_AEI_to_end < this->probe_drag_area_probe_AEI_to_end_lowerBound || this->probe_drag_area_probe_AEI_to_end > this->probe_drag_area_probe_AEI_to_end_upperBound)
            {
                throw std::out_of_range("Input option probe_drag_area_probe_AEI_to_end is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_drag_area_probe_AEI_to_end) + ", bounds are [" + std::to_string(this->probe_drag_area_probe_AEI_to_end_lowerBound) + ", " + std::to_string(this->probe_drag_area_probe_AEI_to_end_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "probe_coefficient_of_drag_probe_separation_to_AEI")
        {
            this->probe_coefficient_of_drag_probe_separation_to_AEI = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_coefficient_of_drag_probe_separation_to_AEI < this->probe_coefficient_of_drag_probe_separation_to_AEI_lowerBound || this->probe_coefficient_of_drag_probe_separation_to_AEI > this->probe_coefficient_of_drag_probe_separation_to_AEI_upperBound)
            {
                throw std::out_of_range("Input option probe_coefficient_of_drag_probe_separation_to_AEI is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_coefficient_of_drag_probe_separation_to_AEI) + ", bounds are [" + std::to_string(this->probe_coefficient_of_drag_probe_separation_to_AEI_lowerBound) + ", " + std::to_string(this->probe_coefficient_of_drag_probe_separation_to_AEI_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "probe_coefficient_of_drag_probe_AEI_to_end")
        {
            this->probe_coefficient_of_drag_probe_AEI_to_end = std::stod(linecell[1]);
            
            //bounds check
            if (this->probe_coefficient_of_drag_probe_AEI_to_end < this->probe_coefficient_of_drag_probe_AEI_to_end_lowerBound || this->probe_coefficient_of_drag_probe_AEI_to_end > this->probe_coefficient_of_drag_probe_AEI_to_end_upperBound)
            {
                throw std::out_of_range("Input option probe_coefficient_of_drag_probe_AEI_to_end is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_coefficient_of_drag_probe_AEI_to_end) + ", bounds are [" + std::to_string(this->probe_coefficient_of_drag_probe_AEI_to_end_lowerBound) + ", " + std::to_string(this->probe_coefficient_of_drag_probe_AEI_to_end_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "probe_AEI_velocity")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option probe_AEI_velocity has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->probe_AEI_velocity.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->probe_AEI_velocity.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->probe_AEI_velocity[entryIndex] < this->probe_AEI_velocity_lowerBound || this->probe_AEI_velocity[entryIndex] > this->probe_AEI_velocity_upperBound)
               {
                   throw std::out_of_range("Input option probe_AEI_velocity[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_AEI_velocity[entryIndex]) + ", bounds are [" + std::to_string(this->probe_AEI_velocity_lowerBound) + ", " + std::to_string(this->probe_AEI_velocity_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "probe_end_velocity")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option probe_end_velocity has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->probe_end_velocity.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->probe_end_velocity.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->probe_end_velocity[entryIndex] < this->probe_end_velocity_lowerBound || this->probe_end_velocity[entryIndex] > this->probe_end_velocity_upperBound)
               {
                   throw std::out_of_range("Input option probe_end_velocity[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->probe_end_velocity[entryIndex]) + ", bounds are [" + std::to_string(this->probe_end_velocity_lowerBound) + ", " + std::to_string(this->probe_end_velocity_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "ProbeSeparationToAEI_MatchPointFraction")
        {
            this->ProbeSeparationToAEI_MatchPointFraction = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeSeparationToAEI_MatchPointFraction < this->ProbeSeparationToAEI_MatchPointFraction_lowerBound || this->ProbeSeparationToAEI_MatchPointFraction > this->ProbeSeparationToAEI_MatchPointFraction_upperBound)
            {
                throw std::out_of_range("Input option ProbeSeparationToAEI_MatchPointFraction is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeSeparationToAEI_MatchPointFraction) + ", bounds are [" + std::to_string(this->ProbeSeparationToAEI_MatchPointFraction_lowerBound) + ", " + std::to_string(this->ProbeSeparationToAEI_MatchPointFraction_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ProbeSeparationToAEI_ForwardIntegrationStepLength")
        {
            this->ProbeSeparationToAEI_ForwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeSeparationToAEI_ForwardIntegrationStepLength < this->ProbeSeparationToAEI_ForwardIntegrationStepLength_lowerBound || this->ProbeSeparationToAEI_ForwardIntegrationStepLength > this->ProbeSeparationToAEI_ForwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option ProbeSeparationToAEI_ForwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeSeparationToAEI_ForwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->ProbeSeparationToAEI_ForwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->ProbeSeparationToAEI_ForwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ProbeSeparationToAEI_BackwardIntegrationStepLength")
        {
            this->ProbeSeparationToAEI_BackwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeSeparationToAEI_BackwardIntegrationStepLength < this->ProbeSeparationToAEI_BackwardIntegrationStepLength_lowerBound || this->ProbeSeparationToAEI_BackwardIntegrationStepLength > this->ProbeSeparationToAEI_BackwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option ProbeSeparationToAEI_BackwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeSeparationToAEI_BackwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->ProbeSeparationToAEI_BackwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->ProbeSeparationToAEI_BackwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ProbeAEI_to_end_MatchPointFraction")
        {
            this->ProbeAEI_to_end_MatchPointFraction = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeAEI_to_end_MatchPointFraction < this->ProbeAEI_to_end_MatchPointFraction_lowerBound || this->ProbeAEI_to_end_MatchPointFraction > this->ProbeAEI_to_end_MatchPointFraction_upperBound)
            {
                throw std::out_of_range("Input option ProbeAEI_to_end_MatchPointFraction is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeAEI_to_end_MatchPointFraction) + ", bounds are [" + std::to_string(this->ProbeAEI_to_end_MatchPointFraction_lowerBound) + ", " + std::to_string(this->ProbeAEI_to_end_MatchPointFraction_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ProbeAEI_to_end_ForwardIntegrationStepLength")
        {
            this->ProbeAEI_to_end_ForwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeAEI_to_end_ForwardIntegrationStepLength < this->ProbeAEI_to_end_ForwardIntegrationStepLength_lowerBound || this->ProbeAEI_to_end_ForwardIntegrationStepLength > this->ProbeAEI_to_end_ForwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option ProbeAEI_to_end_ForwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeAEI_to_end_ForwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->ProbeAEI_to_end_ForwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->ProbeAEI_to_end_ForwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ProbeAEI_to_end_BackwardIntegrationStepLength")
        {
            this->ProbeAEI_to_end_BackwardIntegrationStepLength = std::stod(linecell[1]);
            
            //bounds check
            if (this->ProbeAEI_to_end_BackwardIntegrationStepLength < this->ProbeAEI_to_end_BackwardIntegrationStepLength_lowerBound || this->ProbeAEI_to_end_BackwardIntegrationStepLength > this->ProbeAEI_to_end_BackwardIntegrationStepLength_upperBound)
            {
                throw std::out_of_range("Input option ProbeAEI_to_end_BackwardIntegrationStepLength is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ProbeAEI_to_end_BackwardIntegrationStepLength) + ", bounds are [" + std::to_string(this->ProbeAEI_to_end_BackwardIntegrationStepLength_lowerBound) + ", " + std::to_string(this->ProbeAEI_to_end_BackwardIntegrationStepLength_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "print_this_journey_options_no_matter_what")
        {
            this->print_this_journey_options_no_matter_what = (bool) std::stoi(linecell[1]);
            return;
        }
        
        //specialized maneuver constraints(epoch and magnitude)
        if (linecell[0] == "BEGIN_MANEUVER_CONSTRAINT_BLOCK")
        {
            std::string line;
            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
            {
                line.erase( std::remove(line.begin(), line.end(), '\r'), line.end() );
                line.erase( std::remove(line.begin(), line.end(), '\n'), line.end() );
                if (line.size() > 0)
                {
                    if (line == "END_MANEUVER_CONSTRAINT_BLOCK")
                        return;
                    else
                        this->ManeuverConstraintDefinitions.push_back(line);

                }
            }
        }

        //specialized boundary constraints
        if (linecell[0] == "BEGIN_BOUNDARY_CONSTRAINT_BLOCK")
        {
            std::string line;
            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
            {
                line.erase( std::remove(line.begin(), line.end(), '\r'), line.end() );
                line.erase( std::remove(line.begin(), line.end(), '\n'), line.end() );
                if (line.size() > 0)
                {
                    if (line == "END_BOUNDARY_CONSTRAINT_BLOCK")
                        return;
                    else
                        this->BoundaryConstraintDefinitions.push_back(line);

                }
            }
        }

        //phase distance constraints
        if (linecell[0] == "BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK")
        {
            std::string line;
            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
            {
                line.erase( std::remove(line.begin(), line.end(), '\r'), line.end() );
                line.erase( std::remove(line.begin(), line.end(), '\n'), line.end() );
                if (line.size() > 0)
                {
                    if (line == "END_PHASE_DISTANCE_CONSTRAINT_BLOCK")
                        return;
                    else
                        this->PhaseDistanceConstraintDefinitions.push_back(line);

                }
            }
        }

        //decision vector guess
        if (linecell[0] == "BEGIN_TRIALX")
        {
            std::string line;
            while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
            {
                line.erase( std::remove(line.begin(), line.end(), '\r'), line.end() );
                line.erase( std::remove(line.begin(), line.end(), '\n'), line.end() );
                if (line.size() > 0)
                {
                    if (line == "END_TRIALX")
                        return;
                    else
                    {
                        std::vector<std::string> linecell;
                        boost::split(linecell, line, boost::is_any_of(","), boost::algorithm::token_compress_on);
                        boost::trim(linecell[0]);
                        this->trialX.push_back({ linecell[0], std::stod(linecell[1]) });
                    }

                }
            }

            return;
        }
        
        //If we got this far, then the option was not recognized
        std::cout << "Option " << linecell[0] << " on line " << lineNumber << " is not recognized. Moving on with life..." << std::endl;
    }//end parse_line()
    
    void JourneyOptions::write(const std::string& optionsFileName, const bool& newFile, const bool& writeAll)
    {
        std::ofstream optionsFileStream;
        if (newFile)
            optionsFileStream = std::ofstream(optionsFileName, std::ios::trunc);
        else
            optionsFileStream = std::ofstream(optionsFileName, std::ios::app);
        optionsFileStream.precision(20);
        
        optionsFileStream << "BEGIN_JOURNEY" << std::endl;
        
        if (this->journey_name != "default" || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey name" << std::endl;
            optionsFileStream << "journey_name " << this->journey_name << std::endl;
        }
    
        if (this->journey_central_body != "Sun" || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey central body name" << std::endl;
            optionsFileStream << "journey_central_body " << this->journey_central_body << std::endl;
        }
    
        if (this->destination_list != std::vector<int>({ 3, 4}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#destination list, as indices from the Universe file" << std::endl;
            optionsFileStream << "destination_list";
            for (int entry : this->destination_list)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        optionsFileStream << "#flyby sequence, as indices from the Universe file" << std::endl;
        optionsFileStream << "sequence";
        for (int entry : this->sequence)
            optionsFileStream << " " << entry;
        optionsFileStream << std::endl;
        
        if (this->phase_type != 2 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#phase type\n#0: MGALTS\n#1: FBLTS\n#2: MGALT\n#3: FBLT\n#4: PSBI\n#5: PSFB\n#6: MGAnDSMs\n#7: CoastPhase\n#8: SundmanCoastPhase\n#9: variable (do not use)\n#10 ProbeEntryPhase\n#11 ControlLawThrustPhase" << std::endl;
            optionsFileStream << "phase_type " << this->phase_type << std::endl;
        }
    
        if (this->impulses_per_phase != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#impulses per phase" << std::endl;
            optionsFileStream << "impulses_per_phase " << this->impulses_per_phase << std::endl;
        }
    
        if (this->thrust_control_law != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Thrust control law\n#0: Cartesian\n#1: Velocity direction\n1#2: anti-velocity direction" << std::endl;
            optionsFileStream << "thrust_control_law " << this->thrust_control_law << std::endl;
        }
    
        if (this->force_unit_magnitude_control != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Force unit magnitude control?\n#0: free control magnitude\n#1: force unit magnitude\n#2: force zero magnitude" << std::endl;
            optionsFileStream << "force_unit_magnitude_control " << this->force_unit_magnitude_control << std::endl;
        }
    
        if (this->force_fixed_inertial_control != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Force fixed inertial control? All control vectors in a phase must be identical if this is selected." << std::endl;
            optionsFileStream << "force_fixed_inertial_control " << this->force_fixed_inertial_control << std::endl;
        }
    
        if (this->override_num_steps != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Override this journey's number of steps?" << std::endl;
            optionsFileStream << "override_num_steps " << this->override_num_steps << std::endl;
        }
    
        if (this->number_of_steps != 20 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Number of time steps for this journey, if overriden" << std::endl;
            optionsFileStream << "number_of_steps " << this->number_of_steps << std::endl;
        }
    
        if (this->override_duty_cycle != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey override global duty cycle" << std::endl;
            optionsFileStream << "override_duty_cycle " << this->override_duty_cycle << std::endl;
        }
    
        if (this->duty_cycle != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey duty cycle" << std::endl;
            optionsFileStream << "duty_cycle " << this->duty_cycle << std::endl;
        }
    
        if (this->override_PropagatorType != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#override propagator type?" << std::endl;
            optionsFileStream << "override_PropagatorType " << this->override_PropagatorType << std::endl;
        }
    
        if (this->propagatorType != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#propagator type" << std::endl;
            optionsFileStream << "propagatorType " << this->propagatorType << std::endl;
        }
    
        if (this->override_integration_step_size != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Override global integration step size?" << std::endl;
            optionsFileStream << "override_integration_step_size " << this->override_integration_step_size << std::endl;
        }
    
        if (this->integration_step_size != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#integration step size (s)" << std::endl;
            optionsFileStream << "integration_step_size " << this->integration_step_size << std::endl;
        }
    
        if (this->override_flyby_altitude_bounds != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Override journey flyby altitude?" << std::endl;
            optionsFileStream << "override_flyby_altitude_bounds " << this->override_flyby_altitude_bounds << std::endl;
        }
    
        if (this->flyby_altitude_bounds != std::vector<double>({ 300.0, 1000000.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Lower and upper bound on journey flyby altitude (only applies to the departure flyby, if there is one)" << std::endl;
            optionsFileStream << "flyby_altitude_bounds";
            for (double entry : this->flyby_altitude_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->PeriapseArrival_override_altitude != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Override journey flyby altitude?" << std::endl;
            optionsFileStream << "PeriapseArrival_override_altitude " << this->PeriapseArrival_override_altitude << std::endl;
        }
    
        if (this->PeriapseArrival_altitude_bounds != std::vector<double>({ 300.0, 1000000.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Lower and upper bound on journey flyby altitude (km)" << std::endl;
            optionsFileStream << "PeriapseArrival_altitude_bounds";
            for (double entry : this->PeriapseArrival_altitude_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->PeriapseDeparture_altitude_bounds != std::vector<double>({ 185.0, 185.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#PeriapseDeparture altitude bounds (in km)" << std::endl;
            optionsFileStream << "PeriapseDeparture_altitude_bounds";
            for (double entry : this->PeriapseDeparture_altitude_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->num_interior_control_points != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#number of interior control points for parallel shooting phase types" << std::endl;
            optionsFileStream << "num_interior_control_points " << this->num_interior_control_points << std::endl;
        }
    
        if (this->CoastPhaseMatchPointFraction != 0.5 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#coast phase match point fraction" << std::endl;
            optionsFileStream << "CoastPhaseMatchPointFraction " << this->CoastPhaseMatchPointFraction << std::endl;
        }
    
        if (this->CoastPhaseForwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#coast phase forward integration step length (seconds)" << std::endl;
            optionsFileStream << "CoastPhaseForwardIntegrationStepLength " << this->CoastPhaseForwardIntegrationStepLength << std::endl;
        }
    
        if (this->CoastPhaseBackwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#coast phase backward integration step length (seconds)" << std::endl;
            optionsFileStream << "CoastPhaseBackwardIntegrationStepLength " << this->CoastPhaseBackwardIntegrationStepLength << std::endl;
        }
    
        if (this->journey_end_TCM != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey-end TCM magnitude (km/s)" << std::endl;
            optionsFileStream << "journey_end_TCM " << this->journey_end_TCM << std::endl;
        }
    
        if (this->enable_periapse_burns != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Enable periapse burns in ephemeris pegged flybys?" << std::endl;
            optionsFileStream << "enable_periapse_burns " << this->enable_periapse_burns << std::endl;
        }
    
        if (this->bounded_departure_date != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Bound the departure epoch?" << std::endl;
            optionsFileStream << "bounded_departure_date " << this->bounded_departure_date << std::endl;
        }
    
        if (this->timebounded != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#does the journey have time bounds?\n#0: unbounded\n#1: bounded flight time\n#2: bounded arrival date\n#3: bounded aggregate flight time" << std::endl;
            optionsFileStream << "timebounded " << this->timebounded << std::endl;
        }
    
        if (this->departure_date_bounds != std::vector<double>({ 0.0 * 86400.0, 0.0 * 86400.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey departure epoch bounds (MJD, two entries)" << std::endl;
            optionsFileStream << "departure_date_bounds";
            for (double entry : this->departure_date_bounds)
                optionsFileStream << " " << entry / 86400.0;
            optionsFileStream << std::endl;
        }
        
        if (this->wait_time_bounds != std::vector<double>({ 0.0 * 86400.0, 1000.0 * 86400.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey wait time bounds (days)" << std::endl;
            optionsFileStream << "wait_time_bounds";
            for (double entry : this->wait_time_bounds)
                optionsFileStream << " " << entry / 86400.0;
            optionsFileStream << std::endl;
        }
        
        if (this->flight_time_bounds != std::vector<double>({ 0.0 * 86400.0, 0.0 * 86400.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey flight time bounds (days)" << std::endl;
            optionsFileStream << "flight_time_bounds";
            for (double entry : this->flight_time_bounds)
                optionsFileStream << " " << entry / 86400.0;
            optionsFileStream << std::endl;
        }
        
        if (this->arrival_date_bounds != std::vector<double>({ 51544.5 * 86400.0, 60000.0 * 86400.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey arrival date bounds (MJD, two entries)" << std::endl;
            optionsFileStream << "arrival_date_bounds";
            for (double entry : this->arrival_date_bounds)
                optionsFileStream << " " << entry / 86400.0;
            optionsFileStream << std::endl;
        }
        
        if (this->departure_type != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey departure type\n#0: launch or direct insertion\n#1: depart from parking orbit (you can use this one in place of a launch vehicle model, and the departure burn will be done with the EDS motor)\n#2: free direct departure, i.e. do not burn to get the departure v_infinity (used for when operations about a small body are not modeled but the departure velocity is known)\n#3: flyby (only valid for successive journeys)\n#4: flyby with fixed v-infinity-out (only valid for successive journeys)\n#5: spiral-out from circular orbit (low-thrust missions only)\n#6: zero-turn flyby (for small bodies)" << std::endl;
            optionsFileStream << "departure_type " << this->departure_type << std::endl;
        }
    
        if (this->initial_impulse_bounds != std::vector<double>({ 0.0, 6.97}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#what are the bounds on the initial impulse for each journey in km/s\\\n#you can set a very high upper bound if you are using a launchy vehicle model - the optimizer will find the correct value" << std::endl;
            optionsFileStream << "initial_impulse_bounds";
            for (double entry : this->initial_impulse_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->force_free_point_direct_insertion_along_velocity_vector != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Force free point direct insertion burn to be along the inertial velocity vector?" << std::endl;
            optionsFileStream << "force_free_point_direct_insertion_along_velocity_vector " << this->force_free_point_direct_insertion_along_velocity_vector << std::endl;
        }
    
        if (this->departure_elements_vary_flag != std::vector<bool>({ 0, 0, 0, 0, 0, 0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#one entry for each element" << std::endl;
            optionsFileStream << "departure_elements_vary_flag";
            for (bool entry : this->departure_elements_vary_flag)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->departure_elements != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#cartesian state or SMA, ECC, INC, RAAN, AOP, TA" << std::endl;
            optionsFileStream << "departure_elements";
            for (double entry : this->departure_elements)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->departure_elements_bounds != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#bounds on elements or state components, two entries for each element" << std::endl;
            optionsFileStream << "departure_elements_bounds";
            for (double entry : this->departure_elements_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->departure_elements_reference_epoch != 51544.5 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Reference epoch (MJD) for journey departure elements" << std::endl;
            optionsFileStream << "departure_elements_reference_epoch " << this->departure_elements_reference_epoch / 86400.0 << std::endl;
        }
    
        if (this->departure_elements_state_representation != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)" << std::endl;
            optionsFileStream << "departure_elements_state_representation " << this->departure_elements_state_representation << std::endl;
        }
    
        if (this->departure_elements_frame != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#reference frame for journey departure elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)" << std::endl;
            optionsFileStream << "departure_elements_frame " << this->departure_elements_frame << std::endl;
        }
    
        if (this->AllowJourneyFreePointDepartureToPropagate != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Allow journey departure free point boundary to propagate (otherwise it is a fixed waypoint)" << std::endl;
            optionsFileStream << "AllowJourneyFreePointDepartureToPropagate " << this->AllowJourneyFreePointDepartureToPropagate << std::endl;
        }
    
        if (this->maximum_starting_mass_increment != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#upper bound on starting mass increment (negative number indicates mass drop) [kg]" << std::endl;
            optionsFileStream << "maximum_starting_mass_increment " << this->maximum_starting_mass_increment << std::endl;
        }
    
        if (this->minimum_starting_mass_increment != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#lower bound on starting mass increment (negative number indicates mass drop) [kg]" << std::endl;
            optionsFileStream << "minimum_starting_mass_increment " << this->minimum_starting_mass_increment << std::endl;
        }
    
        if (this->fixed_starting_mass_increment != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#starting mass increment (negative number indicates mass drop) [kg]" << std::endl;
            optionsFileStream << "fixed_starting_mass_increment " << this->fixed_starting_mass_increment << std::endl;
        }
    
        if (this->fixed_ending_mass_increment != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#ending mass increment (negative number indicates mass drop) [kg]" << std::endl;
            optionsFileStream << "fixed_ending_mass_increment " << this->fixed_ending_mass_increment << std::endl;
        }
    
        if (this->variable_mass_increment != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Vary initial mass increment?" << std::endl;
            optionsFileStream << "variable_mass_increment " << this->variable_mass_increment << std::endl;
        }
    
        if (this->constrain_initial_mass != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Constrain initial mass?" << std::endl;
            optionsFileStream << "constrain_initial_mass " << this->constrain_initial_mass << std::endl;
        }
    
        if (this->maximum_initial_mass != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#If initial mass for this journey is constrained, enter the constraint value here." << std::endl;
            optionsFileStream << "maximum_initial_mass " << this->maximum_initial_mass << std::endl;
        }
    
        if (this->departure_class != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey departure boundary class\n#0: Ephemeris-pegged (default EMTG)\n#1: Free point\n#2: Ephemeris-referenced\n#3: Periapse" << std::endl;
            optionsFileStream << "departure_class " << this->departure_class << std::endl;
        }
    
        if (this->departure_ellipsoid_axes != std::vector<double>({ 1e-08, 1e-08, 1e-08}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey departure ellipsoid axes (3)" << std::endl;
            optionsFileStream << "departure_ellipsoid_axes";
            for (double entry : this->departure_ellipsoid_axes)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->arrival_type != 3 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey arrival type\n#0: insertion into parking orbit (use chemical Isp)\n#1: rendezvous (use chemical Isp)\n#2: intercept with bounded V_infinity\n#3: low-thrust rendezvous (does not work if terminal phase is not low-thrust)\n#4: match final v-infinity vector\n#5: match final v-infinity vector (low-thrust)\n#6: capture spiral\n#7: momentum transfer (kinetic impactor)" << std::endl;
            optionsFileStream << "arrival_type " << this->arrival_type << std::endl;
        }
    
        if (this->arrival_elements_vary_flag != std::vector<bool>({ 0, 0, 0, 0, 0, 0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#one entry for each element" << std::endl;
            optionsFileStream << "arrival_elements_vary_flag";
            for (bool entry : this->arrival_elements_vary_flag)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->arrival_elements != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#cartesian state or SMA, ECC, INC, RAAN, AOP, TA" << std::endl;
            optionsFileStream << "arrival_elements";
            for (double entry : this->arrival_elements)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->arrival_elements_bounds != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#bounds on elements or state components, two entries for each element" << std::endl;
            optionsFileStream << "arrival_elements_bounds";
            for (double entry : this->arrival_elements_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->arrival_elements_reference_epoch != 51544.5 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Reference epoch (MJD) for journey arrival elements" << std::endl;
            optionsFileStream << "arrival_elements_reference_epoch " << this->arrival_elements_reference_epoch / 86400.0 << std::endl;
        }
    
        if (this->arrival_elements_state_representation != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)" << std::endl;
            optionsFileStream << "arrival_elements_state_representation " << this->arrival_elements_state_representation << std::endl;
        }
    
        if (this->arrival_elements_frame != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM, 9: ObjectReferenced)" << std::endl;
            optionsFileStream << "arrival_elements_frame " << this->arrival_elements_frame << std::endl;
        }
    
        if (this->AllowJourneyFreePointArrivalToPropagate != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Allow journey arrival free point boundary to propagate (otherwise it is a fixed waypoint)" << std::endl;
            optionsFileStream << "AllowJourneyFreePointArrivalToPropagate " << this->AllowJourneyFreePointArrivalToPropagate << std::endl;
        }
    
        if (this->final_velocity != std::vector<double>({ 0.0, 20.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Bounds on this journey's final velocity (in km/s)" << std::endl;
            optionsFileStream << "final_velocity";
            for (double entry : this->final_velocity)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->forced_terminal_coast != 0 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey forced terminal coast (in days)" << std::endl;
            optionsFileStream << "forced_terminal_coast " << this->forced_terminal_coast / 86400.0 << std::endl;
        }
    
        if (this->forced_initial_coast != 0 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey forced initial coast (in days)" << std::endl;
            optionsFileStream << "forced_initial_coast " << this->forced_initial_coast / 86400.0 << std::endl;
        }
    
        if (this->arrival_class != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey arrival boundary class\n#0: Ephemeris-pegged (default EMTG)\n#1: Free point\n#2: Ephemeris-referenced\n#3: Periapse" << std::endl;
            optionsFileStream << "arrival_class " << this->arrival_class << std::endl;
        }
    
        if (this->arrival_ellipsoid_axes != std::vector<double>({ 1e-08, 1e-08, 1e-08}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#journey arrival ellipsoid axes (3)" << std::endl;
            optionsFileStream << "arrival_ellipsoid_axes";
            for (double entry : this->arrival_ellipsoid_axes)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->zero_turn_flyby_distance != 1000 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#encounter distance (from center of object) for a zero-turn flyby (km)" << std::endl;
            optionsFileStream << "zero_turn_flyby_distance " << this->zero_turn_flyby_distance << std::endl;
        }
    
        if (this->terminal_intercept_flyby_distance != 1000 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#encounter distance (from center of object) for an ephemeris-pegged intercept (km)" << std::endl;
            optionsFileStream << "terminal_intercept_flyby_distance " << this->terminal_intercept_flyby_distance << std::endl;
        }
    
        if (this->escape_spiral_starting_radius != 6678 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Starting orbital radius for an Edelbaum escape spiral (km)" << std::endl;
            optionsFileStream << "escape_spiral_starting_radius " << this->escape_spiral_starting_radius << std::endl;
        }
    
        if (this->escape_spiral_final_radius != 6678 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Final orbit radius for an Edelbaum capture spiral (km)" << std::endl;
            optionsFileStream << "escape_spiral_final_radius " << this->escape_spiral_final_radius << std::endl;
        }
    
        if (this->capture_spiral_final_radius != 6678 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Final orbit radius for an Edelbaum capture spiral (km)" << std::endl;
            optionsFileStream << "capture_spiral_final_radius " << this->capture_spiral_final_radius << std::endl;
        }
    
        if (this->capture_spiral_starting_radius != 6678 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Starting orbital radius for an Edelbaum capture spiral (km)" << std::endl;
            optionsFileStream << "capture_spiral_starting_radius " << this->capture_spiral_starting_radius << std::endl;
        }
    
        if (this->FreePointArrival_print_target_spec != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Print a target spec for free point arrival at the end of this journey?" << std::endl;
            optionsFileStream << "FreePointArrival_print_target_spec " << this->FreePointArrival_print_target_spec << std::endl;
        }
    
        if (this->journey_end_deltav != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Journey-end delta-v (km/s)" << std::endl;
            optionsFileStream << "journey_end_deltav " << this->journey_end_deltav << std::endl;
        }
    
        if (this->journey_end_propulsion_system != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Propulsion system for journey-end maneuver\n#0: Monoprop chemical\n#1: Biprop chemical\n#2: Electric" << std::endl;
            optionsFileStream << "journey_end_propulsion_system " << this->journey_end_propulsion_system << std::endl;
        }
    
        optionsFileStream << "#Which bodies are used for third-body perturbation?\n#Expressed as indices in the Universe file" << std::endl;
        optionsFileStream << "perturbation_bodies";
        for (size_t entry : this->perturbation_bodies)
            optionsFileStream << " " << entry;
        optionsFileStream << std::endl;
        
        if (this->stage_after_departure != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Stage after departure?" << std::endl;
            optionsFileStream << "stage_after_departure " << this->stage_after_departure << std::endl;
        }
    
        if (this->stage_before_arrival != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Stage before arrival?" << std::endl;
            optionsFileStream << "stage_before_arrival " << this->stage_before_arrival << std::endl;
        }
    
        if (this->stage_after_arrival != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Stage after arrival?" << std::endl;
            optionsFileStream << "stage_after_arrival " << this->stage_after_arrival << std::endl;
        }
    
        if (this->freeze_decision_variables != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Freeze this journey's decision variables?" << std::endl;
            optionsFileStream << "freeze_decision_variables " << this->freeze_decision_variables << std::endl;
        }
    
        if (this->ephemeris_pegged_orbit_insertion_SMA != 6678 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#SMA (in km) for ephemeris pegged orbit insertion" << std::endl;
            optionsFileStream << "ephemeris_pegged_orbit_insertion_SMA " << this->ephemeris_pegged_orbit_insertion_SMA << std::endl;
        }
    
        if (this->ephemeris_pegged_orbit_insertion_ECC != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#ECC for ephemeris pegged orbit insertion" << std::endl;
            optionsFileStream << "ephemeris_pegged_orbit_insertion_ECC " << this->ephemeris_pegged_orbit_insertion_ECC << std::endl;
        }
    
        if (this->impact_momentum_enhancement_factor != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Impact momentum enhancement factor for planetary defense (also called beta)" << std::endl;
            optionsFileStream << "impact_momentum_enhancement_factor " << this->impact_momentum_enhancement_factor << std::endl;
        }
    
        if (this->perturb_drag != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Aerodynamic drag?" << std::endl;
            optionsFileStream << "perturb_drag " << this->perturb_drag << std::endl;
        }
    
        if (this->spacecraft_drag_area != 70 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#spacecraft area (for aerodynamic drag, in m^2)" << std::endl;
            optionsFileStream << "spacecraft_drag_area " << this->spacecraft_drag_area << std::endl;
        }
    
        if (this->coefficient_of_drag != 2.2 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#coefficient of drag, i.e. Cd (unitless)" << std::endl;
            optionsFileStream << "coefficient_of_drag " << this->coefficient_of_drag << std::endl;
        }
    
        if (this->AtmosphericDensityModelKey != "Exponential" || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Atmospheric density model" << std::endl;
            optionsFileStream << "AtmosphericDensityModelKey " << this->AtmosphericDensityModelKey << std::endl;
        }
    
        if (this->AtmosphericDensityModelDataFile != "DoesNotExist.emtg_densityopt" || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#File defining atmospheric density model" << std::endl;
            optionsFileStream << "AtmosphericDensityModelDataFile " << this->AtmosphericDensityModelDataFile << std::endl;
        }
    
        if (this->probe_separation_impulse != 1 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Probe separation impulse (Ns)" << std::endl;
            optionsFileStream << "probe_separation_impulse " << this->probe_separation_impulse << std::endl;
        }
    
        if (this->probe_mass != 100.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Probe mass (kg)" << std::endl;
            optionsFileStream << "probe_mass " << this->probe_mass << std::endl;
        }
    
        if (this->Probe_AEI_elements_vary_flag != std::vector<bool>({ 0, 0, 0, 0, 0, 0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#one entry for each element" << std::endl;
            optionsFileStream << "Probe_AEI_elements_vary_flag";
            for (bool entry : this->Probe_AEI_elements_vary_flag)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_AEI_elements != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#cartesian state or SMA, ECC, INC, RAAN, AOP, TA" << std::endl;
            optionsFileStream << "Probe_AEI_elements";
            for (double entry : this->Probe_AEI_elements)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_AEI_elements_bounds != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#bounds on elements or state components, two entries for each element" << std::endl;
            optionsFileStream << "Probe_AEI_elements_bounds";
            for (double entry : this->Probe_AEI_elements_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_AEI_elements_reference_epoch != 51544.5 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Reference epoch (MJD) for journey probe arrival elements" << std::endl;
            optionsFileStream << "Probe_AEI_elements_reference_epoch " << this->Probe_AEI_elements_reference_epoch / 86400.0 << std::endl;
        }
    
        if (this->Probe_AEI_elements_state_representation != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)" << std::endl;
            optionsFileStream << "Probe_AEI_elements_state_representation " << this->Probe_AEI_elements_state_representation << std::endl;
        }
    
        if (this->Probe_AEI_elements_frame != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)" << std::endl;
            optionsFileStream << "Probe_AEI_elements_frame " << this->Probe_AEI_elements_frame << std::endl;
        }
    
        if (this->Probe_End_elements_vary_flag != std::vector<bool>({ 0, 0, 0, 0, 0, 0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#one entry for each element" << std::endl;
            optionsFileStream << "Probe_End_elements_vary_flag";
            for (bool entry : this->Probe_End_elements_vary_flag)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_End_elements != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#cartesian state or SMA, ECC, INC, RAAN, AOP, TA" << std::endl;
            optionsFileStream << "Probe_End_elements";
            for (double entry : this->Probe_End_elements)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_End_elements_bounds != std::vector<double>({ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#bounds on elements or state components, two entries for each element" << std::endl;
            optionsFileStream << "Probe_End_elements_bounds";
            for (double entry : this->Probe_End_elements_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->Probe_End_elements_reference_epoch != 51544.5 * 86400.0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Reference epoch (MJD) for journey probe arrival elements" << std::endl;
            optionsFileStream << "Probe_End_elements_reference_epoch " << this->Probe_End_elements_reference_epoch / 86400.0 << std::endl;
        }
    
        if (this->Probe_End_elements_state_representation != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe arrival free point state representation (Cartesian, SphericalRADEC, SphericalAZFPA, COE)" << std::endl;
            optionsFileStream << "Probe_End_elements_state_representation " << this->Probe_End_elements_state_representation << std::endl;
        }
    
        if (this->Probe_End_elements_frame != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#reference frame for journey arrival elements (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar, 8: SAM)" << std::endl;
            optionsFileStream << "Probe_End_elements_frame " << this->Probe_End_elements_frame << std::endl;
        }
    
        if (this->ModelProbeSecondPhase != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "# or just final approach?" << std::endl;
            optionsFileStream << "ModelProbeSecondPhase " << this->ModelProbeSecondPhase << std::endl;
        }
    
        if (this->AllowJourneyProbeAEIToPropagate != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Allow probe AEI free point boundary to propagate (otherwise it is a fixed waypoint)" << std::endl;
            optionsFileStream << "AllowJourneyProbeAEIToPropagate " << this->AllowJourneyProbeAEIToPropagate << std::endl;
        }
    
        if (this->AllowJourneyProbeEndToPropagate != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Allow probe end free point boundary to propagate (otherwise it is a fixed waypoint)" << std::endl;
            optionsFileStream << "AllowJourneyProbeEndToPropagate " << this->AllowJourneyProbeEndToPropagate << std::endl;
        }
    
        if (this->probe_communication_distance_bounds != std::vector<double>({ 2000.0, 10000.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Probe-spacecraft communication distance constraint (km)" << std::endl;
            optionsFileStream << "probe_communication_distance_bounds";
            for (double entry : this->probe_communication_distance_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->perturb_drag_probe_separation_to_AEI != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Aerodynamic drag on probe from separation to AEI?" << std::endl;
            optionsFileStream << "perturb_drag_probe_separation_to_AEI " << this->perturb_drag_probe_separation_to_AEI << std::endl;
        }
    
        if (this->perturb_drag_probe_AEI_to_end != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Aerodynamic drag on probe from AEI to end of probe mission?" << std::endl;
            optionsFileStream << "perturb_drag_probe_AEI_to_end " << this->perturb_drag_probe_AEI_to_end << std::endl;
        }
    
        if (this->probe_drag_area_probe_separation_to_AEI != 70 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe area prior to AEI (for aerodynamic drag, in m^2)" << std::endl;
            optionsFileStream << "probe_drag_area_probe_separation_to_AEI " << this->probe_drag_area_probe_separation_to_AEI << std::endl;
        }
    
        if (this->probe_drag_area_probe_AEI_to_end != 70 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe area after AEI (for aerodynamic drag, in m^2)" << std::endl;
            optionsFileStream << "probe_drag_area_probe_AEI_to_end " << this->probe_drag_area_probe_AEI_to_end << std::endl;
        }
    
        if (this->probe_coefficient_of_drag_probe_separation_to_AEI != 2.2 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe coefficient of drag prior to AEI, i.e. Cd (unitless)" << std::endl;
            optionsFileStream << "probe_coefficient_of_drag_probe_separation_to_AEI " << this->probe_coefficient_of_drag_probe_separation_to_AEI << std::endl;
        }
    
        if (this->probe_coefficient_of_drag_probe_AEI_to_end != 2.2 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe coefficient of drag after AEI, i.e. Cd (unitless)" << std::endl;
            optionsFileStream << "probe_coefficient_of_drag_probe_AEI_to_end " << this->probe_coefficient_of_drag_probe_AEI_to_end << std::endl;
        }
    
        if (this->probe_AEI_velocity != std::vector<double>({ 0.0, 20.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Bounds on the probe's final velocity at AEI (in km/s)" << std::endl;
            optionsFileStream << "probe_AEI_velocity";
            for (double entry : this->probe_AEI_velocity)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->probe_end_velocity != std::vector<double>({ 0.0, 20.0, 0.0}) || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Bounds on the probe's final velocity at end of mission (in km/s)" << std::endl;
            optionsFileStream << "probe_end_velocity";
            for (double entry : this->probe_end_velocity)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->ProbeSeparationToAEI_MatchPointFraction != 0.5 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe separation to AEI match point fraction" << std::endl;
            optionsFileStream << "ProbeSeparationToAEI_MatchPointFraction " << this->ProbeSeparationToAEI_MatchPointFraction << std::endl;
        }
    
        if (this->ProbeSeparationToAEI_ForwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe separation to AEI forward integration step length (seconds)" << std::endl;
            optionsFileStream << "ProbeSeparationToAEI_ForwardIntegrationStepLength " << this->ProbeSeparationToAEI_ForwardIntegrationStepLength << std::endl;
        }
    
        if (this->ProbeSeparationToAEI_BackwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe separation to AEI backward integration step length (seconds)" << std::endl;
            optionsFileStream << "ProbeSeparationToAEI_BackwardIntegrationStepLength " << this->ProbeSeparationToAEI_BackwardIntegrationStepLength << std::endl;
        }
    
        if (this->ProbeAEI_to_end_MatchPointFraction != 0.5 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe AEI to end match point fraction" << std::endl;
            optionsFileStream << "ProbeAEI_to_end_MatchPointFraction " << this->ProbeAEI_to_end_MatchPointFraction << std::endl;
        }
    
        if (this->ProbeAEI_to_end_ForwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe AEI to end forward integration step length (seconds)" << std::endl;
            optionsFileStream << "ProbeAEI_to_end_ForwardIntegrationStepLength " << this->ProbeAEI_to_end_ForwardIntegrationStepLength << std::endl;
        }
    
        if (this->ProbeAEI_to_end_BackwardIntegrationStepLength != 86400 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#probe AEI to end backward integration step length (seconds)" << std::endl;
            optionsFileStream << "ProbeAEI_to_end_BackwardIntegrationStepLength " << this->ProbeAEI_to_end_BackwardIntegrationStepLength << std::endl;
        }
    
        if (this->print_this_journey_options_no_matter_what != 0 || writeAll || this->print_this_journey_options_no_matter_what)
        {
            optionsFileStream << "#Always print this journey's options to the .emtgopt file?" << std::endl;
            optionsFileStream << "print_this_journey_options_no_matter_what " << this->print_this_journey_options_no_matter_what << std::endl;
        }
    
        optionsFileStream << std::endl;
        optionsFileStream << "#Maneuver constraint code" << std::endl;
        optionsFileStream << "#Works for absolute and relative epochs and also magnitudes" << std::endl;
        optionsFileStream << "BEGIN_MANEUVER_CONSTRAINT_BLOCK" << std::endl;
        for (std::string& entry : this->ManeuverConstraintDefinitions)
        {
            optionsFileStream << entry << std::endl;
        }
        optionsFileStream << "END_MANEUVER_CONSTRAINT_BLOCK" << std::endl;
        optionsFileStream << std::endl;
            
        optionsFileStream << std::endl;
        optionsFileStream << "#Boundary constraint code" << std::endl;
        optionsFileStream << "BEGIN_BOUNDARY_CONSTRAINT_BLOCK" << std::endl;
        for (std::string& entry : this->BoundaryConstraintDefinitions)
        {
            optionsFileStream << entry << std::endl;
        }
        optionsFileStream << "END_BOUNDARY_CONSTRAINT_BLOCK" << std::endl;
        optionsFileStream << std::endl;

        optionsFileStream << std::endl;
        optionsFileStream << "#Phase distance constraint code" << std::endl;
        optionsFileStream << "BEGIN_PHASE_DISTANCE_CONSTRAINT_BLOCK" << std::endl;
        for (std::string& entry : this->PhaseDistanceConstraintDefinitions)
        {
            optionsFileStream << entry << std::endl;
        }
        optionsFileStream << "END_PHASE_DISTANCE_CONSTRAINT_BLOCK" << std::endl;
        optionsFileStream << std::endl;
        optionsFileStream << "#trial decision vector" << std::endl;
        optionsFileStream << "BEGIN_TRIALX" << std::endl;
        optionsFileStream.precision(20);
        for (std::tuple<std::string, double> entry : this->trialX)
            optionsFileStream << std::get<0>(entry) << " ," << std::get<1>(entry) << std::endl;
        optionsFileStream << "END_TRIALX" << std::endl;
        optionsFileStream << std::endl;
        optionsFileStream << "END_JOURNEY";
        optionsFileStream << std::endl;
        optionsFileStream << std::endl;
    }//end write()
    
}//close namespace EMTG
