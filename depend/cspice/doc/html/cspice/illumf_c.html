
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>illumf_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>illumf_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void illumf_c ( ConstSpiceChar        * method,
                   ConstSpiceChar        * target,
                   ConstSpiceChar        * ilusrc,
                   SpiceDouble             et,
                   ConstSpiceChar        * fixref,
                   ConstSpiceChar        * abcorr,
                   ConstSpiceChar        * obsrvr,
                   ConstSpiceDouble        spoint [3],
                   SpiceDouble           * trgepc,
                   SpiceDouble             srfvec [3],
                   SpiceDouble           * phase,
                   SpiceDouble           * incdnc,
                   SpiceDouble           * emissn,
                   SpiceBoolean          * visibl,
                   SpiceBoolean          * lit       )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Compute the illumination angles---phase, incidence, and
   emission---at a specified point on a target body. Return logical
   flags indicating whether the surface point is visible from
   the observer's position and whether the surface point is
   illuminated.

   The target body's surface is represented using topographic data
   provided by DSK files, or by a reference ellipsoid.

   The illumination source is a specified ephemeris object.
  </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/dsk.html">DSK</a> 
   <a href="../req/frames.html">FRAMES</a> 
   <a href="../req/naif_ids.html">NAIF_IDS</a> 
   <a href="../req/pck.html">PCK</a> 
   <a href="../req/spk.html">SPK</a> 
   <a href="../req/time.html">TIME</a> 
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   ANGLES 
   GEOMETRY 
   ILLUMINATION 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description 
   --------  ---  -------------------------------------------------- 
   method     I   Computation method. 
   target     I   Name of target body. 
   ilusrc     I   Name of illumination source. 
   et         I   Epoch in TDB seconds past J2000 TDB. 
   fixref     I   Body-fixed, body-centered target body frame. 
   abcorr     I   Aberration correction flag.
   obsrvr     I   Name of observing body. 
   spoint     I   Body-fixed coordinates of a target surface point. 
   trgepc     O   Target surface point epoch. 
   srfvec     O   Vector from observer to target surface point. 
   phase      O   Phase angle at the surface point. 
   incdnc     O   Source incidence angle at the surface point. 
   emissn     O   Emission angle at the surface point. 
   visibl     O   Visibility flag (SPICETRUE == visible).
   lit        O   Illumination flag (SPICETRUE == illuminated).
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   method      is a short string providing parameters defining 
               the computation method to be used. In the syntax 
               descriptions below, items delimited by brackets 
               are optional. 
               
               `method' may be assigned the following values:    
 
                  &quot;ELLIPSOID&quot; 
  
                     The illumination angle computation uses a 
                     triaxial ellipsoid to model the surface of the 
                     target body. The ellipsoid's radii must be 
                     available in the kernel pool. 
 
 
                  &quot;DSK/UNPRIORITIZED[/SURFACES = &lt;surface list&gt;]&quot; 
 
                     The illumination angle computation uses 
                     topographic data to model the surface of the 
                     target body. These data must be provided by 
                     loaded DSK files. 
 
                     The surface list specification is optional. The 
                     syntax of the list is 
 
                        &lt;surface 1&gt; [, &lt;surface 2&gt;...] 
 
                     If present, it indicates that data only for the 
                     listed surfaces are to be used; however, data 
                     need not be available for all surfaces in the 
                     list. If absent, loaded DSK data for any surface 
                     associated with the target body are used. 
 
                     The surface list may contain surface names or 
                     surface ID codes. Names containing blanks must 
                     be delimited by escaped double quotes, for example 
 
                        &quot;SURFACES = \&quot;Mars MEGDR 128 PIXEL/DEG\&quot;&quot;
                                        
                     If multiple surfaces are specified, their names 
                     or IDs must be separated by commas. 
 
                     See the Particulars section below for details 
                     concerning use of DSK data. 
 
 
               Neither case nor white space are significant in 
               `method', except within double-quoted strings 
               representing surface names. For example, the string 
               &quot; eLLipsoid &quot; is valid.
 
               Within double-quoted strings representing surface names,
               blank characters are significant, but multiple
               consecutive blanks are considered equivalent to a single
               blank. Case is not significant. So
 
                  \&quot;Mars MEGDR 128 PIXEL/DEG\&quot; 
 
               is equivalent to  
 
                  \&quot; mars megdr  128  pixel/deg \&quot;
 
               but not to 
 
                  \&quot;MARS MEGDR128PIXEL/DEG\&quot; 
 
 
   target      is the name of the target body. `target' is 
               case-insensitive, and leading and trailing blanks in 
               `target' are not significant. Optionally, you may 
               supply a string containing the integer ID code for 
               the object. For example both &quot;MOON&quot; and &quot;301&quot; are 
               legitimate strings that indicate the moon is the 
               target body. 
 
 
   ilusrc      is the name of the illumination source. This source 
               may be any ephemeris object. Case, blanks, and 
               numeric values are treated in the same way as for the 
               input `target'. 
                
 
   et          is the epoch, expressed as seconds past J2000 TDB, 
               for which the apparent illumination angles at the 
               specified surface point on the target body, as seen 
               from the observing body, are to be computed. 
 
 
   fixref      is the name of the body-fixed, body-centered 
               reference frame associated with the target body. The 
               input surface point `spoint' and the output vector 
               `srfvec' are expressed relative to this reference 
               frame. The string `fixref' is case-insensitive, and 
               leading and trailing blanks in `fixref' are not 
               significant. 
 
 
   abcorr      is the aberration correction to be used in computing 
               the position and orientation of the target body and 
               the location of the illumination source. 
        
               For remote sensing applications, where the apparent 
               illumination angles seen by the observer are desired, 
               normally either of the corrections  
             
                  &quot;LT+S&quot;  
                  &quot;CN+S&quot; 
    
               should be used. These and the other supported options 
               are described below. `abcorr' may be any of the  
               following: 
 
                  &quot;NONE&quot;     No aberration correction. 
 
               Let `lt' represent the one-way light time between the
               observer and the input surface point `spoint' (note: NOT
               between the observer and the target body's center). The
               following values of `abcorr' apply to the &quot;reception&quot;
               case in which photons depart from `spoint' at the
               light-time corrected epoch et-lt and *arrive* at the
               observer's location at `et':

                  &quot;LT&quot;       Correct both the position of `spoint' as
                             seen by the observer, and the position of
                             the illumination source as seen by the
                             target, for light time.
 
                  &quot;LT+S&quot;     Correct both the position of `spoint' as
                             seen by the observer, and the position of
                             the illumination source as seen by the
                             target, for light time and stellar
                             aberration.
 
                  &quot;CN&quot;       Converged Newtonian light time correction.
                             In solving the light time equations for
                             `spoint' and the illumination source, the
                             &quot;CN&quot; correction iterates until the
                             solution converges.
 
                  &quot;CN+S&quot;     Converged Newtonian light time and stellar
                             aberration corrections. This option
                             produces a solution that is at least as
                             accurate at that obtainable with the
                             &quot;LT+S&quot; option. Whether the &quot;CN+S&quot; solution
                             is substantially more accurate depends on
                             the geometry of the participating objects
                             and on the accuracy of the input data. In
                             all cases this routine will execute more
                             slowly when a converged solution is
                             computed.

               The following values of `abcorr' apply to the 
               &quot;transmission&quot; case in which photons *arrive* at 
               `spoint' at the light-time corrected epoch et+lt and 
               *depart* from the observer's location at `et': 
 
                  &quot;XLT&quot;      &quot;Transmission&quot; case: correct for 
                             one-way light time using a Newtonian 
                             formulation. This correction yields the 
                             illumination angles at the moment that 
                             `spoint' receives photons emitted from the 
                             observer's location at `et'.  
 
                             The light time correction uses an 
                             iterative solution of the light time 
                             equation. The solution invoked by the 
                             &quot;XLT&quot; option uses one iteration. 
 
                             Both the target position as seen by the 
                             observer, and rotation of the target 
                             body, are corrected for light time. 
 
                  &quot;XLT+S&quot;    &quot;Transmission&quot; case: correct for 
                             one-way light time and stellar 
                             aberration using a Newtonian 
                             formulation  This option modifies the 
                             angles obtained with the &quot;XLT&quot; option 
                             to account for the observer's and 
                             target's velocities relative to the 
                             solar system barycenter (the latter 
                             velocity is used in computing the 
                             direction to the apparent illumination 
                             source). 
 
                  &quot;XCN&quot;      Converged Newtonian light time 
                             correction. This is the same as XLT 
                             correction but with further iterations 
                             to a converged Newtonian light time 
                             solution.  
 
                  &quot;XCN+S&quot;    &quot;Transmission&quot; case: converged 
                             Newtonian light time and stellar 
                             aberration corrections. This option 
                             produces a solution that is at least as 
                             accurate at that obtainable with the 
                             &quot;XLT+S&quot; option. Whether the &quot;XCN+S&quot; 
                             solution is substantially more accurate 
                             depends on the geometry of the 
                             participating objects and on the 
                             accuracy of the input data. In all 
                             cases this routine will execute more 
                             slowly when a converged solution is 
                             computed. 


               Neither case nor white space are significant in 
               `abcorr'. For example, the string  
 
                 &quot;Lt + s&quot; 
 
               is valid. 
                              
 
   obsrvr      is the name of the observing body. The observing body 
               is an ephemeris object: it typically is a spacecraft, 
               the earth, or a surface point on the earth. `obsrvr' is 
               case-insensitive, and leading and trailing blanks in 
               `obsrvr' are not significant. Optionally, you may 
               supply a string containing the integer ID code for 
               the object. For example both &quot;MOON&quot; and &quot;301&quot; are 
               legitimate strings that indicate the moon is the 
               observer. 
 
               `obsrvr' may be not be identical to `target'. 
 
 
   spoint      is a surface point on the target body, expressed in 
               Cartesian coordinates, relative to the body-fixed 
               target frame designated by `fixref'. 
 
               `spoint' need not be visible from the observer's 
               location at the epoch `et'. 
 
               The components of `spoint' have units of km. 
 
 </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
 
   trgepc      is the &quot;target surface point epoch.&quot; `trgepc' is defined
               as follows: letting `lt' be the one-way light time
               between the observer and the input surface point
               `spoint', `trgepc' is either the epoch et-lt or `et'
               depending on whether the requested aberration correction
               is, respectively, for received radiation or omitted.
               `lt' is computed using the method indicated by `abcorr'.
 
               `trgepc' is expressed as TDB seconds past J2000 TDB.
 
 
   srfvec      is the vector from the observer's position at `et' to
               the aberration-corrected (or optionally, geometric)
               position of `spoint', where the aberration corrections
               are specified by `abcorr'. `srfvec' is expressed in the
               target body-fixed reference frame designated by
               `fixref', evaluated at `trgepc'.
 
               The components of `srfvec' are given in units of km. 
 
               One can use the CSPICE function <a href="vnorm_c.html">vnorm_c</a> to obtain the 
               distance between the observer and `spoint': 
 
                  dist = <a href="vnorm_c.html">vnorm_c</a> ( srfvec );
 
               The observer's position `obspos', relative to the 
               target body's center, where the center's position is 
               corrected for aberration effects as indicated by 
               `abcorr', can be computed via the call: 
 
                  <a href="vsub_c.html">vsub_c</a> ( spoint, srfvec, obspos );

               To transform the vector `srfvec' from a reference frame
               `fixref' at time `trgepc' to a time-dependent reference
               frame `ref' at time `et', the routine <a href="pxfrm2_c.html">pxfrm2_c</a> should be
               called. Let `xform' be the 3x3 matrix representing the
               rotation from the reference frame `fixref' at time
               `trgepc' to the reference frame `ref' at time `et'. Then
               `srfvec' can be transformed to the result `refvec' as
               follows:
 
                  <a href="pxfrm2_c.html">pxfrm2_c</a> ( fixref, ref,    trgepc, et, xform );
                  <a href="mxv_c.html">mxv_c</a>    ( xform,  srfvec, refvec            );

 
   phase       is the phase angle at `spoint', as seen from `obsrvr' at
               time `et'. This is the angle between the spoint-obsrvr
               vector and the spoint-illumination source vector. Units
               are radians. The range of `phase' is [0, pi]. See
               Particulars below for a detailed discussion of the
               definition.
 

   incdnc      is the illumination source incidence angle at `spoint',
               as seen from `obsrvr' at time `et'. This is the angle
               between the surface normal vector at `spoint' and the
               spoint-illumination source vector. Units are radians.
               The range of `incdnc' is [0, pi]. See Particulars below
               for a detailed discussion of the definition.
 
 
   emissn      is the emission angle at `spoint', as seen from `obsrvr'
               at time `et'. This is the angle between the surface
               normal vector at `spoint' and the spoint-observer
               vector. Units are radians. The range of `emissn' is 
               [0, pi]. See Particulars below for a detailed discussion 
               of the definition.


   visibl      is a logical flag indicating whether the surface
               point is visible to the observer. `visibl' takes into
               account whether the target surface occults `spoint',
               regardless of the emission angle at `spoint'. `visibl' is
               returned with the value SPICETRUE if `spoint' is visible;
               otherwise it is SPICEFALSE.


   lit         is a logical flag indicating whether the surface
               point is illuminated; the point is considered to be
               illuminated if the vector from the point to the
               center of the illumination source doesn't intersect
               the target surface. `lit' takes into account whether
               the target surface casts a shadow on `spoint',
               regardless of the incidence angle at `spoint'. `lit' is
               returned with the value SPICETRUE if `spoint' is
               illuminated; otherwise it is SPICEFALSE.
  
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
 
   1)  If the specified aberration correction is relativistic or 
       calls for stellar aberration but not light time correction, 
       the error SPICE(NOTSUPPORTED) is signaled. If the specified 
       aberration correction is any other unrecognized value, the 
       error will be diagnosed and signaled by a routine in the call 
       tree of this routine. 
 
   2)  If any of the target, observer, or illumination source  
       input strings cannot be converted to an integer ID code, the 
       error SPICE(IDCODENOTFOUND) is signaled. 
 
   3)  If `obsrvr' and `target' map to the same NAIF integer ID code, 
       the error SPICE(BODIESNOTDISTINCT) is signaled. 
 
   4)  If the input target body-fixed frame `fixref' is not 
       recognized, the error SPICE(NOFRAME) is signaled. A frame 
       name may fail to be recognized because a required frame 
       specification kernel has not been loaded; another cause is a 
       misspelling of the frame name. 
 
   5)  If the input frame `fixref' is not centered at the target body, 
       the error SPICE(INVALIDFRAME) is signaled. 
 
   6)  If the input argument `METHOD' is not recognized, the error 
       SPICE(INVALIDMETHOD) is signaled. 
 
   7)  If insufficient ephemeris data have been loaded prior to 
       calling <b>illumf_c</b>, the error will be diagnosed and signaled by a 
       routine in the call tree of this routine. Note that when 
       light time correction is used, sufficient ephemeris data must 
       be available to propagate the states of observer, target, and 
       the illumination source to the solar system barycenter. 
 
   8)  If the computation method specifies an ellipsoidal target 
       shape and triaxial radii of the target body have not been 
       loaded into the kernel pool prior to calling <b>illumf_c</b>, the 
       error will be diagnosed and signaled by a routine in the call 
       tree of this routine. 
 
   9)  The target must be an extended body: if any of the radii of 
       the target body are non-positive, the error will be 
       diagnosed and signaled by routines in the call tree of this 
       routine. 
 
   10) If PCK or CK data specifying the target body-fixed frame 
       orientation have not been loaded prior to calling <b>illumf_c</b>, 
       the error will be diagnosed and signaled by a routine in the 
       call tree of this routine. 
 
   11) If ``method'' specifies that the target surface is represented by 
       DSK data, and no DSK files are loaded for the specified 
       target, the error is signaled by a routine in the call tree 
       of this routine. 
        
   12) If `method' specifies that the target surface is represented 
       by DSK data, and data representing the portion of the surface 
       on which `spoint' is located are not available, an error will  
       be signaled by a routine in the call tree of this routine. 
 
   13) If `method' specifies that the target surface is represented 
       by DSK data, `spoint' must lie on the target surface, not above 
       or below it. A small tolerance is used to allow for round-off 
       error in the calculation determining whether `spoint' is on the 
       surface. If, in the DSK case, `spoint' is too far from the 
       surface, an error will be signaled by a routine in the call 
       tree of this routine. 
 
       If the surface is represented by a triaxial ellipsoid, `spoint' 
       is not required to be close to the ellipsoid; however, the 
       results computed by this routine will be unreliable if `spoint' 
       is too far from the ellipsoid. 
 </PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   Appropriate kernels must be loaded by the calling program before 
   this routine is called. 
 
   The following data are required: 
 
      - SPK data: ephemeris data for target, observer, and the 
        illumination source must be loaded. If aberration 
        corrections are used, the states of target, observer, and 
        the illumination source relative to the solar system 
        barycenter must be calculable from the available ephemeris 
        data. Typically ephemeris data are made available by loading 
        one or more SPK files via <a href="furnsh_c.html">furnsh_c</a>. 
 
      - Target body orientation data: these may be provided in a text or 
        binary PCK file. In some cases, target body orientation may
        be provided by one more more CK files. In either case, data
        are made available by loading the files via <a href="furnsh_c.html">furnsh_c</a>.
 
      - Shape data for the target body: 
               
          PCK data:  
 
             If the target body shape is modeled as an ellipsoid, 
             triaxial radii for the target body must be loaded into 
             the kernel pool. Typically this is done by loading a 
             text PCK file via <a href="furnsh_c.html">furnsh_c</a>. 
 
             Triaxial radii are also needed if the target shape is 
             modeled by DSK data, and the DSK NADIR method is 
             selected. 
 
          DSK data:  
 
             If the target shape is modeled by DSK data, DSK files 
             containing topographic data for the target body must be 
             loaded. If a surface list is specified, data for at 
             least one of the listed surfaces must be loaded. DSK
             files are loaded via <a href="furnsh_c.html">furnsh_c</a>.
 
   The following data may be required: 
 
      - Frame data: if a frame definition is required to convert the 
        observer and target states to the body-fixed frame of the 
        target, that definition must be available in the kernel 
        pool. Typically the definition is supplied by loading a 
        frame kernel via <a href="furnsh_c.html">furnsh_c</a>. 
 
      - Surface name-ID associations: if surface names are specified 
        in `method', the association of these names with their 
        corresponding surface ID codes must be established by  
        assignments of the kernel variables 
 
           NAIF_SURFACE_NAME 
           NAIF_SURFACE_CODE 
           NAIF_SURFACE_BODY 
 
        Normally these associations are made by loading a text 
        kernel containing the necessary assignments. An example 
        of such assignments is 
 
           NAIF_SURFACE_NAME += 'Mars MEGDR 128 PIXEL/DEG' 
           NAIF_SURFACE_CODE += 1   
           NAIF_SURFACE_BODY += 499                   

      - SCLK data: if the target body's orientation is provided by
        CK files, an associated SCLK kernel must be loaded.


   In all cases, kernel data are normally loaded once per program 
   run, NOT every time this routine is called. 
 
  </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   CSPICE contains four routines that compute illumination angles: 
    
      <b>illumf_c</b> (this routine) 

      <a href="illumg_c.html">illumg_c</a> (same as this routine, except that illumination 
                and visibility flags are not returned) 
                
      <a href="ilumin_c.html">ilumin_c</a> (same as <a href="illumg_c.html">illumg_c</a>, except that the sun is fixed 
                as the illumination source) 
 
      <a href="illum_c.html">illum_c</a>  (deprecated) 
    

   <b>illumf_c</b> is the most capable of the set. 
 
    
   Illumination angles 
   =================== 
 
   The term &quot;illumination angles&quot; refers to the following set of 
   angles: 
 
 
      phase angle              Angle between the vectors from the 
                               surface point to the observer and 
                               from the surface point to the  
                               illumination source. 
 
      incidence angle          Angle between the surface normal at 
                               the specified surface point and the 
                               vector from the surface point to the 
                               illumination source. 
 
      emission angle           Angle between the surface normal at 
                               the specified surface point and the 
                               vector from the surface point to the 
                               observer. 
  
   The diagram below illustrates the geometric relationships 
   defining these angles. The labels for the incidence, emission, 
   and phase angles are &quot;inc.&quot;, &quot;e.&quot;, and &quot;phase&quot;. 
 
 
                                                    * 
                                            illumination source 
 
                  surface normal vector 
                            ._                 _. 
                            |\                 /|  illumination  
                              \    phase      /    source vector 
                               \   .    .    / 
                               .            . 
                                 \   ___   / 
                            .     \/     \/ 
                                  _\ inc./ 
                           .    /   \   / 
                           .   |  e. \ / 
       *             &lt;--------------- *  surface point on 
    viewing            vector            target body 
    location           to viewing 
    (observer)         location 
 
 
   Note that if the target-observer vector, the target normal vector 
   at the surface point, and the target-illumination source vector 
   are coplanar, then phase is the sum of the incidence and emission 
   angles. This rarely occurs; usually 
 
      phase angle  &lt;  incidence angle + emission angle 
 
   All of the above angles can be computed using light time 
   corrections, light time and stellar aberration corrections, or no 
   aberration corrections. In order to describe apparent geometry as 
   observed by a remote sensing instrument, both light time and 
   stellar aberration corrections should be used. 
    
   The way aberration corrections are applied by this routine 
   is described below. 
 
      Light time corrections 
      ====================== 
 
         Observer-target surface point vector 
         ------------------------------------ 
 
         Let `et' be the epoch at which an observation or remote 
         sensing measurement is made, and let et-lt (&quot;lt&quot; stands 
         for &quot;light time&quot;) be the epoch at which the photons 
         received at `et' were emitted from the surface point `spoint'. 
         Note that the light time between the surface point and 
         observer will generally differ from the light time between 
         the target body's center and the observer. 
 
 
         Target body's orientation 
         ------------------------- 
 
         Using the definitions of `et' and `lt' above, the target body's 
         orientation at et-lt is used. The surface normal is 
         dependent on the target body's orientation, so the body's 
         orientation model must be evaluated for the correct epoch. 
 
 
         Target body -- illumination source vector 
         ----------------------------------------- 
 
         The surface features on the target body near `spoint' will 
         appear in a measurement made at `et' as they were at et-lt. 
         In particular, lighting on the target body is dependent on 
         the apparent location of the illumination source as seen 
         from the target body at et-lt. So, a second light time 
         correction is used to compute the position of the 
         illumination source relative to the surface point. 
 
 
      Stellar aberration corrections 
      ============================== 
 
      Stellar aberration corrections are applied only if 
      light time corrections are applied as well. 
 
         Observer-target surface point body vector 
         ----------------------------------------- 
 
         When stellar aberration correction is performed, the 
         direction vector `srfvec' is adjusted so as to point to the 
         apparent position of `spoint': considering `spoint' to be an 
         ephemeris object, `srfvec' points from the observer's 
         position at `et' to the light time and stellar aberration 
         corrected position of `spoint'. 
 
         Target body-illumination source vector 
         -------------------------------------- 
 
         The target body-illumination source vector is the apparent 
         position of the illumination source, corrected for light 
         time and stellar aberration, as seen from the target body 
         at time et-lt. 
 
 
   Using DSK data 
   ============== 
 
      DSK loading and unloading 
      ------------------------- 
 
      DSK files providing data used by this routine are loaded by
      calling <a href="furnsh_c.html">furnsh_c</a> and can be unloaded by calling <a href="unload_c.html">unload_c</a> or
      <a href="kclear_c.html">kclear_c</a>. See the documentation of <a href="furnsh_c.html">furnsh_c</a> for limits on numbers
      of loaded DSK files.
 
      For run-time efficiency, it's desirable to avoid frequent 
      loading and unloading of DSK files. When there is a reason to 
      use multiple versions of data for a given target body---for 
      example, if topographic data at varying resolutions are to be 
      used---the surface list can be used to select DSK data to be 
      used for a given computation. It is not necessary to unload 
      the data that are not to be used. This recommendation presumes 
      that DSKs containing different versions of surface data for a 
      given body have different surface ID codes. 
 
 
      DSK data priority 
      ----------------- 
 
      A DSK coverage overlap occurs when two segments in loaded DSK 
      files cover part or all of the same domain---for example, a 
      given longitude-latitude rectangle---and when the time 
      intervals of the segments overlap as well. 
 
      When DSK data selection is prioritized, in case of a coverage 
      overlap, if the two competing segments are in different DSK 
      files, the segment in the DSK file loaded last takes 
      precedence. If the two segments are in the same file, the 
      segment located closer to the end of the file takes 
      precedence. 
 
      When DSK data selection is unprioritized, data from competing 
      segments are combined. For example, if two competing segments 
      both represent a surface as a set of triangular plates, the 
      union of those sets of plates is considered to represent the 
      surface.  
 
      Currently only unprioritized data selection is supported. 
      Because prioritized data selection may be the default behavior 
      in a later version of the routine, the UNPRIORITIZED keyword is 
      required in the `method' argument. 
 
       
      Syntax of the `method' input argument 
      ----------------------------------- 
 
      The keywords and surface list in the `method' argument 
      are called &quot;clauses.&quot; The clauses may appear in any 
      order, for example 
 
         &quot;DSK/&lt;surface list&gt;/UNPRIORITIZED&quot;
         &quot;DSK/UNPRIORITIZED/&lt;surface list&gt;&quot;
         &quot;UNPRIORITIZED/&lt;surface list&gt;/DSK&quot;
 
      The simplest form of the `method' argument specifying use of 
      DSK data is one that lacks a surface list, for example: 
 
         &quot;DSK/UNPRIORITIZED&quot; 
 
      For applications in which all loaded DSK data for the target 
      body are for a single surface, and there are no competing 
      segments, the above string suffices. This is expected to be 
      the usual case. 
 
      When, for the specified target body, there are loaded DSK 
      files providing data for multiple surfaces for that body, the 
      surfaces to be used by this routine for a given call must be 
      specified in a surface list, unless data from all of the 
      surfaces are to be used together. 
 
      The surface list consists of the string 
 
         &quot;SURFACES =&quot;
 
      followed by a comma-separated list of one or more surface 
      identifiers. The identifiers may be names or integer codes in 
      string format. For example, suppose we have the surface 
      names and corresponding ID codes shown below: 
 
         Surface Name                              ID code 
         ------------                              ------- 
         &quot;Mars MEGDR 128 PIXEL/DEG&quot;                1 
         &quot;Mars MEGDR 64 PIXEL/DEG&quot;                 2 
         &quot;Mars_MRO_HIRISE&quot;                         3 
 
      If data for all of the above surfaces are loaded, then 
      data for surface 1 can be specified by either 
 
         &quot;SURFACES = 1&quot; 
 
      or 
 
         &quot;SURFACES = &quot;\&quot;Mars MEGDR 128 PIXEL/DEG\&quot;&quot; 
 
      Escaped double quotes are used to delimit the surface name
      because it contains blank characters.
          
      To use data for surfaces 2 and 3 together, any 
      of the following surface lists could be used: 
 
         &quot;SURFACES = 2, 3&quot; 
 
         &quot;SURFACES = \&quot;Mars MEGDR  64 PIXEL/DEG\&quot;, 3&quot; 
 
         &quot;SURFACES = 2, Mars_MRO_HIRISE&quot; 
 
         &quot;SURFACES = \&quot;Mars MEGDR 64 PIXEL/DEG\&quot;, Mars_MRO_HIRISE&quot; 
        
      An example of a `method' argument that could be constructed 
      using one of the surface lists above is 

         &quot;DSK/UNPRIORITIZED/SURFACES = \&quot;Mars MEGDR 64 PIXEL/DEG\&quot;, 3&quot;
  
 
      Aberration corrections using DSK data 
      ------------------------------------- 
 
      For irregularly shaped target bodies, the distance between the 
      observer and the nearest surface intercept need not be a 
      continuous function of time; hence the one-way light time 
      between the intercept and the observer may be discontinuous as 
      well. In such cases, the computed light time, which is found 
      using an iterative algorithm, may converge slowly or not at all. 
      In all cases, the light time computation will terminate, but 
      the result may be less accurate than expected. 
 
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
   The numerical results shown for this example may differ across 
   platforms. The results depend on the SPICE kernels used as 
   input, the compiler and supporting libraries, and the machine  
   specific arithmetic implementation.  
 
   1) Find the phase, solar incidence, and emission angles at the 
      sub-solar and sub-spacecraft points on Mars as seen from the Mars
      Global Surveyor spacecraft at a specified UTC time.
 
      Use both an ellipsoidal Mars shape model and topographic data
      provided by a DSK file.  For both surface points, use the &quot;near
      point&quot; and &quot;nadir&quot; definitions for ellipsoidal and DSK shape
      models, respectively.
 
      Use converged Newtonian light time and stellar aberration
      corrections.

      The topographic model is based on data from the MGS MOLA DEM 
      megr90n000cb, which has a resolution of 4 pixels/degree. A 
      triangular plate model was produced by computing a 720 x 1440 
      grid of interpolated heights from this DEM, then tessellating 
      the height grid. The plate model is stored in a type 2 segment 
      in the referenced DSK file. 

      Use the meta-kernel shown below to load the required SPICE 
      kernels. 
 
         KPL/MK 
 
         File: illumf_ex1.tm 
 
         This meta-kernel is intended to support operation of SPICE 
         example programs. The kernels shown here should not be 
         assumed to contain adequate or correct versions of data 
         required by SPICE-based user applications. 
 
         In order for an application to use this meta-kernel, the 
         kernels referenced here must be present in the user's 
         current working directory. 
 
         The names and contents of the kernels referenced 
         by this meta-kernel are as follows: 
 
            File name                        Contents 
            ---------                        -------- 
            de430.bsp                        Planetary ephemeris 
            mar097.bsp                       Mars satellite ephemeris 
            pck00010.tpc                     Planet orientation and 
                                             radii 
            naif0011.tls                     Leapseconds 
            mgs_ext12_ipng_mgs95j.bsp        MGS ephemeris 
            megr90n000cb_plate.bds           Plate model based on 
                                             MEGDR DEM, resolution 
                                             4 pixels/degree. 
 
         \begindata 
 
            KERNELS_TO_LOAD = ( 'de430.bsp', 
                                'mar097.bsp', 
                                'pck00010.tpc', 
                                'naif0011.tls', 
                                'mgs_ext12_ipng_mgs95j.bsp', 
                                'megr90n000cb_plate.bds'      ) 
         \begintext 
 
 
 
      Example code begins here. 

         /.
            Program illumf_ex1
         ./

         #include &lt;stdio.h&gt;
         #include &quot;SpiceUsr.h&quot;

         int main()
         {

            /.
            Local constants 
            ./
            #define                 META   &quot;illumf_ex1.tm&quot;
            #define                 MTHLEN 81
            #define                 NMETH  2

            /.
            Local variables 
            ./
            SpiceBoolean            ssclit;
            SpiceBoolean            sscvis;
            SpiceBoolean            ssllit;
            SpiceBoolean            sslvis;

            SpiceChar             * abcorr;
            SpiceChar             * fixref;
            SpiceChar               ilumth [NMETH][MTHLEN] =
               {&quot;Ellipsoid&quot;, &quot;DSK/Unprioritized&quot; };

            SpiceChar             * ilusrc;
            SpiceChar             * target;
            SpiceChar             * obsrvr;
            SpiceChar               submth [NMETH][MTHLEN] =
               {&quot;Near Point/Ellipsoid&quot;, &quot;DSK/Nadir/Unprioritized&quot; };

            SpiceChar             * utc;

            SpiceDouble             et;
            SpiceDouble             srfvec [3];
            SpiceDouble             sscemi;
            SpiceDouble             sscphs;
            SpiceDouble             sscpt  [3];
            SpiceDouble             sscsol;
            SpiceDouble             sslemi;
            SpiceDouble             sslphs;
            SpiceDouble             sslsol;
            SpiceDouble             ssolpt [3];
            SpiceDouble             trgepc;

            SpiceInt                i;


            /.
            Load kernel files. 
            ./
            <a href="furnsh_c.html">furnsh_c</a> ( META );

            /.
            Convert the UTC request time string to seconds past 
            J2000 TDB. 
            ./
            utc = &quot;2003 OCT 13 06:00:00 UTC&quot;;

            <a href="str2et_c.html">str2et_c</a> ( utc, &amp;et );

            printf ( &quot;\n&quot;
                     &quot;UTC epoch is %s\n&quot;, utc );


            /.
            Assign observer, target, and illumination source
            names. The acronym MGS indicates Mars Global 
            Surveyor. See NAIF_IDS for a list of names 
            recognized by SPICE. 

            Also set the target body-fixed frame and
            the aberration correction flag.  
            ./

            target = &quot;Mars&quot;;
            obsrvr = &quot;MGS&quot;;
            ilusrc = &quot;Sun&quot;;
            fixref = &quot;IAU_MARS&quot;;
            abcorr = &quot;CN+S&quot;;

            for ( i = 0;  i &lt; NMETH;  i++ )
            {
               /.
               Find the sub-solar point on Mars as 
               seen from the MGS spacecraft at `et'. Use the 
               &quot;near point&quot; style of sub-point definition 
               when the shape model is an ellipsoid, and use 
               the &quot;nadir&quot; style when the shape model is 
               provided by DSK data. This makes it easy to  
               verify the solar incidence angle when 
               the target is modeled as an  ellipsoid. 
               ./
               <a href="subslr_c.html">subslr_c</a> ( submth[i], target,  et, 
                          fixref,    abcorr,  obsrvr,
                          ssolpt,    &amp;trgepc, srfvec  );

               /.
               Now find the sub-spacecraft point.  
               ./
               <a href="subpnt_c.html">subpnt_c</a> ( submth[i], target,  et, 
                          fixref,    abcorr,  obsrvr,
                          sscpt,     &amp;trgepc, srfvec  );

               /.
               Find the phase, solar incidence, and emission 
               angles at the sub-solar point on Mars as 
               seen from MGS at time `et'.  
               ./
               <b>illumf_c</b> ( ilumth[i], target,  ilusrc,
                          et,        fixref,  abcorr,
                          obsrvr,    ssolpt,  &amp;trgepc,
                          srfvec,    &amp;sslphs, &amp;sslsol,
                          &amp;sslemi,   &amp;sslvis, &amp;ssllit   );

               /.
               Do the same for the sub-spacecraft point. 
               ./
               <b>illumf_c</b> ( ilumth[i], target,  ilusrc,
                          et,        fixref,  abcorr,
                          obsrvr,    sscpt,   &amp;trgepc,
                          srfvec,    &amp;sscphs, &amp;sscsol,
                          &amp;sscemi,   &amp;sscvis, &amp;ssclit   );

               /.
               Convert the angles to degrees and write them out.     
               ./
               sslphs *= <a href="dpr_c.html">dpr_c</a>();
               sslsol *= <a href="dpr_c.html">dpr_c</a>();
               sslemi *= <a href="dpr_c.html">dpr_c</a>();

               sscphs *= <a href="dpr_c.html">dpr_c</a>();
               sscsol *= <a href="dpr_c.html">dpr_c</a>();
               sscemi *= <a href="dpr_c.html">dpr_c</a>();

               printf ( &quot;\n&quot;
                        &quot;   <b>illumf_c</b> method: %s\n&quot;
                        &quot;   <a href="subpnt_c.html">subpnt_c</a> method: %s\n&quot;
                        &quot;   <a href="subslr_c.html">subslr_c</a> method: %s\n&quot;
                        &quot;\n&quot;
                        &quot;      Illumination angles at the &quot;
                        &quot;sub-solar point:\n&quot;
                        &quot;\n&quot;
                        &quot;      Phase angle            (deg): %15.9f\n&quot;
                        &quot;      Solar incidence angle  (deg): %15.9f\n&quot;
                        &quot;      Emission angle         (deg): %15.9f\n&quot;
                        &quot;      Visible, Lit flags &quot;
                        &quot;(0 == false, 1 == true):  %d, %d\n&quot;,
                        ilumth[i],
                        submth[i],
                        submth[i],
                        sslphs,
                        sslsol,
                        sslemi,
                        (int)sslvis,
                        (int)ssllit                                    );

               if ( i == 0 )
               {
                  printf ( &quot;        The solar incidence angle &quot;
                           &quot;should be 0.\n&quot;
                           &quot;        The emission and phase &quot;
                           &quot;angles should be equal.\n&quot;          );
               }

               printf ( &quot;\n&quot;
                        &quot;      Illumination angles at the &quot;
                        &quot;sub-s/c point:\n&quot;
                        &quot;\n&quot;
                        &quot;      Phase angle            (deg): %15.9f\n&quot;
                        &quot;      Solar incidence angle  (deg): %15.9f\n&quot;
                        &quot;      Emission angle         (deg): %15.9f\n&quot;
                        &quot;      Visible, Lit flags &quot;
                        &quot;(0 == false, 1 == true):  %d, %d\n&quot;,
                        sscphs,
                        sscsol,
                        sscemi,
                        (int)sscvis,
                        (int)ssclit                                    );

               if ( i == 0 )
               {
                  printf ( &quot;        The emission angle &quot;
                           &quot;should be 0.\n&quot;
                           &quot;        The solar incidence &quot;
                           &quot;and phase angles should be equal.\n&quot;  );
               }               
            }
            printf ( &quot;\n&quot; );

            return ( 0 );
         }
 
 
   When this program was executed on a PC/Linux/gcc/64-bit platform,
   the output was:   
 

      UTC epoch is 2003 OCT 13 06:00:00 UTC

         <b>illumf_c</b> method: Ellipsoid
         <a href="subpnt_c.html">subpnt_c</a> method: Near Point/Ellipsoid
         <a href="subslr_c.html">subslr_c</a> method: Near Point/Ellipsoid

            Illumination angles at the sub-solar point:

            Phase angle            (deg):   138.370270685
            Solar incidence angle  (deg):     0.000000000
            Emission angle         (deg):   138.370270685
            Visible, Lit flags (0 == false, 1 == true):  0, 1
              The solar incidence angle should be 0.
              The emission and phase angles should be equal.

            Illumination angles at the sub-s/c point:

            Phase angle            (deg):   101.439331040
            Solar incidence angle  (deg):   101.439331041
            Emission angle         (deg):     0.000000002
            Visible, Lit flags (0 == false, 1 == true):  1, 0
              The emission angle should be 0.
              The solar incidence and phase angles should be equal.

         <b>illumf_c</b> method: DSK/Unprioritized
         <a href="subpnt_c.html">subpnt_c</a> method: DSK/Nadir/Unprioritized
         <a href="subslr_c.html">subslr_c</a> method: DSK/Nadir/Unprioritized

            Illumination angles at the sub-solar point:

            Phase angle            (deg):   138.387071677
            Solar incidence angle  (deg):     0.967122745
            Emission angle         (deg):   137.621480599
            Visible, Lit flags (0 == false, 1 == true):  0, 1

            Illumination angles at the sub-s/c point:

            Phase angle            (deg):   101.439331359
            Solar incidence angle  (deg):   101.555993667
            Emission angle         (deg):     0.117861156
            Visible, Lit flags (0 == false, 1 == true):  1, 0
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman   (JPL) 
   B.V. Semenov   (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.0.0, 04-APR-2017 (NJB) (BVS)

       16-AUG-2016 (NJB) (BVS)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   illumination angles general source with flags 
   lighting angles general source with flags
   phase angle general source with flags
   incidence angle general source with flags
   emission angle general source with flags
 </PRE>
<h4>Link to routine illumf_c source file <a href='../../../src/cspice/illumf_c.c'>illumf_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:37 2017</pre>

</body>
</html>

