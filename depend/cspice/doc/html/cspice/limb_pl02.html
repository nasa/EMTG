
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>limb_pl02</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>limb_pl02</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void limb_pl02 ( SpiceInt              handle,
                    ConstSpiceDLADescr  * dladsc,
                    ConstSpiceChar      * target,
                    SpiceDouble           et,
                    ConstSpiceChar      * fixref,
                    ConstSpiceChar      * abcorr,
                    ConstSpiceChar      * obsrvr,
                    SpiceInt              npoints,
                    SpiceDouble         * trgepc,
                    SpiceDouble           obspos   [3],
                    SpiceDouble           limbpts  [][3],
                    SpiceInt              plateIDs []     )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Deprecated: This routine has been superseded by the CSPICE routine
   <a href="limbpt_c.html">limbpt_c</a>. This routine is supported for purposes of backward
   compatibility only.

   Compute a set of points on the limb of a specified target body,
   where the target body's surface is represented by a triangular plate
   model contained in a type 2 DSK segment.
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/naif_ids.html">NAIF_IDS</a>
   <a href="../req/pck.html">PCK</a>
   <a href="../req/spk.html">SPK</a>
   <a href="../req/time.html">TIME</a>
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   BODY 
   GEOMETRY 
   MATH 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description 
   --------  ---  -------------------------------------------------- 
   handle     I   DSK handle.
   dlasdc     I   DLA descriptor of target body segment.
   target     I   Target body. 
   et         I   Observation epoch. 
   fixref     I   Body-fixed frame associated with target. 
   abcorr     I   Aberration correction. 
   obsrvr     I   Observer. 
   npoints    I   Number of points in limb set. 
   trgepc     O   Epoch associated with target center. 
   obspos     O   Position of observer in body-fixed frame. 
   limbpts    O   Limb point set. 
   plateIDs   O   DSK plate IDs of surface points.
  </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
  
   handle      is the DAS file handle of a DSK file open for read
               access.  This kernel must contain a type 2 segment that
               provides a plate model representing the entire surface
               of the target body.
 
   dladsc      is the DLA descriptor of a DSK segment representing the
               surface of a target body.
 
 
   target      is the name of the target body. `target' is
               case-insensitive, and leading and trailing blanks in
               `target' are not significant. Optionally, you may supply
               a string containing the integer ID code for the object.
               For example both &quot;MOON&quot; and &quot;301&quot; are legitimate strings
               that indicate the moon is the target body.
 
               This routine assumes that a kernel variable representing
               the target's radii is present in the kernel pool.
               Normally the kernel variable would be defined by loading
               a PCK file.
 
 
   et          is the epoch of participation of the observer, 
               expressed as ephemeris seconds past J2000 TDB: `et' is 
               the epoch at which the observer's position is 
               computed. 
 
               When aberration corrections are not used, `et' is also
               the epoch at which the position and orientation of the
               target body are computed.
 
               When aberration corrections are used, `et' is the epoch
               at which the observer's position relative to the solar
               system barycenter is computed; in this case the position
               and orientation of the target body are computed at
               et-lt, where `lt' is the one-way light time between the
               target body's center and the observer. See the
               description of `abcorr' below for details.
 
 
   fixref      is the name of the reference frame relative to which the
               output limb points are expressed. This must a
               body-centered, body-fixed frame associated with the
               target.  The frame's axes must be compatible with the
               triaxial ellipsoidal shape model associated with the
               target body (normally provide via a PCK): this routine
               assumes that the first, second, and third ellipsoid radii
               correspond, respectively, to the x, y, and z-axes of the
               frame designated by `fixref'.
 
               `fixref' may refer to a built-in frame (documented in 
               the Frames Required Reading) or a frame defined by a 
               loaded frame kernel (FK). 
 
               The orientation of the frame designated by `fixref' is 
               evaluated at epoch of participation of the target 
               body.  See the descriptions of `et' and `abcorr' for 
               details. 
 
 
   abcorr      indicates the aberration correction to be applied 
               when computing the observer-target position, the 
               orientation of the target body, and the target- 
               source position vector.  `abcorr' may be any of 
               the following. 
 
                  &quot;NONE&quot;     Apply no correction.  Compute the limb
                             points using the position of the observer
                             and target, and the orientation of the
                             target, at `et'.
 
               Let `lt' represent the one-way light time between the 
               observer and the target body's center. The following 
               values of `abcorr' apply to the &quot;reception&quot; case in 
               which photons depart from the target body's center at 
               the light-time corrected epoch et-lt and *arrive* at 
               the observer's location at `et': 
 
 
                  &quot;LT&quot;       Correct for one-way light time (also
                             called &quot;planetary aberration&quot;) using a
                             Newtonian formulation. This correction
                             yields the location of the limb points at
                             the approximate time they emitted photons
                             arriving at the observer at `et' (the
                             difference between light time to the
                             target center and light time to the limb
                             points is ignored).
  
                             The light time correction uses an 
                             iterative solution of the light time 
                             equation. The solution invoked by the 
                             &quot;LT&quot; option uses one iteration. 
 
                             The target position as seen by the 
                             observer and the rotation of the target 
                             body are corrected for light time. 
 
                  'LT+S'     Correct for one-way light time and stellar
                             aberration using a Newtonian formulation.
                             This option modifies the position obtained
                             with the &quot;LT&quot; option to account for the
                             observer's velocity relative to the solar
                             system barycenter. The result is the
                             apparent limb as seen by the observer.
 
                  &quot;CN&quot;       Converged Newtonian light time correction.
                             In solving the light time equation, the
                             &quot;CN&quot; correction iterates until the
                             solution converges.  The position and
                             rotation of the target body are corrected
                             for light time.
 
                  'CN+S'     Converged Newtonian light time 
                             and stellar aberration corrections. 
 
 
   obsrvr      is the name of the observing body.  This is typically 
               a spacecraft, the Earth, or a surface point on the 
               Earth.  `obsrvr' is case-insensitive, and leading and 
               trailing blanks in `obsrvr' are not significant. 
               Optionally, you may supply a string containing the 
               integer ID code for the object.  For example both 
               &quot;EARTH&quot; and &quot;399&quot; are legitimate strings that indicate 
               the Earth is the observer. 
 
                   
   npoints     is the number of limb points to compute. 
 
    </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   trgepc      is the &quot;target epoch.&quot;  `trgepc' is defined as follows: 
               letting `lt' be the one-way light time between the 
               target center and observer, `trgepc' is either the 
               epoch et-lt or `et' depending on whether the requested 
               aberration correction is, respectively, for received 
               radiation or omitted. `lt' is computed using the 
               method indicated by `abcorr'. 
 
               `trgepc' is expressed as seconds past J2000 TDB. 
 
 
   obspos      is the vector from the center of the target body at 
               epoch `trgepc' to the observer at epoch `et'.  `obspos' is 
               expressed in the target body-fixed reference frame 
               `fixref', which is evaluated at `trgepc'. 
 
               `obspos' is returned to simplify various related 
               computations that would otherwise be cumbersome.  For 
               example, the vector `xvec' from the observer to the 
               Ith limb point can be calculated via the call 
 
                  <a href="vminus_c.html">vminus_c</a> ( limbpts[i], obspos, xvec );
 
               The components of `obspos' are given in units of km. 
 
 
   limbpts     is an array of points on the limb of the target.
               The ith point is contained in the array elements
 
                   limbpts[i][j],  j = 0, 1, 2

               As described above, each limb point lies on a ray
               emanating from the center of the target and passing
               through a limb point on the target's reference
               ellipsoid. Each limb point *on the reference ellipsoid*
               is the point of tangency of a ray that emanates from the
               observer.  Measured in a cylindrical coordinate system
               whose Z-axis is parallel to the observer-target vector,
               the magnitude of the separation in longitude between the
               limb points is
 
                  2*Pi / npoints  
                                       
               The limb points are expressed in the body-fixed 
               reference frame designated by `fixref'; the 
               orientation of the frame is evaluated at `trgepc'.
               Units are km. 
 
 
   plateIDs    is an array of integer ID codes of the plates on which
               the limb points are located.  The ith plate ID
               corresponds to the ith limb point. These ID codes can
               be use to look up data associated with the plates, such
               as the plates' vertices or outward normal vectors.
 
               `plateIDs' should be declared by the caller

                  SpiceInt plateIDs [npoints];
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1)  If the target name `target' cannot be mapped 
       to a body ID code, the error SPICE(IDCODENOTFOUND)
       signaled. 

   2)  If the observer name `obsrvr' cannot be mapped to a body ID
       code, the error SPICE(IDCODENOTFOUND) is signaled. 

   3)  If `obsrvr' and `target' map to the same NAIF integer ID codes,
       the error SPICE(BODIESNOTDISTINCT) is signaled.

   4)  If the input frame name `fixref' cannot be mapped 
       to a frame ID code, the error SPICE(UNKNOWNFRAME) is 
       signaled. 
 
   5)  If the frame designated by `fixref' is not centered 
       on the target, the error SPICE(INVALIDFRAME) is 
       signaled. 
 
   6)  If the set size `npoints' is not at least 1, the error 
       SPICE(INVALIDCOUNT) is signaled.
 
   7)  If any of the reference ellipsoid's semi-axis lengths is
       non-positive, the error will be diagnosed by a routine in the
       call tree of this routine.
 
   8)  If radii for the target body are not available in the kernel
       pool, the error will be diagnosed by a routine in the call tree
       of this routine.  If radii are available but the target body
       does not have three radii, the error SPICE(INVALIDCOUNT) will be
       signaled.
 
   9)  If any SPK look-up fails, the error will be diagnosed by 
       a routine in the call tree of this routine. 
 
  10)  If a DSK providing a DSK type 2 plate model has not been
       loaded prior to calling <a href="llgrid_pl02.html">llgrid_pl02</a>, the error will be
       diagnosed and signaled by a routine in the call tree of this
       routine.

  11)  If the segment associated with the input DLA descriptor is not
       of data type 2, the error SPICE(WRONGDATATYPE) is signaled.

  12)  If a surface point cannot be computed because the ray corresponding
       to a longitude/latitude pair fails to intersect the target
       surface as defined by the plate model, the error will be
       diagnosed by a routine in the call tree of this routine.
 
  13)  If the DSK segment identified by `dladsc' is not for the
       body identified by `target', the error SPICE(DSKTARGETMISMATCH)
       is signaled.

  14)  If any input string pointer is null, the error SPICE(NULLPOINTER)
       will be signaled.
 
  15)  If any input string has length zero, the error SPICE(EMPTYSTRING)
       will be signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   Appropriate DSK, SPK, PCK, and frame kernels must be loaded by the 
   calling program before this routine is called.  
 
   The following data are required: 
 
      - DSK data:  a DSK file containing a plate model representing the
        target body's surface must be loaded. This kernel must contain
        a type 2 segment that contains data for the entire surface of
        the target body.

      - SPK data: ephemeris data for target and observer must be
        loaded. If aberration corrections are used, the states of both
        objects relative to the solar system barycenter must be
        calculable from the available ephemeris data. Typically
        ephemeris data are made available by loading one or more SPK
        files via <a href="furnsh_c.html">furnsh_c</a>.
 
      - PCK data: triaxial radii for the target body must be loaded
        into the kernel pool. Typically this is done by loading a text
        PCK file via <a href="furnsh_c.html">furnsh_c</a>.
 
      - Further PCK data:  rotation data for the target body must 
        be loaded.  These may be provided in a text or binary PCK 
        file.  
 
      - Frame data:  if a frame definition is required to convert 
        the observer and target states to the target body-fixed 
        frame designated by `fixref', that definition must be 
        available in the kernel pool.  Typically the definitions of 
        frames not already built-in to SPICE are supplied by loading 
        a frame kernel. 
 
   In all cases, kernel data are normally loaded once per program 
   run, NOT every time this routine is called. 
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
  
   Boundaries of visible regions on an arbitrary surface are often
   complicated point sets:  boundaries of mountains and craters, if
   present, may contribute to the overall set.  To make the limb
   computation tractable, we simplify the problem by using a reference
   ellipsoid for guidance.  We compute a set of limb points on the
   reference ellipsoid for the target body, then use those points to
   define the latitudes and longitudes of limb points on the surface
   defined by the specified triangular shape model.  As such, the set
   of limb points found by this routine is just an approximation.
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as input,
   the compiler and supporting libraries, and the machine specific
   arithmetic implementation.

 
   1)  Compute sets of limb points on Phobos as seen from Mars. Perform
       a consistency check using the emission angle at each point,
       where the emission angle is computed using both a reference
       ellipsoid and the actual plate model surface and surface normal.
       We expect to see an emission angle of approximately 90 degrees.
 
       This program loads SPICE kernels via a meta-kernel.  The
       contents of the meta-kernel used to produce the results shown 
       below are:


          \begindata

             KERNELS_TO_LOAD = ( 'naif0009.tls'
                                 'pck00009.tpc'
                                 'mar085.bsp' 
                                 'de421.bsp'   )
          \begintext
 

       The DSK is loaded separately (this is a temporary inconvenience
       that will be remedied when the KEEPER system is updated to handle
       DSKs).  The DSK used for this computation is

          phobos.3.3.bds

       Source code follows.
      

          #include &lt;stdio.h&gt;
          #include &lt;math.h&gt;
          #include &quot;SpiceUsr.h&quot;

          int main()
          {
             /.
             Prototypes 
             ./
             void <b>limb_pl02</b> ( SpiceInt              handle,
                              ConstSpiceDLADescr  * dladsc,
                              ConstSpiceChar      * target,
                              SpiceDouble           et,
                              ConstSpiceChar      * fixref,
                              ConstSpiceChar      * abcorr,
                              ConstSpiceChar      * obsrvr,
                              SpiceInt              npoints,
                              SpiceDouble         * trgepc,
                              SpiceDouble           obspos   [3],
                              SpiceDouble           limbpts   [][3],
                              SpiceInt              plateIDs []     );

             /.
             Local parameters
             ./
             #define  FILSIZ         256 
             #define  NPOINTS        3
             #define  NTYPES         2
             #define  TOL            ( 1.e-12 )
             #define  CORLEN         15
             #define  TYPLEN         81 
             #define  TIMLEN         41

             /.
             Local variables
             ./
             SpiceBoolean            found;

             SpiceChar             * abcorr = &quot;LT+S&quot;;
             SpiceChar               dsk     [ FILSIZ  ];
             SpiceChar             * fixref = &quot;IAU_PHOBOS&quot;;
             SpiceChar               meta    [ FILSIZ  ];


             SpiceChar             * obsrvr = &quot;Mars&quot;;
             SpiceChar             * target = &quot;Phobos&quot;;
             SpiceChar             * utcstr = &quot;2007 FEB 9 00:00:00 UTC&quot;;
             SpiceChar               timstr  [ TIMLEN];

             SpiceDLADescr           dladsc;

             SpiceDouble             emissn;
             SpiceDouble             obspos    [3];
             SpiceDouble             phase;
             SpiceDouble             radius;
             SpiceDouble             solar;
             SpiceDouble             trgepc;
             SpiceDouble             et;
             SpiceDouble             lat;
             SpiceDouble             lon;
             SpiceDouble             limbpts    [NPOINTS][3];

             SpiceInt                handle;
             SpiceInt                i;
             SpiceInt                plateIDs  [NPOINTS];

             /.
             Prompt for the name of a meta-kernel specifying
             all of the other kernels we need.  Load the
             metakernel.
             ./
             <a href="prompt_c.html">prompt_c</a> ( &quot;Enter meta-kernel name &gt; &quot;, FILSIZ, meta );
             <a href="furnsh_c.html">furnsh_c</a> ( meta );

             /.
             Prompt for the name of the DSK to read.
             ./
             <a href="prompt_c.html">prompt_c</a> ( &quot;Enter DSK name         &gt; &quot;, FILSIZ, dsk );

             /.
             Open the DSK file for read access.
             We use the DAS-level interface for
             this function.
             ./
             <a href="dasopr_c.html">dasopr_c</a> ( dsk, &amp;handle );

             /.
             Begin a forward search through the
             kernel, treating the file as a DLA.
             In this example, it's a very short
             search.
             ./
             <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;dladsc, &amp;found );

             if ( !found  )
             {
                /.
                We arrive here only if the kernel
                contains no segments.  This is
                unexpected, but we're prepared for it.
                ./
                <a href="setmsg_c.html">setmsg_c</a> ( &quot;No segments found in DSK file #.&quot;);
                <a href="errch_c.html">errch_c</a>  ( &quot;#&quot;,  dsk                         );
                <a href="sigerr_c.html">sigerr_c</a> ( &quot;SPICE(NODATA)&quot;                   );
             }

             /.
             If we made it this far, `dladsc' is the
             DLA descriptor of the first segment.

             Convert the observation time to seconds past J2000 TDB.
             ./
             <a href="str2et_c.html">str2et_c</a> ( utcstr, &amp;et );

             <a href="timout_c.html">timout_c</a> ( et, 
                        &quot;YYYY-MON-DD &quot;
                        &quot;HR:MN:SC.### ::TDB(TDB)&quot;,
                        TIMLEN,
                        timstr                    );

             printf ( &quot;\n\n&quot;
                      &quot;   Observer:               %s\n&quot; 
                      &quot;   Target:                 %s\n&quot; 
                      &quot;   Observation epoch:      %s\n&quot; 
                      &quot;   Aberration correction:  %s\n&quot;
                      &quot;   Body-fixed frame:       %s\n&quot;, 
                      obsrvr,
                      target,
                      timstr,
                      abcorr,
                      fixref                            );

             /.
             Now compute grid of limb points.
             ./
             <b>limb_pl02</b> ( handle,   &amp;dladsc,   
                         target,   et,       fixref,   abcorr,
                         obsrvr,   NPOINTS,  &amp;trgepc,  obspos,
                         limbpts,   plateIDs                    );

             /.
             Display the limb points. 
             ./
             for ( i = 0;  i &lt; NPOINTS;  i++  )
             {
                printf ( &quot;\n&quot; );

                <a href="reclat_c.html">reclat_c</a> ( limbpts[i], &amp;radius, &amp;lon, &amp;lat );

                printf ( 
                &quot;      Limb point %d:\n&quot;
                &quot;         Radius                     (km):  %f\n&quot; 
                &quot;         Planetocentric longitude   (deg): %f\n&quot; 
                &quot;         Planetocentric latitude    (deg): %f\n&quot;
                &quot;         Plate ID:                         %d\n&quot;,
                (int)i,
                radius,
                lon * <a href="dpr_c.html">dpr_c</a>(),
                lat * <a href="dpr_c.html">dpr_c</a>(),
                (int)plateIDs[i]                                );


                /.
                Compute the illumination angles using an ellipsoidal
                representation of the target's surface. The role of
                this representation is to provide an outward surface
                normal.
                ./
                <a href="illum_c.html">illum_c</a> ( target,  et,         abcorr, 
                          obsrvr,  limbpts[i],  &amp;phase,  
                          &amp;solar,  &amp;emissn             );

                printf ( 
                &quot;            &quot;
                &quot;emission angle derived using\n&quot;
                &quot;            &quot;
                &quot;   - an ellipsoidal reference surface        (deg):&quot;
                &quot; %f\n&quot;,              
                emissn  * <a href="dpr_c.html">dpr_c</a>()                                      );

                /.
                Compute the illumination angles at the limb point
                using the actual plate model surface normal.
                ./
                <a href="illum_pl02.html">illum_pl02</a> ( handle, &amp;dladsc, target,   et,
                             abcorr, obsrvr,  limbpts[i], 
                             &amp;phase, &amp;solar,  &amp;emissn      );               

                printf ( 
                &quot;            &quot;
                &quot;   - plate model's surface and normal vector (deg):&quot;
                &quot; %f\n&quot;,
                emissn  * <a href="dpr_c.html">dpr_c</a>()                                      );
             }

             printf ( &quot;\n&quot; );

             /.
             Close the kernel.  This isn't necessary in a stand-
             alone program, but it's good practice in subroutines
             because it frees program and system resources.
             ./
             <a href="dascls_c.html">dascls_c</a> ( handle );

             return ( 0 );
          }


   
   When this program was executed on a PC/Linux/gcc platform, 
   the output was:
 

     Enter meta-kernel name &gt; limb_meta
     Enter DSK name         &gt; phobos.3.3.bds


        Observer:               Mars
         Target:                 Phobos
         Observation epoch:      2007-FEB-09 00:01:05.184 (TDB)
         Aberration correction:  LT+S
         Body-fixed frame:       IAU_PHOBOS

            Limb point 0:
               Radius                     (km):  11.548564
               Planetocentric longitude   (deg): 91.916308
               Planetocentric latitude    (deg): -0.001421
               Plate ID:                         229468
                  emission angle derived using
                     - an ellipsoidal reference surface        (deg): 90.002150
                     - plate model's surface and normal vector (deg): 110.821147

            Limb point 1:
               Radius                     (km):  9.539431
               Planetocentric longitude   (deg): -87.644392
               Planetocentric latitude    (deg): 59.998173
               Plate ID:                         235885
                  emission angle derived using
                     - an ellipsoidal reference surface        (deg): 89.999635
                     - plate model's surface and normal vector (deg): 97.682098

            Limb point 2:
               Radius                     (km):  9.040443
               Planetocentric longitude   (deg): -87.860468
               Planetocentric latitude    (deg): -59.996395
               Plate ID:                         17964
                  emission angle derived using
                     - an ellipsoidal reference surface        (deg): 89.996577
                     - plate model's surface and normal vector (deg): 69.169892
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   1)  The quality of the results produced by this routine depend on how
       well the target body's surface is approximated by the target's
       reference ellipsoid.  This routine will *not* produce meaningful
       results for body shapes such as &quot;dumbbells.&quot;
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman    (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 2.0.0, 23-JUL-2016 (NJB) 
 
      Added and moved <a href="failed_c.html">failed_c</a> calls.

      Include file references have been updated. Integer output
      format in the example program has been updated. Updated
      example program output to reflect bug fix of 29-APR-2014.

   -Beta Version 3.0.0, 24-JUN-2014 (NJB) (EDW)
   
       Added <a href="failed_c.html">failed_c</a> checks to ensure return before 
       performance of arithmetic computations using
       invalid operands. Added check for target equal
       to observer.

    Last update was 29-APR-2014 (NJB)
       
       Bug fix: corrected limb point selection so that
       points have uniform spacing in longitude, measured
       in a frame centered on the observer-target center 
       line.

       Bug fix: added <a href="sigerr_c.html">sigerr_c</a> call in error handling
       branch for invalid value of `npoints'.

       Bug fix: added check for body-fixed frame not 
       centered on target.

       Bug fix: added error handling for null input string
       pointers and empty strings.

       Added check for mismatch between target and central
       body of DSK segment.

       Added test of <a href="failed_c.html">failed_c</a> after <a href="spkpos_c.html">spkpos_c</a> call.

       Changed argument name `fixfrm' to `fixref'.

       The target name to ID conversion is now performed
       in-line. The short error message for a failed 
       conversion is not SPICE(IDCODENOTFOUND).

       Header correction: the error case of an unmapped 
       observer name is now listed.
       

   -Beta Version 2.1.0, 14-MAY-2010 (NJB)

       Updated header example. Added include statement
       for header pl02.h.

   -Beta Version 2.0.0, 12-FEB-2010 (NJB)  

       Updated to include

          SpiceDSK.h

   -Beta Version 1.0.0, 27-FEB-2007 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   find limb on plate model
   find limb on triangular shape model
 </PRE>
<h4>Link to routine limb_pl02 source file <a href='../../../src/cspice/limb_pl02.c'>limb_pl02.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:38 2017</pre>

</body>
</html>

